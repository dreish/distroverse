> Java 3D examples at:
  http://java.sun.com/products/java-media/3D/collateral/examples.zip
> API documentation at: http://download.java.net/media/java3d/
  builds/release/1.5.1/java3d-1_5_1-api-docs.zip
> M-Th: 50, Fr: 75, Sa/Su: 250

- To do for 0.01:
  - Make a client that only understands the about:hello URL
    + Obviously need some sort of rendering window thingy
      + Download jME
      + Get an example app; see how they do it
      + Get the client running s.t. it produces a window but doesn't do
        anything with it
    - Implement ultra-dumb setUrl()
      - At top level, this sets the URL display in the HUD
        x Use FengGUI in a GameState for this
          > Can't use FengGUI; it uses the CDDL license, which is not
            GPL-compatible
        + Find an example app that displays text
          > jmetest/effects/water/TestProjectedWater.java
          > Uses com.jme.scene.Text
        + Create TextDisplayBar class
        - For now, just display a bare line of text with a Text object
      - If URL is about:hello, reset the render window and dump a
        predefined set of objects into it (maybe loaded from a file)
        - Implement AboutControllerPipeline()
          - Does my TriangleStripArray-based approach translate to jME?
  - Add the ability to connect to a remote server and get a proxy
    - Implement full DvtpFlexiStreamer and DvtpFlexiParser
      - Anything that starts with a 0 byte is an object; otherwise
        an UTF-8 string
      - For objects, next byte indicates how many bytes that follow
        give the size of the object
      - If object is Externalizable, use that
      - Otherwise, if object is Serializable, use that
      - For streaming String objects, make sure they don't encode to
        an initial NUL; if they do, use the object method
    - Add to setUrl() ability to handle real URLs
      - Connect to server and request proxy URL
      - If it is the same as the currently-running proxy, send the
        proxy a SetUrl object
      - Otherwise, download a new server and start it up with the
        given SetUrl object
      x In either case, get a result back and show the effective URL
        > This will just be a general UrlChange object, async
    - Listen for, and handle, messages from the proxy
  - Add movement objects
  x Deform the points according to my trig functions and see whether
    it produces decent-looking planets
  x Write a simple Java3D app
    + Create a cube
    > Nevermind Java3D; using jME
    x Create methods to set its position, velocity, & acceleration
    x Create methods to do the same for its orientation
  - core.DataPackage (abstract)
    - Find out whether something like this already exists
      > Presents a simple array of objects
      > Serialization produces different results depending on 
        implementation
    - core.DataPackagePlain
      > No compression
  	- core.DataPackageGzip
  	  > Gzips entire package to serialize
  	- core.DataPackageTgz
  	  > Wraps everything in a gzipped tarball
  + Check everything into SVN
    > Too easy!
  + Set up backups for svn repository
    > In case things get corrupted
    + 2 daily and 5 weekly
  + <T> T foldr( T[], folder )
    + Why can't I have a public abstract static method (in
      FoldingFunction)?
      > Doesn't need to be static, does need to be abstract
    x How does Callable work, and would it be sufficient for this?
  + PointArray class in DVTP
  + Package up a TriangleStripArray into a Shape class
  x Test performance of Java3D and of pushing objects from client to
    server; compare
    > No real doubts about the design at this point, unless it turns out
      to be clearly unusable
  + Create a spheroid polyhedron with N roughly equally-spaced
    points
    > BallFactory isa ShapeFactory, Generate() returns a Shape
    > It might be easyish to do this by subclassing LatheShape3D,
      though it would not result in equally-spaced points
    > Otherwise it means using Java3D's GeometryArray
      > Specifically TriangleStripArray
    + Divide sphere into N equally spaced circles of latitude
    	> They're only equally-spaced for mAspectRatio = 1.0, now
    x Calculate distance between those circles, 'd'
    + For each circle, find M: the number of evenly-spaced points
      such that the distance between them is closer to 'd' than for
      any other number
      > This is actually simple enough: just sin(latitude) *
        (n_circles * 2 - 2)
    + Make an array of points starting at prime meridian +
      0.5*d*(row%2)
    + ShapeFactory.GenerateSurface( Point3d verts[][] )
    	+ Need to flesh out the Shape class for this
    	  > Will every shape be a TriangleStripArray?
    	    > Yes, apparently so
    	    > I might want some way to specify smoothed forms, or
    	      perhaps at least a sphere primitive
      + For each consecutive pair of arrays of points, create a row
    	  in the TriangleStripArray
        x The vertex count is the sum of the number of points in
          the two rows, plus two because two points are used twice
          > No way of knowing how many points will be used without
            tracing through the points
        > It shouldn't matter which side the array starts with
  x Make a simple server that sends the same shape to any client that
    connects to it
    > HelloServer, the server equivalent to Hello World
  + Make a simple server that just echos dumb responses to commands
    > ElizaServer
    > Using the chargen server example on p393 of JNP and the number
      server on p273 of Java in a Nutshell
    + DvtpServer base class
      + Construct with DvtpListener implementation
      + DvtpListener interface/base class
      x DvtpThreadedListener
        x Accepts connections on port N -- 808?
        x Forks a thread for each new connection
        x Listens for commands and passes them to the DvtpServer
      + DvtpMultiplexedListener
        + Accepts connections on port mServer.getListenPort()
        + Uses a selector to serve all connections in a single thread
        + Passes commands to the DvtpServer, mServer
      + Dispatches commands to functions that must be implemented by
        subclass of DvtpServer
    + NetOutQueue
      + Constructed with an ObjectStreamer object and max_length
        > The max_length is artificially enforced to prevent the queue
          from growing without bound when a client becomes net-dead
      + Either ObjectStreamer or NetOutQueue should have a method for
        writing the buffer to the SocketChannel
      x Any time there is an object in the queue, it asks the
        ObjectStreamer for up to N bytes to send
      + NetOutQueue tells the Selector to wake-on-writable when it
        goes from empty to non-empty
        > activateNetworkWriter()
      + ObjectStreamer tells the Selector (through NetOutQueue) to
        stop waking-on-writable when it finishes writing the last
        object (there must be only one NetOutQueue in use for a given 
        network connection)
        > stopNetworkWriter()
      + The ObjectStreamer can access and delete the head of the queue
        + Make a StringLineStreamer to illustrate (and to reimplement
          the server)
      + The ObjectStreamer will keep a pointer to the next chunk to
        feed
      + An ObjectStreamer could take file objects and feed bytes; it
        could serialize large objects to disk and feed out of that; it
        could take strings that are always terminated by \r\n
    + NetInQueue
      + Constructed with an ObjectParser object; there is an
        ObjectParser to go with every ObjectStreamer
      + Reads data until the ObjectParser says there is a complete
        object; the Parser returns the object
      x NetInQueue can either have a callback to handle the received
        objects synchronously, or it can have BlockingQueue semantics
      + NetInQueue maintains a list of threads that need to be
        notified when the queue is non-empty
        x These are QueueReaderThread{}s, with a test-and-set method
          for determining whether it can be devoted to working on this
          queue
        + For simplicity's sake, for now, it will just notify() the
          first thread in the linked list, and I'll create a thread to
          watch each in-queue
      + Implement a StringLineParser as an example
    + ElizaServer responds to the following commands:
      + LOCATION //blah/blah/blah
        > This is for dvtp:// URLs
        + To anyone who connects, send the URL of the proxy to DL
          + Currently sending a random string; test this
          + Reimplement using new NetInQueue/NetOutQueue classes
            x Attach a Util.Pair<NetInQueue,NetOutQueue> to tmp_key in
              DvtpMultiplexedListener.acceptConnection()
              + Write Util.Pair<A,B>
            + Attach a generic session object, which has the in queue
              and out queue
              + Create NetSession class
            + The NIQ and NOQ classes must contain references to their
              sessions
            + Each SelectionKey will have the session attached to it
            + Nobody calls activateQueueWatcher()
            + Need to create a thread to watch the input queue and add
              responses to the output queue
              x handleCommand takes a NetSession
                > Takes a noq, from which one can get the session
              + Create one thread to watch all connections in
                DvtpMultiplexedListener constructor
                + NetInQueueWatcher<T>
                + DvtpMultiplexedListener cannot be generic on T
                + Implement niqw<Object> as DvtpInQueueStringWatcher
                  + Construct with reference to server
                  + handleNetInObject() dispatches command with
                    mServer.handleCommand()
                    x Where do I get the client and buffer for
                      handleCommand()?
                      > I don't
                    + Change handleCommand() to write to a NetOutQueue
              + With each new connection opened, add the input queue
                to the watcher thread and niq.addQueueReader( t )
              + Need to make sure everything gets deleted when the
                connection is closed
                > This should just be a matter of removing the queue
                  from the queue watcher thread
                > Might want to add a special close-connection object
                  to the output queue?  null?  Or add a close-queue
                  method to avoid losing generality?
        + Debug
          + baos is 1024 bytes long, even though the packet sent was
            only 9 bytes long
          + mQueueWatchers is empty when activateQueueWatcher() gets
            called
        + Try two parallel connections to the same running server
          > Everything works as promised
      + GET //blah/blah/blah
        > This is for WWW-like resource URLs (dvrp?)
        x Result is a single length-prefixed object (as in DVTP),
          which may be an error object, such as resource not found
        x After this, the connection reverts back to line-by-line
      + PROXYOPEN <internal-identifier>
        > The handshake, not used in HelloServer, closes immediately
        > Not a good idea to throw an exception or otherwise bail out
          because of this message; makes the server easy to crash
    x The proxy doesn't bother trying to connect back to the server,
      and just sends the client a shape
      > Normally it would connect to port 808 as well, sending a proxy
        handshake instead of a client handshake; this server ignores
        the handshake altogether
    x Does anything need to be made volatile?
      > Worry about this later
  + Add a Log class and stop printing directly to stderr

- To do for 0.02:
  - Add textures to Shape class
    - Specify color of each triangle
  - Override default serialization in PointArray to guarantee that the
    protocol doesn't change due to changes in Point3d's serialization
  - Reimplement ball factory with a stack of LazyPolygons
    - LazyPolygon( origin, top_vector, side_vector, n_sides )
      - get(n) -> vertex of polygon
        - where n % n_sides == 0 -> origin + top_vector
        - where (n % n_sides) * 4 == n_sides -> origin + side_vector
      - Could make this iterable, no?
    > This should hopefully simplify generation of sections of a ball,
      as well as possibly being useful for other things
  - Add better logging facilities

> Required for 1.0:
  > Client
    > Figure animations
    > Sound
    > Inventory system with remote object browser integration
  > Server
    > Darc
    > OpenID for logins

- Future:
  - Textures must be specifiable as URLs (?) or else they can only be
    loaded from the DVTP server, because that's all the proxy can
    connect to
  - Add support for Scheme source code proxy (using SISC)
  - Need a test that exposes that a server is not threadsafe
    - Tests can run with N threads; good values of N to test would be 1,
      2, 10, 100, maximum that will fit in memory
    - Test that a sequence of objects inserted into a NetOutQueue are
      all received at the other end
  - Switch to a better language targeting the JVM, once something mature
    emerges
    > Probably Rhino
    > Also hyped are Scala, and ... okay, nothing is as hyped as Scala,
      but maybe that's just because they all got together and ambushed
      the comments on
      http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html
    > Maybe Jython or JRuby
    > Maybe the architecture is:
      > Java or fully Java-callable libraries
      > Other projects in other languages, at a higher level
  - Client: master volume control and mute keystroke
  - Client: prompt user if site requests resize; one option should
    defeat malicious sites that flood the user with resize requests and
    make the client unusable without killing/restarting (i.e., "Never
    for this site")
  - Client: prompt user if site requests all heads-up UI elements be
    hidden (pointing out that they can be brought back by selecting the
    menu "Interface / (Un)hide all")
  - Client: any grayed-out menu item must explain why it is disabled
  - iTunes-like interface for managing in-world objects and inventory
    > Ideally, there would be a single interface for both categories,
      but that raises a big question mark about how (and where) to
      implement such a thing
      > With a protocol for passing object directories around; it has to
        be done
  - Editor with syntax highlighting
    - Proxy sends client a bunch of HTML
      - <noedit></noedit>?  Is there a standard way to do that?
    - Client renders HTML in an editing box
    - Updates and/or keystrokes are sent back to the proxy; proxy can
      send back updates with new HTML tags as well
    - Named colors would provide an easy way to configure color schemes
      at the client side (?)
  - Standardize Autofill EARLY
    > That is, if there's any ablity to fill out forms with things like
      name, address, etc., standardize the field names and implement an
      auto-fill method early on
  - Switch to JMonkeyEngine
  x WibbleConfrobulator class
  - When graying out a menu item, give a reason for doing so; hovering
    over (or selecting) the menu item shows the reason
  - URLs should have spaces and other illegal chars removed in the
    address part, not converted to %XX
  - Distroversity!  The name is too good not to use
    > a.k.a. DVU (but this also refers to a far-right party in Germany)
    - Darc tutorials:
      - For people who have never programmed before
      - For people with limited programming experience in one language
        - Visual Basic (see "never programmed before")
        - Java
        - Perl
        - Python
      - For people with extensive programming experience in various
        languages, but no Lisp (for shame!)
      - For Lisp hackers who have never tried Arc
      - For Arc hackers
        - The shortest and easiest one to write; do this first
  x Distroplane: object scripting bytecode language
    > Distrocode?
    x Objects have properties, some of which can be attached bytecode
    x Message passing between objects
    x previous_object()->owner() and this_person(), just like LPMUD
    x Public/private/protected methods:
      x If a method is defined as public, it has property 'visibility =
        'public
      x Default message receiver in class Object does this when called
        for a message from another object:
        [method_object getProperty visibility]
        > Shorthand for (send method_object 'getProperty 'visibility)
        x If result is 'public, the method is called
        x If result is 'private, the method is not called
        x If result is 'protected,
          x Message receiver then checks whether the sender of the
            message is owned by the same user as itself; if so, method
            is called, else not
    > This idea has changed significantly; see notes
  - Configuration of new server:
    - Menu: World/Create/v1.0
      - Also have menu: World/Create/Email me version news...
        - Pops up window saying, "Would you like to be emailed when new
          versions of Distroplane are available?  Enter the address to
          which mail should be sent:" along with checkboxes:
          - Major stable versions (v1.0, v1.2, v2.0, etc.)
          - Minor stable versions (v1.0.8, v1.0.9, v1.2.0, etc.)
          - All minor versions (v1.0.8, v1.1.32, v1.1.33, v1.0.9, etc.)
    - Ask for name of world (should probably be renamable later)
    - Download Distroplane class, create a directory for it to run in
    - Start Distroplane with current user's public identity info set as
      Creator
    - Initially, only allow the Creator to connect
    - Connect to world; use in-world interface to set it up
      - An avatar with the Creator bit set can access all protected
        methods of every object automatically
      - A Creator connecting to a Distroplane sees the message, "You are
        the Creator of this world" with a "Renounce" button.  (Help
        question mark should explain that "renouncing" is temporary
        only, and that transferring of Creatorhood can be done through
        the World Configurator object, which is the only object floating
        in the void in a newly-created Distroplane, and which can be
        summoned again with World menu >> Summon Configurator)
  - Auto-compress groups of queue objects when the output queue gets
    full
