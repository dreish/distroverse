> Java 3D examples at:
  http://java.sun.com/products/java-media/3D/collateral/examples.zip
> API documentation at: http://download.java.net/media/java3d/
  builds/release/1.5.1/java3d-1_5_1-api-docs.zip
> M-Th: 50, Fr: 75, Sa/Su: 250

- To do for 0.01:
  - Play around with planet-building ideas
    + Create a spheroid polyhedron with N roughly equally-spaced
      points
      > BallFactory isa ShapeFactory, Generate() returns a Shape
      > It might be easyish to do this by subclassing LatheShape3D,
        though it would not result in equally-spaced points
      > Otherwise it means using Java3D's GeometryArray
        > Specifically TriangleStripArray
      + Divide sphere into N equally spaced circles of latitude
      	> They're only equally-spaced for mAspectRatio = 1.0, now
      x Calculate distance between those circles, 'd'
      + For each circle, find M: the number of evenly-spaced points
        such that the distance between them is closer to 'd' than for
        any other number
        > This is actually simple enough: just sin(latitude) *
          (n_circles * 2 - 2)
      + Make an array of points starting at prime meridian +
        0.5*d*(row%2)
      + ShapeFactory.GenerateSurface( Point3d verts[][] )
      	+ Need to flesh out the Shape class for this
      	  > Will every shape be a TriangleStripArray?
      	    > Yes, apparently so
      	    > I might want some way to specify smoothed forms, or
      	      perhaps at least a sphere primitive
        + For each consecutive pair of arrays of points, create a row
      	  in the TriangleStripArray
          x The vertex count is the sum of the number of points in
            the two rows, plus two because two points are used twice
            > No way of knowing how many points will be used without
              tracing through the points
          > It shouldn't matter which side the array starts with
    - Make a simple server that sends the same shape to any client that
      connects to it
      > HelloServer, the server equivalent to Hello World
      > Using the chargen server example on p393 of JNP and the number
        server on p273 of Java in a Nutshell
      + DvtpServer base class
        + Construct with DvtpListener implementation
        + DvtpListener interface/base class
        x DvtpThreadedListener
          x Accepts connections on port N -- 808?
          x Forks a thread for each new connection
          x Listens for commands and passes them to the DvtpServer
        + DvtpMultiplexedListener
          + Accepts connections on port mServer.getListenPort()
          + Uses a selector to serve all connections in a single thread
          + Passes commands to the DvtpServer, mServer
        + Dispatches commands to functions that must be implemented by
          subclass of DvtpServer
      - NetOutQueue
        + Constructed with an ObjectStreamer object and max_length
          > The max_length is artificially enforced to prevent the queue
            from growing without bound when a client becomes net-dead
        - Either ObjectStreamer or NetOutQueue should have a method for
          writing the buffer to the SocketChannel
        x Any time there is an object in the queue, it asks the
          ObjectStreamer for up to N bytes to send
        + NetOutQueue tells the Selector to wake-on-writable when it
          goes from empty to non-empty
          > activateNetworkWriter()
        - ObjectStreamer tells the Selector (through NetOutQueue) to
          stop waking-on-writable when it finishes writing the last
          object (there must be only one NetOutQueue in use for a given 
          network connection)
          > stopNetworkWriter()
        + The ObjectStreamer can access and delete the head of the queue
          + Make a StringLineStreamer to illustrate (and to reimplement
            the server)
        - The ObjectStreamer will keep a pointer to the next chunk to
          feed
        - An ObjectStreamer could take file objects and feed bytes; it
          could serialize large objects to disk and feed out of that; it
          could take strings that are always terminated by \r\n
      - NetInQueue
        - Constructed with an ObjectRecognizer object; there is an
          ObjectRecognizer to go with every ObjectStreamer
        - Reads data until the ObjectRecognizer says there is a complete
          object; the Recognizer returns the object
        - NetInQueue can either have a callback to handle the received
          objects synchronously, or it can have BlockingQueue semantics
      - HelloServer responds to the following commands:
        - LOCATION //blah/blah/blah
          > This is for dvtp:// URLs
          - To anyone who connects, send the URL of the proxy to DL
            - Currently sending a random string; test this
        - GET //blah/blah/blah
          > This is for WWW-like resource URLs
        x PROXYOPEN <internal-identifier>
          > The handshake, not used in HelloServer, closes immediately
          > Not a good idea to throw an exception or otherwise bail out
            because of this message; makes the server easy to crash
      - The proxy doesn't bother trying to connect back to the server,
        and just sends the client a shape
        > Normally it would connect to port 808 as well, sending a proxy
          handshake instead of a client handshake; this server ignores
          the handshake altogether
    - Make a client that connects to that simple server and renders
      whatever shapes it gets back
      - Implement setUrl()
        - Connect to server and request proxy URL
        - If it is the same as the currently-running proxy, send the
          proxy a SetUrl object
        - Otherwise, download a new server and start it up with the
          given SetUrl object
        x In either case, get a result back and show the effective URL
          > This will just be a general UrlChange object, async
      - Listen for, and handle, messages from the proxy
    - Add rotation
    - Deform the points according to my trig functions and see whether
      it produces decent-looking planets
  - Write a simple Java3D app
    + Create a cube
    - Create methods to set its position, velocity, & acceleration
    - Create methods to do the same for its orientation
  - core.DataPackage (abstract)
    - Find out whether something like this already exists
      > Presents a simple array of objects
      > Serialization produces different results depending on 
        implementation
    - core.DataPackagePlain
      > No compression
  	- core.DataPackageGzip
  	  > Gzips entire package to serialize
  	- core.DataPackageTgz
  	  > Wraps everything in a gzipped tarball
  + Check everything into SVN
    > Too easy!
  + Set up backups for svn repository
    > In case things get corrupted
    + 2 daily and 5 weekly
  + <T> T foldr( T[], folder )
    + Why can't I have a public abstract static method (in
      FoldingFunction)?
      > Doesn't need to be static, does need to be abstract
    x How does Callable work, and would it be sufficient for this?
  + PointArray class in DVTP
  + Package up a TriangleStripArray into a Shape class
  x Test performance of Java3D and of pushing objects from client to
    server; compare
    > No real doubts about the design at this point, unless it turns out
      to be clearly unusable

- To do for 0.02:
  - Add textures to Shape class
    - Specify color of each triangle
  - Override default serialization in PointArray to guarantee that the
    protocol doesn't change due to changes in Point3d's serialization
  - Reimplement ball factory with a stack of LazyPolygons
    - LazyPolygon( origin, top_vector, side_vector, n_sides )
      - get(n) -> vertex of polygon
        - where n % n_sides == 0 -> origin + top_vector
        - where (n % n_sides) * 4 == n_sides -> origin + side_vector
      - Could make this iterable, no?
    > This should hopefully simplify generation of sections of a ball,
      as well as possibly being useful for other things
  - Add better logging facilities

- Future:
  - Add support for Scheme source code proxy (using SISC)
  - Switch to a better language targeting the JVM, once something mature
    emerges
    > Probably Rhino
    > Also hyped are Scala, and ... okay, nothing is as hyped as Scala,
      but maybe that's just because they all got together and ambushed
      the comments on
      http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html
    > Maybe Jython or JRuby
    > Maybe the architecture is:
      > Java or fully Java-callable libraries
      > Other projects in other languages, at a higher level
  - Client: master volume control and mute keystroke
  x WibbleConfrobulator class
  - Distroplane: object scripting bytecode language
    > Distrocode?
    - Objects have properties, some of which can be attached bytecode
    - Message passing between objects
    - previous_object()->owner() and this_person(), just like LPMUD
    - Public/private/protected methods:
      - If a method is defined as public, it has property 'visibility =
        'public
      - Default message receiver in class Object does this when called
        for a message from another object:
        [method_object getProperty visibility]
        > Shorthand for (send method_object 'getProperty 'visibility)
        - If result is 'public, the method is called
        - If result is 'private, the method is not called
        - If result is 'protected,
          - Message receiver then checks whether the sender of the
            message is owned by the same user as itself; if so, method
            is called, else not
  - Configuration of new server:
    - Menu: World/Create/v1.0
      - Also have menu: World/Create/Email me version news...
        - Pops up window saying, "Would you like to be emailed when new
          versions of Distroplane are available?  Enter the address to
          which mail should be sent:" along with checkboxes:
          - Major stable versions (v1.0, v1.2, v2.0, etc.)
          - Minor stable versions (v1.0.8, v1.0.9, v1.2.0, etc.)
          - All minor versions (v1.0.8, v1.1.32, v1.1.33, v1.0.9, etc.)
    - Ask for name of world (should probably be renamable later)
    - Download Distroplane class, create a directory for it to run in
    - Start Distroplane with current user's public identity info set as
      Creator
    - Initially, only allow the Creator to connect
    - Connect to world; use in-world interface to set it up
      - An avatar with the Creator bit set can access all protected
        methods of every object automatically
      - A Creator connecting to a Distroplane sees the message, "You are
        the Creator of this world" with a "Renounce" button.  (Help
        question mark should explain that "renouncing" is temporary
        only, and that transferring of Creatorhood can be done through
        the World Configurator object, which is the only object floating
        in the void in a newly-created Distroplane, and which can be
        summoned again with World menu >> Summon Configurator)

