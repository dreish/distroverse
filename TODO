                                        -*- Org -*-

- To do for 0.02:
  - As quickly as possible, put together a server that sends an
    extremely simplified universe (with no detail culling and only one
    detail level), an envoy that caches nothing, and get it working
    with the client
    + Replace universe def with something very limited
      + defvar small-universe-spec
    + Instantiate simple universe and convert all nodes to concrete
      + Create node tree dm
        + echildren: optional generator function
          + Takes spec ID (look up in node-tree/vars), parent radius,
            layer, depth, seed; returns ephemeral children of course
            > Any reason not to just take the parent node struct?
        + children: optional list of node ids; has precedence over
          echildren
        > Whenever children and echildren agree, children can be
          deleted
        + Libraries attempting to use the database without calling
          dm/startup! is now an issue
          + Every lib that uses dm at load-time should obviously call
            dm/startup!
          + dm/startup! should throw an error if called with different
            parameters than the last time
          x Mark any use of :reload-all with an XXX; not for use in
            production
            > Only in setup scripts (with dashes)
        x Column name "key" is no good; munge all column names so they
          cannot collide with SQL keywords
          x And then re-init the database
          x And then change :xkey back to :key
        + Change :key to :k, and :val to :v to match
          + Need a way to drop a table
            x Resolve :drop write to data-drop!
            + ds/drop!
              + For :sql, drop a table
              + For :dcookies, no op
            + dm/drop-map!
              + Need to grab the same mutex as create-map!
              + Drop table first
              + Then delete from table map
          + Drop and recreate node-tree/vars
        + From the names of the newly-created tables, it looks like
          I'm not appending a serial number as I think I did
          previously
          + Add a serial number whenever ds/munge must be used (which
            is whenever there is no default spec)
      + Add a root node to it (nodeid 1)
        x seq-check and seq-fix need to handle nil correctly
          > For now, try writing code without using those functions at
            all, and without using the :seq type
        + Dropping a table and then recreating it, get-map still
          returns the table I just dropped
          + *tables* also needs to be modified
            + First, nil-out :read and :write so anyone else
              attempting to use a copy of it will fail
            + Then swap-dissoc it
            + Why do I even have both *tables* and *table-map*?
              > I think I did that to guarantee that there is never
                more than one copy of a table loaded, regardless of
                concurrent transaction activity
                > It might not actually be needed, but it probably
                  doesn't hurt
                > It also makes the :dcookies design a little easier,
                  coincidentally
        + How does the generator function call actually get stored?
          Do I just stuff the entire spec into the node data?
          > This would introduce a huge amount of redundancy; every
            terminal concrete node would have several copies of the
            entire universe spec
          + Refer to a var in node-tree/vars
      + Add small-universe-spec to node-tree/vars
        x use def-universe
          + Need to merge node_tree.clj and server_lib.clj, and
            def-universe
            > Actual universe specs could be in setup-data
        + use server-lib
        + Add any needed forward declarations
        + :generator needs to be unevaluated expr or symbol
        + The :keyword type isn't working on the key column; isn't
          translating it to a string on select (before inserting)
          > This should happen in ds/getrec
        + Attempting to re-add the row right after deleting it leads
          to a bad query ("SELECT * FROM wsanodetreevars WHERE k = ?"
          :: nil); throws an exception in the writer thread
          > Attempting to insert a map with no :k (still had :key)
          + Don't allow bad queries to be added to the queue; die
            earlier
      + Convert immediate children to concrete
        + (concretize-children 1)
          + (children-of (get-node 1))
            x Needs :ephemeral property
            + This shouldn't check the node's :ephemeral property,
              it should look for either :children or :echildren
            + fix (gen-children)
              + fake-parent needs a :seed-mutation-shift
                + Add to gen-echildren call in root node
                + Add to gen-echildren parameters
                + Add to constructed fake-parent
            x :parent is nil; could be given in this case
              > But this does raise questions about whether parent-ref
                makes sense; maybe I should just ditch it until it
                proves necessary
            + Children need their own gen-echildren calls
              in :echildren, unless a terminal node
              > Tested; can make grandchildren of root node now!
            + Obviously DvtpExternalizable objects need a print-dup
              + Maybe the way to do this is in binary
                + dvtp-to-bytearray
                + bytearray-to-dvtp
                + binu64
                + u64bin
              + "#=" prettyPrint -- define this in dvtp-lib
                + I will certainly need to use eval; straight #=()
                  wouldn't call nested constructors
              x Make a test function that iterates through all the
                DvtpExternalizable classes and makes sure an example
                value equals itself after print/read
                > This would duplicate the existing tests for
                  DvtpExternalizable, now that I just have a general
                  layer on top of that
              x ".prettyPrint" should print full class names, with a
                dot
              x Will need constructors that take any iterable
                collection, not just arrays
            + :obj should use print-dup
            + Should probably continue to make the spec just a label;
              in fact, it should only exist as an arg in :echildren
          + Fix arity mismatch calling gen-simple-starsystem
          + If node has :echildren, create each one and add it as a
            new node, and replace the :echildren column with :children
            + Top-level echildren should have parent nodeid
              + gen-echildren takes a nodeid
              + generators use (parent :nodeid)
            + add-node
      + Recursively convert all descendant nodes to concrete
        + Once again, insertion of a row that causes the writer thread
          to throw an exception proves to be a nasty problem; in this
          case, a row had a radius that would not fit because it was a
          float, so its print-dup was long
          + Come up with some way to prevent this from destroying the
            whole system
            + Maybe do this: shut down the server, write out the
              failed write and any subsequent writes to a log
            x Or this: keep the server running, dump writes to a file
              with print-dup, and recover manually
              + Before going too far with this, it might be a good
                time to switch to agents
              x Make a note for later: any rows with failed writes
                will need to be protected from being expunged from the
                write cache (when I finally get around to implementing
                that)
          + Retry the thing that crashed it previously; confirm that
            it writes a log and stops the process
            > Does appear to shut down
            + Does not include write that caused exception
            + Writes out numerous aborted-writes-logs with empty
              queues and appears to keep accepting writes
              + If things worked correctly, there couldn't possibly
                have been more than one log
                > Of course: there were queued agent-write! calls sent
                  to the agent after it failed; the write queue by
                  chance didn't have any other writes queued when the
                  failed one was encountered; the failed write never
                  got cleared from the queue
                + The agent itself should have a significant value
              > Still exhibits the same symptoms
              + Try breaking it in a more controlled fashion
                + Reset node table again
                + Make concretize-children not recursive
                + Call it once for each depth
                  > Failure happens on attempting to add a
                    gen-simple-starsystem node
                + Reload; don't reset
                + Add two star systems in one transaction
                + Add an atomic *aborting* and only write when
                  atomically setting that flag
                + Try the full descent test again
                  > Looks much better this time, and only writes one
                    log
          + Not-really-addressing-the-root-problem solution: make
            all :obj columns at least TEXT or VARCHAR(255)
          + Try again
            > It works, but isn't as fast as I'd hoped (13.508 seconds
              to concretize all 1097 nodes)
          + Find out if shutting off query-printing makes it faster
            > Much better: 2.623 seconds
          + Also tangential: have a :num column that encodes as a
            string, but doesn't use print-dup; use that
            for :nodeid, :parent, :radius, and :depth
          x Try splitting it into eight threads
    + Make a star system just a single polyhedron
    + How do I send a polyhedron?  Or any node for that matter?
      > First pass at an envoy will just respond to DNode (from
        server) by sending client an AddObject
      + Add DNode handling in envoy
    - Get it to show up in the client
      + On connect, call dump-universe
      + Receive "dump-universe" funcall on the server
        + Traverse entire universe (from hardcoded root node #1)
          + (node-tree-seq nodeid)
            x Maybe consider taking a node instead of a nodeid, for a
              cleaner implementation
            + This seems like it won't work; traversing the node tree
              is transactional, and a lazy seq can't be guaranteed to
              exist within one transaction
              + Since this is just a rough first draft anyway, just
                realize all nodes in one transaction and add that
                realized seq to the write queue
        + Convert each node to a DNode and send it to the client
          + Finish node-encode
          + node-to-addobject
          + noderef-encode
          + Converting node 1 results in a DNode object with nil for
            the AddObject, which causes a null pointer exception on
            externalize; it should be allowed
      + Receive DNode on envoy; display nodes in client
      + Get the server running
        + (org.distroverse.distroplane.WorldServer/main nil)
          + Does not compile; create-map! added to wrong namespace?
            + dm and bk now clash; use (ns) thing from setup-data
          + Need to create key-to-id bk map
            + Use ws-ns?
          + Create userdata and avatars (regular maps)
          + new-object: takes a shape, returns a node ID (no parent)
            + Needs Shape.getRadius()
          + Implement reparent
            + Set depth to (inc parent-depth)
            + Concretize parent's children if necessary
            + Add to parent's children
          + ac! doesn't appear to compile even for basic cases
          + fun-call doesn't work
            > Needed into-array
          + get-all-avatars is unimplemented (needed by startup!)
            + Need a keys equivalent for dm: pkeys
              + List of all keys in :writes or :reads that don't map
                to nil
              + datastore/get-pkey-seq
                + Filter these based on not being present in :writes
                  or :reads
                + close-on-error x &code -- a little like with-open,
                  but don't close on a normal return, and don't
                  combine with binding
                + Try it; can I get the seq of all node ids?
                  + Verify count against a SQL query
                  + Needs the values returned to be decoded (and not
                    in sublists)
      + Try connecting to the server by telnet
        + Even after killing the thread that contains the server, it's
          still printing "clearAllQueues() called" every few seconds
          > Server was designed to be started up and left running as a
            standalone process, then killed, not called as a function in
            a Lisp REPL
          + Watcher thread needs to stop
          + Server thread goes into DvtpListener.serve(), ends up in
            a while-true loop in DvtpMultiplexedConnection.run()
            + Add mShuttingDown in DvtpMultiplexedConnection, and public
              shutdown()
              > Also shuts down the watcher
            + Make DvtpServer.createServer() return the server instead
              of running it
            + Add WorldServer/shutdownInstance
        + It connects, and LOCATION works, but ENVOYOPEN kills it
          > Got it sending the ID/id inv request now
        + Even after calling shutdownInstance, something is still
          accepting connections on port 1808
          x Run in the Eclipse debugger and poke around
          + Add something to shut down the listening socket
        + Client dropping connection just after ENVOYOPEN causes an
          ugly-looking exception in the server
          > Canceling an unknown key due to an exception
          > Got a stupid fix for it; oh well
      + Logging stops when it reaches the limit, and there's no way to
        restart
        + (Log/setNumLogMessages 0)
        + (Log/setLogging true)
        + (Log/resetLogging)
      + Get the client running
        + ViewerWindow constructor throws exception calling
          DvWindow.addWidget( null )
          + Is anyone calling DvWindow.initGame()?
            > Only BaseGame.start()
          + Is anyone calling DvWindow.start()?
            + Race condition: I was calling window_copy.start() in a
              thread, and then immediately initializing the GUI, but
              parts of mWindow get set up in start() (why not the
              constructor?)
              > Because jME doesn't work that way
              + Add DvWindow.waitForInit()
      - Try connecting to the server using the client
        + Server did not return a [sic] EnvoySpec in response to a
          LOCATION query
        + Locks up in EnvoyControllerPipeline constructor, trying to do
          a LOCATION query
          + Server has stopped responding to LOCATION; still sends
            greeting
        + ConcurrentModificationException from
          NetInQueueWatcher.clearAllQueues() line 102
        + Server carps about protocol errors: receiving Str while in
          conversation mode
          > Why not just handle these?
        + Got two "Unrecognized message from server" messages
          + One is for the greeting Str
          + Other is for AskInv ID
        + Server occasionally becomes unresponsive, find out why
          + Next time it happens, try to identify a trigger
            + Receiving a non-string in conversation mode; clearly this
              is an idiotic reason to kill the entire watcher thread
              + Don't throw an exception; just close the channel
        + Server carps about receiving a FunCall in conversation mode
          + How is that possible?  I thought only the server sent
            FunCalls
            > PassThroughEnvoy sends ("init"), and WorldEnvoy sends
              ("dump-universe")
          x Did the client fail to send ENVOYOPEN?
            > I see _two_ ENVOYOPEN commands (how could that happen?)
          + Restart server in new Clojure session; find out what the
            exact funcall is
            + Current jME install isn't compatible with Snow Leopard
              + Try 32-bit Java 1.5 workaround from OneSwarm wiki
                > Back to normal
              x If that doesn't work, upgrade to jME 2.0.1
            + Getting dump-universe in conversation mode
              + Called from WorldEnvoy.initWorld only
                + Called only from SingleServerEnvoyBase.setUrl
                  + Called only from SingleServerEnvoyBase.offer, in
                    response to getting a SetUrl message from the client
                    > This should only happen strictly after ENVOYOPEN
                      is sent
                    + Add a breakpoint at NetOutQueue.add
                    + Watch a run to make sure it sends ENVOYOPEN along
                      the _same_ channel that ends up getting the setUrl
                      + Given that the behavior doesn't appear with the
                        breakpoint set, this is most likely a race
                        condition
                        + Nothing ever sets mCurrentHost or
                          mCurrentPort, so the connection just keeps
                          getting reopened over and over
                        + It's still happening
                          + Make a test client in clojure
                            + Event-queue interface to Net*Queue
                              + class InvertingInQueueObjectWatcher,
                                constructed with a java.util.Queue
                          + Run it in another session (not from Emacs)
                            + Mysteriously sometimes takes minutes to
                              send a message
                              + Impossible-looking race condition;
                                somehow the selecting thread gets
                                through the synchronized ( mSelecting
                                ) block while another thread is also
                                synchronized on mSelecting
                                > Theory: any code executing inside an
                                  object that is a subclass of Thread
                                  looks like it is a part of that
                                  Thread, even if it was called from
                                  within another thread, so the
                                  synchronized keywords, they do
                                  nothing
                                + Fix by setting a flag before waking
                                  up the selector; busy-wait for the
                                  flag to clear instead of
                                  synchronized blocking, sad though it
                                  may be
                            + WorldServer _does_ think it is in
                              conversation mode even after an
                              ENVOYOPEN
                              + Handle setting conversation mode
                                automatically when the ENVOYOPEN
                                message is received
        + trim-to-matcher is unimplemented
        + Session is not the same as its attachment
          + satget
        + FunCall->FunRet response maker doesn't work
        + Looks like the server gets more than one copy of the
          ReplyInv, the first of which is handled correctly;
          subsequent one(s) die because there's no longer a callback
          + Apparently because the callback returns nil and I'm
            foolishly using that to indicate "no, it wasn't for me
            after all", which probably isn't a useful capability
        + Add FunRet to test script
        - Find out why FunRet 1 doesn't hit the callback for FunCall 1
        - NPE in EnvoyControllerPipeline.dispatchObject()?  How is that
          possible?
        - Make sure the ID response maps to something that is actually
          in the id table
  - Add a trivial avatar to the world
  - Add avatar movement
  - dm/ds: die on attempting to encode an unreadable object as a str
    (instead of inserting it into the database and dying on attempting
    to read it back out)
  - Hopefully-emerging node design:
    - Need a depth attribute
      - Property stored in concrete nodes
      + gen-children should add it
    - server-lib/node-encode {} => DNode
    - children: apply-lambda, not (lazy-seq (apply (resolve)))
      > Important point: don't want this to persist after being
        finished with it
  - Refactor durable-maps so it can sit on top of any data store that
    can provide atomic multi-record writes (such as the cookie store)
    - datastore.clj
      - sync-call using async-call!?  How would that work inside a
        transaction?
        - dvtp-lib/functional-sync-call
          - Takes a DvtpChannel -- anything with void .send
            DvtpExternalizable
          - Add .send method to NetSession
          - Need some kind of .send interface in WorldEnvoy
      > Okay if schemas look different depending on datastore backend
      - Need some place to store the meta tables?  Would there even be
        meta tables for the :dcookies store?
        > No, every table has the same schema
        + Create table is a no-op for :dcookies
        - Move all SQL out of durable-maps and into datastore
          + dm-startup! should take a connection type, and varargs
          + create-table! -- run-stmt!
            + Will just take exactly the same tablespec format I was
              using with durable-maps
            > I'm really just moving code and adding some
              polymorphism; not much changes
            + But who mutates the tablename?  And who keeps track of
              the correspondence?
              > Since the dcookie datastore can't handle the mtables
                schema, datastore can't be completely unaware of table
                name mutation
              + datastore/ds-munge
              + datastore/default-spec
              + When adding a table, check for a default schema; if
                the ds has one, given spec must match it and nothing
                else need be done; if it doesn't have one, then add it
                to *table-map*
              + dm-load-table also needs to check for a default schema
          + Writes just contain the abstract information (a simple
            copy); the query is constructed in datastore.clj by
            functions called from the writer thread (or agent)
            + Bring valify-row down to datastore as well
              > Looks like all the associated functions can come too
            + Bring down mapify-row -- this is SQL specific as well
          + flush-writes-before! -- run-stmt!
          + insert-query
            + Call ds-add! in queue clearer
            + Implement ds-add! -- take insert-query
          + update-query
          + delete-query
            + Add a {:type :delete ...} hash to the write queue
              instead of forming an SQL query and adding that
            + Handle this in data-write!
              + Call ds-delete!, don't form a DELETE FROM query
          + get-query
            + get-row
              + ds-get equivalent to get-row
          + ds-get calls mapify-row, not database-select?
            x database-select needs to pass a hash with :dmap equal to
              dmap
            + Change all the SQL functions to take whole dmaps
              + Or more precisely, any hash with :table for table
                name, :key for primary key column name, and a :spec
                like what I've been using
                + ds-get definition
                + ds-get calls
                + ds-change! defn
                + ds-change! call
                + ds-add! defn
                + ds-add! call
                + ds-delete! was already set
            + Make sure that's what they're all being given
          + Can't create-table! in dm-init!
        + Test :sql using test-scratch.clj; both dm & bk
          > dm appears to work
          + bk fails to load on dm-get-map "bigkey-dm/mbk-maps"
            > Can't load bk until after loading dm and calling
              dm-startup!
              > This seems unfortunate; is there a way to pass these
                parameters while use-ing?
              > Or (def *db* ...) before loading?
            + Create bk-startup!
        + Try out the stress tests; probably somewhat faster now
          > No big difference
        + Make sure mtables and mvar either won't be hit for dcookies,
          or can be translated somehow
          + It appears dm-create-map! does not handle this correctly
          + next-inname-num, using *var-map*, looks problematic
            > Add comment and punt for now
            > Solution might be to change to :k :v, but what about
              type conversion?
        - Make dm-init! work for dcookies; currently would die because
          the specs are not compatible
        - Table name mutation should be done within datastore
    - For testing, target a brain-dead simple filesystem tree,
      ignoring the transactional write issue (as I currently do for
      SQL, anyway)
  - Send surroundings from server to envoy
    + Set initial detail level -- -10.0
      > This is in the session attachment
    + Set envoy's loading property
    x Starting from avatar's parent node, find and send all visible
      nodes
    x Starting from avatar's parent node, find and send all top-level
      visible nodes (all nodes such that some children might be
      visible)
      x Want to be able to send a seq of DvtpExternalizable objects
        (maybe just use a classic Java iterator)
    + Send ancestor nodes; client will query downward from there
      + node-tree/rel-vector a b [offset]
        + MoveSeq.transformAt
          + Looks like all times need to be Real
        + Change search-nodes to do matrix mult
        + Change is-within, is-intersecting, is-containing to use
          matrices
          > Interfaces shouldn't need to change
        x nodes-within et al should need at most minimal changes,
          right?
          > No, nothing
        > Return vector from a to b, plus offset
        + matrix.clj
          + Minvert mat
          + M* mat1 mat2
    - Envoy will pull children that both envoy and server agree are
      visible to the client at the current detail level
      > Envoy will stop descending when a node has the same timestamp
        as the copy in its cache; will not stop ascending
      + One concession to efficiency: the server will send the chain
        going up, and the client will only ever pull children
        > Otherwise, the server will need to recheck visibility on
          each node, which will be O(N^2) of the tree depth of the
          avatar
        + node-tree/parent-chain nodeid
        + Make dvtp-send! handle a seq
          + It should get added to the netOutQueue as normal; the
            queue reader needs to know how to handle a seq (or an
            iterator)
            > The queue reader is called DvtpFlexiStreamer
            + Take an object from the seq and stream it
            + Add the rest back to the end of the queue
            > This is pretty awesome
            > I'm pretty sure it will break when I switch to lazier
              seqs tomorrow
              > Was easy to fix
      - Pull from client
        + Client needs to know where avatar is, not just camera
          > Actually, just the envoy
          + Server: send ("set-avatar" object-id)
            + I want the avatar object to be permanent
              + Change add-self-to-world:
                + Don't add-object there
                + Get avatar object, which should have no parent
                + Reparent it to :lastpos
          + Envoy: recognize this message
            + Create WorldEnvoy (extends SingleServerEnvoyBase)
            + Create message recognizer (FunCall objects)
            > FunCall ID 0 does not need response
            + Die on unrecognized messages from the server
              > Better just to log them for now
            + For set-avatar, set long mAvatar
        - Each time a node is received, along with its children and
          their last-update times, check all children against what is
          in the cache, and request any that are newer
          - Trimming:
            - The server will send any direct child of a node that is
              within the client's visibility range
            - The client will do trimming, and the server will only
              double-check
              + Algorithm will err on the side of permissiveness
                (displaying) for moving objects
                > Probably the same algorithm will determine when a node
                  must be reparented up to accommodate a large movement
              - NodeTreeUtils.vectorTo()
                - This is actually impossible to do correctly without
                  either using STM or locking the entire cookie store,
                  isn't it?  So how do I do transactions from the envoy
                  on a database stored by the client?
                  > durable-maps, of course
                  - From the envoy, load durable-maps
    x Server will automatically subscribe the client to changes in all
      nodes within range
      > Given that an avatar will move around more than nodes will, in
        general, change, I think the subscriber list idea was not a
        good one.  Instead, whenever a node is changed, the interested
        clients should be determined dynamically, perhaps by using a
        separate tree structure containing the locations of all
        avatars (which would almost surely be useful in other cases)
        > The separate tree is problematic, but additional information
          in the main node structure would make it relatively easy to
          search
    x Client needs to subscribe to all these nodes, too
    - Clear envoy's loading property
      - It seems that with the current approach to loading, it will not
        be clear when loading is finished
        - Maintain a count of requested nodes?
          > Would only be accurate if the server reported requested but
            refused nodes, which might be a good idea anyway
          - What about unrequested nodes?
            - Separate message for requested nodes
              - DList: (Str "rn", DNode)
    - New approach to handling ephemeral nodes
      + A concrete node can either have all concrete children, or it
        can have a generator function to generate its child nodes
        + DNode should have a switch: mGeneratedChildren
          + Debug failed externalization test
      + Instead of a gen-children function, every node will have a
        lazy seq of children
        + Column type :seq
          + Store as :obj
          x On update or load, apply given seq and store result as
            :<colname>-seq
          + val is a hash: {:func x, :seq y}
          + Problem: dm-update will have to do an expensive check to
            find out if the column has changed
            + Not too bad: part of a table spec is a seq of columns
              that need these checks
              + (fixrow row prev-row dmap)
              x On loading a dmap, scan the spec for columns that need
                checks and build :checked-cols
            + The caller of dm-update should just set func, not seq,
              which will be overwritten
          + dm-insert must also fix a row
      - Converting a node to concrete means converting its parent to
        have all concrete children, all of which will have generator
        functions for their children
        - That means each generator will need to be mappable to a
          function that will return the function call to generate each
          of the children
          > That, or an ephemeral node has the same apply/seq pair it
            would have as a concrete node
        - If nodes have their parent node as a member, they obviously
          could not contain a seq of their children as well
          - Would making :parent-ref an actual ref help?
      - Make them concrete (temporarily) any time they have children
        added
        > Could have a concise message format for this
        - In add-subnode (which should be in node-tree), if the parent
          is ephemeral, call make-concrete on it
          - Ephemeral nodes need to have an :index-in-parents-children
            > Not concrete nodes, though, since they are subject to
              deletion
      - When a child is removed, if the node itself hasn't been
        modified, and all its children are again ephemeral (and none
        of them have been deleted), it reverts back to ephemeral with
        a delete/add transaction on the parent
      x Avatars should probably have their quitting position stored as
        a vector of MoveSeqs, since really any node might disappear
      - Or as a series of node/vector combinations starting from the
        last parent node and going up to the root; they would be tried
        in order until one still existing was found
        > This would have the advantage (?) that if the user were to
          quit in a room that then got moved, the user would start in
          the same place.  This might be very desireable in a case
          like quitting as a passenger in a vehicle
        > The minor disadvantage is that quitting far from an
          artificial structure would cause a proportional but small
          inaccuracy in the restart position
          > For example, on an uninhabited continent 5000 km from any
            civilization, the savepos error would be on the order of
            0.6 meters
      - What does the boundary between a concrete parent node and
        ephemeral children look like?
  - Add a FengGUI location bar
    - Would be nice to know why TextArea causes OpenGL exceptions
  - Implement actual movement
  - Use trusted path for dialog boxes that shouldn't be spoofed (f10?)
    > Also nice because it avoids having system dialogs swallow a
      stray enter key or spacebar
  - Add textures to Shape class
    - Specify color of each triangle
    - Include image
    - Each triangle includes an image transform
  - Add WarpShape message
    - Polynomial/sin change over time, but each coefficient is a Shape
      instead of a vector or quaternion
      > Shape must be topologically identical to the one it applies to
  - Add AddRef message
    > Object id and MoveSeq
    > Creates a new object with the same shape as another object and
      its children
    > Changes to the other object's shape affect referring objects
      > This includes texture
    > Changes to child shapes and their relative positions also affect
      child shapes and positions of referring objects
  - Client input
  - Cookies
  x Override default serialization in PointArray to guarantee that the
    protocol doesn't change due to changes in Point3d's serialization
  - Reimplement ball factory with a stack of DynPolygons
    - DynPolygon( origin, top_vector, side_vector, n_sides )
      - get(n) -> vertex of polygon
        - where n % n_sides == 0 -> origin + top_vector
        - where (n % n_sides) * 4 == n_sides -> origin + side_vector
      - Could make this iterable, no?
    > This should hopefully simplify generation of sections of a ball,
      as well as possibly being useful for other things
  - Add better logging facilities
  - Time out synchronous queries
  - Show some sort of "loading in progress" status indicator when
    going to a new URL, before the connection is fully established
  x Switch to latest jME
    + svn checkout http://jmonkeyengine.googlecode.com/svn/trunk/   \
      jmonkeyengine-read-only
    + git commit old version
    + Remove * .cvsignore
    + Copy in new jME 2
    + git commit new version
    x Try loading some tests from within Eclipse
      > Great, it crashes
    x Find some instructions and follow them
    > SVN version is not ready
    + Go back to 1.0
    + CVS update to get jME 1.0.1
  + Now getting errors loading about:hello
    + ControllerPipeline should have the EnvoyClientConnection, not
      ViewerWindow; otherwise there's no point to it
      + The EnvoyClientConnection currently has a way back to the
        ViewerWindow, and gives that to the ViewerDispatcher; this
        must instead go through the pipeline (which should have the
        dispatcher)
  + Would be nice to know why everything renders with the wrong Z-order
    + Trace through rendering
      x Trace deeper into GL11.glDrawElements(), called from
        LWJGLRenderer.draw( TriangleBatch )
        x Need to attach source to LWJGL
    + Look at the code in a demo clearly lacking this problem
      + jmetest.shape.TestTube renders a single complex shape with
        correct hidden-face removal; I should be able to at least do a
        single sphere correctly
        + Only thing I see that is different is the shape; Tube vs. my
          hand-rolled TriMesh
          > jmetest.input.action.TestFirstPersonController also uses
            multiple hand-rolled TriMeshes, and also has the same
            problem
          + Look at how Tube is constructed
            > With TrangleBatch, extending TriMesh
            > With all values set in the NormalBuffer
          + Add a Tube and randomize its vertices' colors
            > Amazingly, it has the same problem, so it can't be the
              lack of normals (the Tube has normals)
          + Try changing TestTube so its Tube doesn't have a texture,
            but just random colors
            > This requires turning off the light; otherwise the Tube is
              just grey
          + Found it
            + Must call mRootNode.updateRenderState() after adding a Z=
              buffer to it, as is done in BaseSimpleGame.initGame()
          x Try copying the Tube class and warping the vertices
          x Try converting Shapes to something subclassing TriMesh,
            patterned after Tube
            x DvTriMesh Shape.asDvTriMesh()
          x Does this not get back to the problem I brushed past a while
            ago: my generalization of shapes breaks down because I don't
            know which side is in and which side is out?
            > Might have to just pick an arbitrary handedness for shapes
            > The other possible problem is that I regard shapes as a
              stack of independent strips; there might b no easy
              correlation between them
      x jmetest.scene.TestPassNode
  + Disallow empty MoveSeq in MoveSeq constructor & reader
  + Add flag for invisible shape in AddObject
  + ReparentObject (138)
  + SetShape (136)
    + id
    + Shape
    + WarpSeq
  + SetVisible (140)
    + id
    + bool visible
  + ClearShape (139)
    + id
  + Warp (34)
  + WarpObject (137)
    + id
    + WarpSeq
  + WarpSeq (35)
  + Get a real GUI - FengGUI most likely
    + Relocate from ~/Downloads/src/org
    + Add jar
    + Attach source
    + Try a trivial test -- a dialog box with a message
      + Make this a standalone app, and then migrate the code back into
        Viewer
        > Just using the example for this
    + Wrap the whole ViewerWindow in a FengJME GUI and add root node to
      it
      + Subclass a BaseGame like FengJME
        + DvWindow; provides some useful general methods for adding
          nodes, getting protected access to the FengGUI display,
          update()ing
        x ViewerWindow extends DvWindow; is specific to the Viewer app
          > Because I dislike the BaseGame namespace, I'll make
            ViewerWindow contain a DvWindow, not extend it
      x ViewerGui.setViewRoot( Node )
    + Add shapes
      + about:hello test only reaches addShape() after the window is
        closed; trace execution and find out where it gets stuck, how I
        can make it flow through as before
      + There's a race condition in creating a window and immediately
        attaching the ViewerGui node to it, in ViewerWindow();
        initialize mRootNode in DvWindow()
      + WorldGraph.addShape() is still being called, but the shape does
        not display; find out whether the wg is a child of the node
        actually being rendered
        + Breakpoint in wg.addShape() and in DvWindow.render()
          x Does something need to be happening in update()?
            > From reading AbstractGame, probably not
      x Are there any seemingly superfluous calls that need to be made
        on one or more of the nodes for them to be displayed?
        > Apparently not
      + Try adding mBox to "mRootNode" again
      + Then move the add to AboutControllerPipeline
        + Make static DvWindow.mRootNode public
        > This succeeds
      + Then add it to a child node ("GUI-root")
        > This fails
      + What is different between "mRootNode" and "GUI-root"?
        > Orthographic?
        + Yes, make a window root and attach both world root and GUI
          root under that
      x Then try adding one of my shapes asTriMesh()
      x Are the objects' positions or sizes preventing them from being
        displayed?
    + Shapes are not bobbing; why?
      + Probably need to fill in the update() method
        > Controller is still being added to nodes as before
        + Find out how SimpleGame does it
          > Just: mRootNode.updateGeometricState( tpf, true );
    + Find out from Joshua Keplinger what license FengJMEInputHandler
      is offered under; also whether he wrote FengJME, and what
      license for that as well
      > Was released under a compatible BSD license
  + Replace all GPL copyright banners with the one currently in
    WorldSession.java; LGPL files do not need to change
    > (To allow gradual conversion to Clojure, including the contrib
      library)
  + CTrans class - Client Transaction; list of EnvoySendables
  + Fix mutability problems in DVTP classes
    + Make Dict copy a map rather than adopting one
    + Make all readExternal() methods private
    + Add constructors with InputStream to all classes
    + Rewrite DvtpObject reading code
      + Using reflection to look up the constructors each time would be
        slow, but storing them and calling them should not be
    + Rewrite all DVTP classes built out of other DVTP classes that use
      readExternal()
    + Remove all set methods
      > Except in DNodeRef, but much of that design might go away
    + DNode can't use part of AddObject, since there's no way to set the
      ID after reading; it needs to be a separate class (DObject)
      factored out of AddObject
      + Unless I made a withId() method returning a new object ...
  + Dict is not immutable; it should be
    + Also, change implementation to use any Map; change hashCode to
      the sum of the hashes of keys * 852403729 ^ hashes of values
  + Get rid of KNOCK command
    > A DVTP envoy will be allowed to connect to any server, at any
      time, on any port except SMTP, which is always forbidden
    + Remove handleKnock()
  + Remove WorldSession class
    + Put getPeerAddress() in NetSession class
    + Rewrite server code to take a session and an attachment
    + Look up attachment in handler methods in WorldServer; pass them
  + Make all private DVTP-message fields final and debug
  + Begin implementing WorldServer (extends DvtpServer)
    + Add DVTP messages:
      + GetCookie (DvtpExt) (26)
      + Cookie (DvtpExt Bool DvtpExt) (27)
      + AskInv (Str DvtpExt) (134)
      + ReplyInv (DvtpExt Bool DvtpExt) extends Cookie (135)
    + Add DVTP Dict class (28)
    + DLong (31)
    + Frac (32)
      + toFloat()
      + toDouble()
    + Real (33)
      + toFloat()
      + toDouble()
    + DNodeRef class (29)
      + Str RemoteHost
        > 0 means sending host
      + ULong id
      + Real lastChangeTime
        > Not compared
      + DNode
        > For convenience; not externalized or compared
    + DNode class (not client<->envoy, as AddObject is) (30)
      + AddObject being
        + AddObject.readWithoutId( InputStream in )
          > Sets Id and ParentId to 0
          > Envoy will pick a locally unique ID and set it as it
            receives the DNode
        + AddObject.writeWithoutId( OutputStream out )
        + Compare with AddObject.equalsWithoutId()
        + Hash with AddObject.hashCodeWithoutId()
      + Float radius
      + DNodeRef this
      x Boolean hasParent (parent != null)
      + DNodeRef parent
      + array of DNodeRefs, children
    + Add all new classes to TestExternalization
      + And implement equals()/hashCode() as required
    > Envoy will need to maintain maps, both of RemoteHost/id and of
      local id, to either DNodeRefs or DNodes
      > Which one will depend on how the map will be used most often
      > Break out RemoteHost/id as its own type?
        > Not necessary; just make those identity fields define equality
    + Create WorldServer in Lisp; otherwise this is going to be a major
      bummer
      x All the node management will be in Java, but the response/
        callback structure will be a major pain in Java.  Java no likey
        callbacks
        > Actually node management, as state shared by multiple
          threads, is the strongest argument for using Clojure
      + Get and install Clojure
      + Enjoy the consing for a few minutes
      > http://en.wikibooks.org/wiki/Clojure_Programming demonstrates
        how to call a Clojure function from Java
        > (The docs give the reverse case, which is trivial)
      + Install Emacs for OS X
      + Install Clojure support for Emacs
    + Request identity
      + Clojure macro (async) for weaving a do-like construct into a
        series of messages and callbacks
        x Gotcha: all callbacks will need to be removed at the end of
          the pseudo-function
        > (async) always returns nil
        > Actually, just a simple let-like macro
        + Figure out how the end-result code should actually look
        + Write it as an async macro call
        + Then write a macro that goes from B to A
    + Create new user if needed (from skeleton user)
      > Has default starting location
    + Ephemeral universe generation
      + universe-spec
      + gen-fractalplace
        + new-topnode
          + Problem: This generates nodes with a radius larger than
            those made with new-subnode; they will exceed the bounds
            of their parent nodes
        + new-subnode
      + Node seed to child node seed
        + Node has a seed-mutation-shift
        + Child node's seed-mutation-shift is parent's (+ 1) (rem 60)
        + Node's seed is:
          x First long generated from rand sequence using parent's seed
          x bit-xor (node-index << seed-mutation-shift)
          > xoring the parent's seed instead
  + Plug server into database
    x Need FIFO map (for db-query caching so they're
      transaction-safe):
      x Created with a length limit, L
      x Adding something new to it, if the (L+1)th thing, causes the
        oldest one to disappear
      x Would be handy to make a version where reading also updates
        the place in the queue
    + Set up Java MySQL driver
    + Pull out db stuff into its own package, wrapping the SQL
      ugliness
      + dm-create-map!
      + Outstanding issues with:
        + Whether select returns a ref or a hash
          > Almost surely a hash
          + local-select and database-select return refs
          + dm-select derefs it
        + Implementation of dm-update based on the above
          + Internal functions return the refs
          + assoc-new-or-retry if the key wasn't already in writes
          + Otherwise alter it in writes
      + dm-init!
        + Create (if not exists) mtables and mvar
        + Getting a null pointer exception from run-stmt
          > SQL commands look perfect
      + Rename translate-val -- there are two directions of
        translation
      + Test
        + Compile everything except the writer thread
          > Will run writes manually
        + Create a dmap
          + (dm-create-map! "test1" {:cols {:mykey ["VARCHAR(32)"
            :str] :myval ["BLOB" :obj]} :key :mykey})
            + get-row must handle the empty set result case
            + next-inname-num doesn't work at all
              + Add an assoc in there
            + On inserting a row, whether to :read (by
              database-select), or to :write (by insert/update), the
              val should be a ref to a hash
            + Row should probably contain the key as well
              x insert-query needs to get the key, obviously
                > That's up to whomever calls dm-insert
                > But I see dm-init! does need to create that var
              + The update probably shouldn't try to set the key
              + WHERE clause in update query has ":varname"
              + Why is it an update?  Why no insert?
                > Because I didn't insert it, dummy
              x Don't add things to the write queue if they have nils
            + Still not creating table
              + inname-num gets added to (*var-map* :write) with key
                equal to clojure.core/key
        + Insert query for new table did not encode spec
          > Also, insert query for new mvar did not encode val
          + Remake tables using text instead of blob
        + Add some stuff to it
        + Flush writes
        + Examine the database from a mysql prompt
        + inname-num got written twice; the first shouldn't have
          happened
        + Update doesn't encode columns -- set or where clause
        + Reload library and attempt to read previously-written data
          + Table gets loaded with :table nil, :spec nil
      + get-row needs to return a column-name -> value hash
        + And the in-memory table needs to wrap that hash in a Ref
      + Need a global write queue, not per-table queues
        + A write is an SQL stmt, the hash equivalent of the values
          being set in the stmt, and a Ref to the in-memory version of
          the row
        + If the hash no longer equals what the Ref points to, cancel
          the write
      x (table-map tablename key "*") => mapx
        x (mapx "foo") does a select * from tablename where key =
          "foo"
      + init
        + Create mtables and mvar
        + Populate mvar with
          + inname-num
      + Writer thread
        + If :required, don't bother to check for a ref
        + Else, if ref doesn't match row being inserted, cancel
      > I think this encapsulates the node caching stuff I was going
        to do separately.  Why carry around two different objects in
        my server code?
        > Somewhat complicated, but worthwhile
          > For example, the object can't be immutable because a
            database table isn't, so it can't support conj or assoc
          > Instead, there will be real mutation functions specific
            to database tables, but they will only happen to the real
            SQL table when an STM transaction succeeds
            > But these will be visible within the transaction, which
              means there will need to be key-value mappings that
              can't time out until they are committed
              > But that means different views of the same table won't
                share the in-transaction changes (within a single
                transaction), which seems awful
              > Worse, they might cache out-of-date values
              > Maybe the answer is to just allow a single view of
                every table and intern table-map per tablename
  x durable-maps writer thread needs to handle being disconnected from
    the server
  + sql needs to handle being disconnected from the server
    + sql/get-db to replace DriverManager/getConnection
      + Returns a ref to a db handle for now
    + In sql, catch any exception by trying once to reopen the
      connection; if that fails, then die
      > com.mysql.jdbc.CommunicationsException isa
        java.sql.SQLException
      + get-sql-conn => *db*
      + Store number of failures in connection object
        + inc-in
      + Change run-stmt!
        + Retry until number of failures > 10
      + Change get-query
  + Test bkm further
    + Test bk-update
      + dm-update seems to make a complete mess of @:write
    + Create a map with a contrived munger that guarantees everything
      goes in the same row
      > Or 1/16 times
    + Verify that the above map still behaves correctly
  + Make the bad ideas go away in world-server.clj
    + Get rid of load-node
    + Pretty much any commute/alter is to be replaced
      > Keeping *avatars* as it is, since it refers to a session
        object
    + And almost any dosync (except with *avatars*)
    + What will *key-to-id* look like?  If the public key goes into a
      text field, it can't be a primary key*
      > *not without significant and annoying limitations, at least
      + Primary key is md5/sha1 of public key, val is hash of public
        key to ID
        + bigkey_dm.clj
          + *bk-maps* is bigkey-dm/mbk-maps
          + md5-munger
  + Try queries in setup-data again tomorrow; see whether connection
    has been dropped
  + Change custom -> to +>
  + Get def-universe working
    + Universe spec is a list; use rest, not :subspec
      + Which means universe-spec, aside from not being true to its
        docstring, is now just a check-structure and an identity
        + Actually, I do need to fill in :subscale
      x Replace all references to subspec to rest
        > Was not using it anywhere
      + Actually, I am using it as a vector; return a vector
      x Replace all references to spec to use first
    + new-universe
      + pick-radius is blowing up
      + Spec needs a :layer
  + node_tree.clj (ns node-tree)
    x durable-maps/dm-annotate
      x Add impermanent things to a map val (without generating a
        write)
        x Verify that db-stored fields are unchanged?  Or not?
        > Problem: this would cause other writes to fail to happen
          > Which happens to be the same reason this isn't necessary
            for scalability
    x Child/parent nodes exist as ints, and refs get looked up and
      stored in a non-saved map
      > Problem with this is that if I want to be able to clean out
        the table, these refs might become invalid
    > The answer for now is almost certainly to just not try to cache
      any links
    + (search-nodes start-node include? descend? ascend?)
      + Conditional needs to transform as the tree is traversed
        + Or, conditionals get called with an accumulated
          transformation to convert a vector relative to the
          start-node to one relative to the current node
      + Return child nodes first
    + (nodes-within relative-node-id pos radius)
    + (nodes-touching relative-node-id pos radius)
  + Change references to CPL to cover any OSDL-approved license
    > OSDL is no more, which suggests a problem with this approach
    + **/*.java; files containing string "Common Public License"
    + **/*.java; files containing "Common\n * Public License"
    + **/*.clj; files containing "Common\n;; Public License"
  + *avatars* should be permanent after all
    > Don't want a server reboot to leave a bunch of statues all over
      the place
    + Single-column table: object ID
    + Will need a way to delete from a dm (and bk)
      + dm-delete
        + How do I prevent the row from being reloaded from the
          database after being deleted from the read and/or write
          caches but before executing the DELETE statement?
          + Must be some special signifier in the write cache to
            indicate a deleted row
            > (ref nil), obviously
          + Create this signifier even if the row doesn't already
            exist, to prevent a concurrent transaction from creating
            the row
          + Other parts of the library must be updated to handle
            this possibility
        + Test this
          + Delete an existing row
          + Get it; confirm it comes back as nil
          + Re-insert the same key
            + Transaction failed after reaching retry limit
              > Was looking up key using the external abstract
                hash-like interface rather than the internal :writes
                hash
      + bk-delete
        + Delete from val hash
          + dissoc-in
        + Or dm-ensure if not in the val hash
        + If that leaves the row with an empty hash, delete the row
        + If there was no such dm row, dm-delete it to ensure it stays
          nonexistent
        + Return bkc
        + Test this
    x Will need a way to iterate through these to be fully useful,
      preferably without loading the entire map into memory all at
      once
      x Problem: This must iterate through the keys on disk and the
        keys in the write cache simultaneously, skipping deleted rows
        > Does this mean :writes should be a sorted map?
          > That still wouldn't necessarily guarantee the same sort
            order
          > No, return non-nil :writes first, then iterate through
            database skipping rows that are in :writes
          > Note: no way to iterate through keys of bk map without
            loading values
          > For that matter, probably nothing useful that can be done
            by iterating through keys alone
          > Iterate through key/value pairs without storing anything?
        x dm-seq => seq of row hashes
          + Will need to be closed when finished; how can a seq know
            when that is?
            + Invert control?
              > Yes; and only write these functions once I can
                actually see how I'll be using them
      > Behavior would be undefined outside a transaction
  + dm-ensure and bk-ensure
    > Same as select, but ensuring
    > Can't use this on deleted rows; use dm-delete instead
    + dm-ensure
    + bk-ensure
  + Stress-test insertion, updating and deletion on both dm and bk
    + sum-counter-stress-test
      + Initialize data: delete counter and target rows if present,
        then insert zeros for both
      + Counter row: threads will get-and-increment from that row
        until the value they get is over N, at which point they quit
      + Target row: threads will add their counter to this target
        value
      + Try with N=10 and 1 thread
        + Mostly worked, but the delete/insert pair bombed; DELETE
          query never ran, but INSERT did
          + Is DELETE added with :required?
      + Try with N=100 and 1 thread
      + Try with N=10 and 2 threads
        + Only one thread actually does anything
          + Try .start, not .run, dumbass
      + Try with N=100 and 2 threads
        > No apparent retries
      + Try with N=100 and 10 threads
        > Still no retries; nice and quick, though
      + Try with N=1000 and 50 threads
        > Got a few clusters of retries; worked beautifully though
      + Shut off printing; time how long these things take
        > N=10000 T=50: 3.64 secs
        > N=10000 T=10: 1.17 secs
        > N=10000 T=2:  0.95 secs
      + Remove outer transaction; repeat above time trials
        > Slight improvement in T=2 and T=10, bigger improvement in
          T=50, not surprisingly
    + scattershot-stress-test
      + Initialize data: delete rows from 1 to N
        > Try without this the first time; it does affect the dm data
          structure
      + Create added: (ref 0)
      + Create T threads
      + In each thread, while @added < N, pick a random number: if it
        doesn't exist, add a row with that key, and increment added
      + Once finished, linearly confirm all N rows exist
      + Then do the same thing in reverse: delete and decrement if
        row exists
      + Confirm all N rows do not exist
      + Try with N=10 T=1
        > 0.003 secs
      + Try with N=100 T=100
        > 0.285 secs
      + N=10 T=100: 0.039 secs
      + N=10 T=200: 0.077 secs
    > Will assume, for now, that bk works correctly, since it is a
      simple layer on top of dm
  + Switch to lazier seqs
    + Follow upgrade instructions from rhickey
      + Rename all calls to 'rest' to 'next'
        x rests ??
          + Can map take a rest?  Do I need to change rests to nexts?
        + server-lib/const-message?
        + util/queue
        + util/+>
          + Look at how -> is defined in the new core
      + Port any use of lazy-cons to a different form using lazy-seq
        + util/hex-encode-bytes
          + Rewrite using mapcat
        + node-tree/parent-chain
        + prng-feedback/prng-*-seq
        + sql/rs-seq
          > Looks like this had a dumb bug in it, too
        + util/crange
    + Update and rebuild Clojure
      + Use nil-punning debug mode:
        + ant -Dclojure.assert-if-lazy-seq=true
    + Restart repl
    + Try tests:
      + dm
        + Interesting problem I never encountered before: a dm-insert
          on an existing row created previously does not throw an
          exception; result is that the writer thread errors out
          + I check whether it's in writes, but not whether it's in
            the table generally
      + bk
      + dm stress tests
        > Runs at around the same speed
  + Redo Real as BigDecimal
    + High bit: this is the last byte before/after the decimal
    + Low 7 bits: two digits at a time, 00-99
    + If first byte is 100, number is negative
  + Break out dm database initialization and leave to the library's
    caller to start it up
    + Make *dm-db* an atom
    + dm-startup!
  + Once things are working again (testable), get rid of the ds- dm-
    bk- anti-pattern (import into ds/ dm/ bk/ if needed)
    + durable-maps
    + bigkey-dm
    + datastore
      + Remove ds- from names
      + Change get to getrec
      + Fix usage in durable-maps
  + Change "proxy" to "envoy"
    + proxies -> envoys
    + Proxies -> Envoys
    + proxy -> envoy
    + Proxy -> Envoy
    + PROXY -> ENVOY
    + Rename any file with Proxy to Envoy
    + Rename src/org/distroverse/proxy to envoy
    +^+ perl -pi -e 's/proxies/envoys/g; s/Proxies/Envoys/g;
        s/proxy/envoy/g; s/Proxy/Envoy/g; s/PROXY/ENVOY/g;' **/*(^/)
        ../TODO
    + "a envoy" is not so cool

* ----------------------------------------------------------------------
- To do for 0.03:
  - Text

* ----------------------------------------------------------------------
- To do for 0.99:
  - Client
    - Text -- can't escape the morass
    - kp-enter to switch between mouselook/pointer mode
    - Sound
    - Shape smoothing
      - Should this all be done at the envoy level, with additional
        polygons?
      > Goal: a future client with tactile output should be able to
        distinguish between sharp and rounded edges
      > Render versus feel detail levels?
      > Render large area at visual detail; small area at feel detail?
        > Envoys able to break all shapes into numerous smaller shapes
          for ultra-high detail; also useful for microscopic avatars
    - Mouselook smoothing
      > E.g., if mouse resolution results in a 10-pixel movement of the
        scene for each pixel of mouse movement, the movement should be
        interpolated so that it isn't jerky when the mouse is moved
        slowly
      > Could just be a matter of choosing a resolution that results in
        mouse pixel = screen pixel
    - Decide whether to build in things like feel, temperature, specific
      heat, etc
      > These could be properties of objects, or they could be
        independent messages mapping to points on the user's skin where
        the sensation is felt, or both
    - Figure animations (as long as an envoy can do it)
    - Sound
    - Inventory system with remote object browser integration
  - Envoy
    - Obviously these need to be loaded
      > http://gist.github.com/36217 shows an example sandbox function
        in Clojure; try this for restricting envoy permissions
    - Forbid connecting to SMTP
  - Server
    - Group dm transactions into SQL transactions
    - Call dm callbacks after SQL transaction finishes
    - Clean up idle nodes
      - Maintain a separate map in memory of the last-read times for
        each node; this could be a wrapper around dm
      - Add is-loaded to the API; use that while hunting for nodes to
        dump to avoid attempting to access (and thus load) unloaded
        nodes

------------------------------------------------------------------------
- Future:
  - Enhancements for dm
    - Do input validation; each column should have a validation
      function either throwing an exception or returning a data
      structure to be added to the write message
    - Add a :row type that encodes and decodes to the entire row (with
      other columns possible as well)
      - Decoder functions take an input row, return result of adding
        the decoded column to that row
    - Add callback handling in writer thread/agent
      - If write has a :callback, call it with true if query performed,
        false if canceled
        - send for :callback, send-off for :callback-off
  - Make dm-insert and bk-insert, etc., multimethods
  - Server for mass-audience events:
    - Performance recorded on a short delay in an arena with no audience
    - Performance encoded into a series of semi-large packages of
      actions and their times
      > (DList Real:time DvtpExt:event Real:time DvtpExt:event ...)
    - Packages compressed and signed
    - Packages distributed peer-to-peer
    - Envoys receive them, unpack, and send each event to the client at
      the time at which it is scheduled to occur
    - Audience can interact with nearby audience members, or other
      people in the private box, for example; rest of audience simulated
      algorithmically in such a way as to appear the same to everyone
      (except those near enough to see the real audience)
    - Audience members can enter stage, but ideally they should appear
      to go through a tunnel that might take some time, explaining the
      delay
    - Audience member returning to the seats would need to be delayed to
      avoid appearing in two places at once
  - Sleep mode (suspend all envoy threads and stop rendering)
    > In a menu item, not a button; this is not something someone is
      going to need to hit in a moment of frustration like the mute
      button
  - Tabs: Why not?  Put them on top like Chrome
    > A mute button in each tab itself, appearing only when that tab is
      making a sound, and for several seconds (30?) afterward, just
      perceptibly smaller than when the site is actually making sound
  - Reestablishing a multiplexed connection after it is dropped
    - The receiver will likely reset correctly and discard any half-sent
      objects, but a sender will need to back up and retransmit
      > Right now, I think I might be discarding the sent bytes
  - Backward compatibility
    - Client should be able to ignore child classes of EnvoySendable
      that it does not recognize
      > Is this just a matter of making the default case a fall-through?
  - Textures must be specifiable as URLs (?) or else they can only be
    loaded from the DVTP server, because that's all the envoy can
    connect to
  - Add support for Scheme source code envoy (using SISC)
  - Need a test that exposes that a server is not threadsafe
    - Tests can run with N threads; good values of N to test would be 1,
      2, 10, 100, maximum that will fit in memory
    - Test that a sequence of objects inserted into a NetOutQueue are
      all received at the other end
  - Teaching mode: function that takes a current application context
    and a set of skill mastery levels and returns a hint for a
    relevant skill that has not yet been demonstrated.
    > E.g., right-clicking on objects to get a menu, entering URLs,
      saving bookmarks, using bookmarks, etc.
  - For paranoid security, suspend all untrusted threads while
    performing public-key computations
  - Envoy: short-range chat:
    - Nearest N people (six or seven -- what a person can normally keep
      track of in conversation) appear along the bottom and scroll up,
      horizontally aligned with the person speaking (arrows for people
      off the edge of the screen)
    - In a crowd of people, speech from those further away appears above
      the horizon
    - For calculating distance, factor in the direction the speaker is
      facing (but not the listener)
    - Focus on a person makes their speech boldface?  Decreases distance
      - Press F and click?  Hover and press F?
  - Learning mode: periodically pops up hints and available commands?
  - Client: master volume control and mute button/keystroke
    > Mute icon blinks (optionally) when something is trying to make
      noise
  - Option to swap brackets and parens (so '[' key sends '(', etc.)
  - Client: prompt user if site requests resize; one option should
    defeat malicious sites that flood the user with resize requests and
    make the client unusable without killing/restarting (i.e., "Never
    for this site")
  - Client: prompt user if site requests all heads-up UI elements be
    hidden (pointing out that they can be brought back by selecting the
    menu "Interface / (Un)hide all")
  - Client: Some way to tell whether a texture has finished loading --
    few things are more annoying than standing in front of a texture,
    wondering if it is ever going to get less blocky
  - Client: any grayed-out menu item must explain why it is disabled
  - Client: boldface the hostname in the location bar
    > Could lead to confusion when on a stitched-together pass-through
      site
  - Good idea from SL: explicit affordance, such as highlighting
    clickable objects in red when the user holds down the alt key
    > Even better: auto label them with the name of the action
  - On the server side, "links" should include some metainformation
    about whom to notify when the link breaks.  This information would
    not be transmitted to clients; the client would notify the server
    that the link was broken, and the server would pass that
    notification along
    > A DvtpBrokenLinkMessage object, becoming a broken-link Darc
      message
  - iTunes-like interface for managing in-world objects and inventory
    > Ideally, there would be a single interface for both categories,
      but that raises a big question mark about how (and where) to
      implement such a thing
      > With a protocol for passing object directories around; it has to
        be done
  - Envoy-side collisions with no trust needed
    > Any envoy may report a moment and point of collision between two
      objects; the server knows the trajectories of the objects,
      verifies the collision (cheap), and calculates resulting forces
      > The same method could be used to pass this back to the client,
        if it were advantageous to use the client's world tree
    > Collision with a door non-physical object is required for crossing
      into a solid cell
    > Server could apply simplified physics in unattended areas
  - History tree(s), as suggested by
    > http://www.jacobsheehy.com/technology/browsing-the-web-with-a-tree
    - Each RedirectUrl creates a branch
    - A SetUrl starts a new tree, but with a dotted line to where the
      user was; can connect as a branch
  - Editor with syntax highlighting
    - Envoy sends client a bunch of HTML
      - <noedit></noedit>?  Is there a standard way to do that?
    - Client renders HTML in an editing box
    - Updates and/or keystrokes are sent back to the envoy; envoy can
      send back updates with new HTML tags as well
    - Named colors would provide an easy way to configure color schemes
      at the client side (?)
  - Standardize Autofill EARLY
    > That is, if there's any ablity to fill out forms with things like
      name, address, etc., standardize the field names and implement an
      auto-fill method early on
  - Should be able to cache R-tree nodes (in the envoy, keeping them in
    cookies)
    - Just check the top-level node on the server; if the timestamp is
      the same as the cached one, no need to update any of the subnodes
  - Use PGP (or something similar) for authentication?  What's the legal
    status of that?
  x WibbleConfrobulator class
  - When graying out a menu item, give a reason for doing so; hovering
    over (or selecting) the menu item shows the reason
  - URLs should have spaces and other illegal chars removed in the
    address part, not converted to %XX
  - Distroversity!  The name is too good not to use
    > a.k.a. DVU (but this also refers to a far-right party in Germany)
    - Darc tutorials:
      > Will need to address objections to Lisp
        > Lack of syntax (explain that this may look confusing at first,
          but is quickly learned, and is related to many powerful
          abilities that other languages don't have)
        > Symbols seem like retarded strings (they are more like
          variable names -- don't think of them as strings)
      - For people who have never programmed before
      - For people with limited programming experience in one language
        - Visual Basic (see "never programmed before")
        - Java
        - Perl
        - Python
        - Lisp?
      - For people with extensive programming experience in various
        languages, but no Lisp (for shame!)
      - For Lisp hackers who have never tried Arc
      - For Arc hackers
        - The shortest and easiest one to write; do this first
  - Darc editor: paren/bracket coloring
    - Could do this strictly in the envoy, by updating html
    - Or perhaps bind ( to commands color/insert/send/color
  - Use bittorrent for downloading envoys?
    > Comes with default file to check for updates
    > User can add/remove index files of course
  - 2D mode, in which only GUI objects are valid (others ignored), for
    efficiency and to allow browser-like behavior
  x Distroplane: object scripting bytecode language
    > Distrocode?
    x Objects have properties, some of which can be attached bytecode
    x Message passing between objects
    x previous_object()->owner() and this_person(), just like LPMUD
    x Public/private/protected methods:
      x If a method is defined as public, it has property 'visibility =
        'public
      x Default message receiver in class Object does this when called
        for a message from another object:
        [method_object getProperty visibility]
        > Shorthand for (send method_object 'getProperty 'visibility)
        x If result is 'public, the method is called
        x If result is 'private, the method is not called
        x If result is 'protected,
          x Message receiver then checks whether the sender of the
            message is owned by the same user as itself; if so, method
            is called, else not
    > This idea has changed significantly; see notes
  - Configuration of new server:
    - Menu: World/Create/v1.0
      - Also have menu: World/Create/Email me version news...
        - Pops up window saying, "Would you like to be emailed when new
          versions of Distroplane are available?  Enter the address to
          which mail should be sent:" along with checkboxes:
          - Major stable versions (v1.0, v1.2, v2.0, etc.)
          - Minor stable versions (v1.0.8, v1.0.9, v1.2.0, etc.)
          - All minor versions (v1.0.8, v1.1.32, v1.1.33, v1.0.9, etc.)
    - Ask for name of world (should probably be renamable later)
    - Download Distroplane class, create a directory for it to run in
    - Start Distroplane with current user's public identity info set as
      Creator
    - Initially, only allow the Creator to connect
    - Connect to world; use in-world interface to set it up
      - An avatar with the Creator bit set can access all protected
        methods of every object automatically
      - A Creator connecting to a Distroplane sees the message, "You are
        the Creator of this world" with a "Renounce" button.  (Help
        question mark should explain that "renouncing" is temporary
        only, and that transferring of Creatorhood can be done through
        the World Configurator object, which is the only object floating
        in the void in a newly-created Distroplane, and which can be
        summoned again with World menu >> Summon Configurator)
  - Auto-compress groups of queue objects when the output queue gets
    full
  - (import object) or (import /path/object):
    - Calls something on object to get a list of functions to import
    - Defines each of them as /object/each
  - Check for /Volumes/USB Drive/Distroverse/my_identity.txt
    > So people can visit Internet cafes and plug in their little USB
      pen drives instead of typing a password.  Could even have some
      standardized way of generating one-time keys -- a button you press
      on the pendrive that generates a new key
      > Might not be so valuable, though -- most people would probably
        tend to avoid sketchy Inet cafes
  - .dvapp format
    - Standalone application that runs on the local machine and can
      access arbitrary remote hosts and ports; communicates with client
      using DVTP
    - Perhaps some sort of sandbox; pop up a warning dialog:
      - This application wants to connect to: *.foo.com
      - This application was (not) signed (by foo.com)
    - Also, give it a directory to play in, and don't allow it to go
      outside it
    - Except for generic file-open/save dialogs in the client
    - Extensions would be bound to the DV client, and it would have its
      own registry of extensions to .dvapps
      > This is unfortunate, but
      > They couldn't be bound to the .dvapp if that were itself a
        document type handled by the DV client
  + Try replacing the writer thread with an agent; send clean-queue
    function after every outer transaction
  + Switch to a better language targeting the JVM, once something mature
    emerges
    > Probably Rhino
    > Also hyped are Scala, and ... okay, nothing is as hyped as Scala,
      but maybe that's just because they all got together and ambushed
      the comments on
      http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html
    > Maybe Jython or JRuby
    > Maybe the architecture is:
      > Java or fully Java-callable libraries
      > Other projects in other languages, at a higher level
    > Looks like I'm going with Clojure
