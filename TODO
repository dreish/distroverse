                                        -*- Text -*-

- To do for 0.02:
  - node_tree.clj (ns node-tree)
    x durable-maps/dm-annotate
      x Add impermanent things to a map val (without generating a
        write)
        x Verify that db-stored fields are unchanged?  Or not?
        > Problem: this would cause the write to fail to happen
          > Which happens to be the same reason this isn't necessary
            for scalability
    x Child/parent nodes exist as ints, and refs get looked up and
      stored in a non-saved map
      > Problem with this is that if I want to be able to clean out
        the table, these refs might become invalid
    > The answer for now is almost certainly to just not try to cache
      anything
  - Add a FengGUI location bar
    - Would be nice to know why TextArea causes OpenGL exceptions
  - Implement actual movement
  - Use trusted path for dialog boxes that shouldn't be spoofed (f10?)
    > Also nice because it avoids having system dialogs swallow a
      stray enter key or spacebar
  - Add textures to Shape class
    - Specify color of each triangle
    - Include image
    - Each triangle includes an image transform
  - Add WarpShape message
    - Polynomial/sin change over time, but each coefficient is a Shape
      instead of a vector or quaternion
      > Shape must be topologically identical to the one it applies to
  - Add AddRef message
    > Object id and MoveSeq
    > Creates a new object with the same shape as another object and
      its children
    > Changes to the other object's shape affect referring objects
      > This includes texture
    > Changes to child shapes and their relative positions also affect
      child shapes and positions of referring objects
  - Client input
  - Cookies
  x Override default serialization in PointArray to guarantee that the
    protocol doesn't change due to changes in Point3d's serialization
  - Reimplement ball factory with a stack of DynPolygons
    - DynPolygon( origin, top_vector, side_vector, n_sides )
      - get(n) -> vertex of polygon
        - where n % n_sides == 0 -> origin + top_vector
        - where (n % n_sides) * 4 == n_sides -> origin + side_vector
      - Could make this iterable, no?
    > This should hopefully simplify generation of sections of a ball,
      as well as possibly being useful for other things
  - Add better logging facilities
  - Time out synchronous queries
  - Show some sort of "loading in progress" status indicator when
    going to a new URL, before the connection is fully established
  x Switch to latest jME
    + svn checkout http://jmonkeyengine.googlecode.com/svn/trunk/   \
      jmonkeyengine-read-only
    + git commit old version
    + Remove * .cvsignore
    + Copy in new jME 2
    + git commit new version
    x Try loading some tests from within Eclipse
      > Great, it crashes
    x Find some instructions and follow them
    > SVN version is not ready
    + Go back to 1.0
    + CVS update to get jME 1.0.1
  + Now getting errors loading about:hello
    + ControllerPipeline should have the ProxyClientConnection, not
      ViewerWindow; otherwise there's no point to it
      + The ProxyClientConnection currently has a way back to the
        ViewerWindow, and gives that to the ViewerDispatcher; this
        must instead go through the pipeline (which should have the
        dispatcher)
  + Would be nice to know why everything renders with the wrong Z-order
    + Trace through rendering
      x Trace deeper into GL11.glDrawElements(), called from
        LWJGLRenderer.draw( TriangleBatch )
        x Need to attach source to LWJGL
    + Look at the code in a demo clearly lacking this problem
      + jmetest.shape.TestTube renders a single complex shape with
        correct hidden-face removal; I should be able to at least do a
        single sphere correctly
        + Only thing I see that is different is the shape; Tube vs. my
          hand-rolled TriMesh
          > jmetest.input.action.TestFirstPersonController also uses
            multiple hand-rolled TriMeshes, and also has the same
            problem
          + Look at how Tube is constructed
            > With TrangleBatch, extending TriMesh
            > With all values set in the NormalBuffer
          + Add a Tube and randomize its vertices' colors
            > Amazingly, it has the same problem, so it can't be the
              lack of normals (the Tube has normals)
          + Try changing TestTube so its Tube doesn't have a texture,
            but just random colors
            > This requires turning off the light; otherwise the Tube is
              just grey
          + Found it
            + Must call mRootNode.updateRenderState() after adding a Z=
              buffer to it, as is done in BaseSimpleGame.initGame()
          x Try copying the Tube class and warping the vertices
          x Try converting Shapes to something subclassing TriMesh,
            patterned after Tube
            x DvTriMesh Shape.asDvTriMesh()
          x Does this not get back to the problem I brushed past a while
            ago: my generalization of shapes breaks down because I don't
            know which side is in and which side is out?
            > Might have to just pick an arbitrary handedness for shapes
            > The other possible problem is that I regard shapes as a
              stack of independent strips; there might b no easy
              correlation between them
      x jmetest.scene.TestPassNode
  + Disallow empty MoveSeq in MoveSeq constructor & reader
  + Add flag for invisible shape in AddObject
  + ReparentObject (138)
  + SetShape (136)
    + id
    + Shape
    + WarpSeq
  + SetVisible (140)
    + id
    + bool visible
  + ClearShape (139)
    + id
  + Warp (34)
  + WarpObject (137)
    + id
    + WarpSeq
  + WarpSeq (35)
  + Get a real GUI - FengGUI most likely
    + Relocate from ~/Downloads/src/org
    + Add jar
    + Attach source
    + Try a trivial test -- a dialog box with a message
      + Make this a standalone app, and then migrate the code back into
        Viewer
        > Just using the example for this
    + Wrap the whole ViewerWindow in a FengJME GUI and add root node to
      it
      + Subclass a BaseGame like FengJME
        + DvWindow; provides some useful general methods for adding
          nodes, getting protected access to the FengGUI display,
          update()ing
        x ViewerWindow extends DvWindow; is specific to the Viewer app
          > Because I dislike the BaseGame namespace, I'll make
            ViewerWindow contain a DvWindow, not extend it
      x ViewerGui.setViewRoot( Node )
    + Add shapes
      + about:hello test only reaches addShape() after the window is
        closed; trace execution and find out where it gets stuck, how I
        can make it flow through as before
      + There's a race condition in creating a window and immediately
        attaching the ViewerGui node to it, in ViewerWindow();
        initialize mRootNode in DvWindow()
      + WorldGraph.addShape() is still being called, but the shape does
        not display; find out whether the wg is a child of the node
        actually being rendered
        + Breakpoint in wg.addShape() and in DvWindow.render()
          x Does something need to be happening in update()?
            > From reading AbstractGame, probably not
      x Are there any seemingly superfluous calls that need to be made
        on one or more of the nodes for them to be displayed?
        > Apparently not
      + Try adding mBox to "mRootNode" again
      + Then move the add to AboutControllerPipeline
        + Make static DvWindow.mRootNode public
        > This succeeds
      + Then add it to a child node ("GUI-root")
        > This fails
      + What is different between "mRootNode" and "GUI-root"?
        > Orthographic?
        + Yes, make a window root and attach both world root and GUI
          root under that
      x Then try adding one of my shapes asTriMesh()
      x Are the objects' positions or sizes preventing them from being
        displayed?
    + Shapes are not bobbing; why?
      + Probably need to fill in the update() method
        > Controller is still being added to nodes as before
        + Find out how SimpleGame does it
          > Just: mRootNode.updateGeometricState( tpf, true );
    + Find out from Joshua Keplinger what license FengJMEInputHandler
      is offered under; also whether he wrote FengJME, and what
      license for that as well
      > Was released under a compatible BSD license
  + Replace all GPL copyright banners with the one currently in
    WorldSession.java; LGPL files do not need to change
    > (To allow gradual conversion to Clojure, including the contrib
      library)
  + CTrans class - Client Transaction; list of ProxySendables
  + Fix mutability problems in DVTP classes
    + Make Dict copy a map rather than adopting one
    + Make all readExternal() methods private
    + Add constructors with InputStream to all classes
    + Rewrite DvtpObject reading code
      + Using reflection to look up the constructors each time would be
        slow, but storing them and calling them should not be
    + Rewrite all DVTP classes built out of other DVTP classes that use
      readExternal()
    + Remove all set methods
      > Except in DNodeRef, but much of that design might go away
    + DNode can't use part of AddObject, since there's no way to set the
      ID after reading; it needs to be a separate class (DObject)
      factored out of AddObject
      + Unless I made a withId() method returning a new object ...
  + Dict is not immutable; it should be
    + Also, change implementation to use any Map; change hashCode to
      the sum of the hashes of keys * 852403729 ^ hashes of values
  + Get rid of KNOCK command
    > A DVTP proxy will be allowed to connect to any server, at any
      time, on any port except SMTP, which is always forbidden
    + Remove handleKnock()
  + Remove WorldSession class
    + Put getPeerAddress() in NetSession class
    + Rewrite server code to take a session and an attachment
    + Look up attachment in handler methods in WorldServer; pass them
  + Make all private DVTP-message fields final and debug
  + Begin implementing WorldServer (extends DvtpServer)
    + Add DVTP messages:
      + GetCookie (DvtpExt) (26)
      + Cookie (DvtpExt Bool DvtpExt) (27)
      + AskInv (Str DvtpExt) (134)
      + ReplyInv (DvtpExt Bool DvtpExt) extends Cookie (135)
    + Add DVTP Dict class (28)
    + DLong (31)
    + Frac (32)
      + toFloat()
      + toDouble()
    + Real (33)
      + toFloat()
      + toDouble()
    + DNodeRef class (29)
      + Str RemoteHost
        > 0 means sending host
      + ULong id
      + Real lastChangeTime
        > Not compared
      + DNode
        > For convenience; not externalized or compared
    + DNode class (not client<->proxy, as AddObject is) (30)
      + AddObject being
        + AddObject.readWithoutId( InputStream in )
          > Sets Id and ParentId to 0
          > Proxy will pick a locally unique ID and set it as it
            receives the DNode
        + AddObject.writeWithoutId( OutputStream out )
        + Compare with AddObject.equalsWithoutId()
        + Hash with AddObject.hashCodeWithoutId()
      + Float radius
      + DNodeRef this
      x Boolean hasParent (parent != null)
      + DNodeRef parent
      + array of DNodeRefs, children
    + Add all new classes to TestExternalization
      + And implement equals()/hashCode() as required
    > Proxy will need to maintain maps, both of RemoteHost/id and of
      local id, to either DNodeRefs or DNodes
      > Which one will depend on how the map will be used most often
      > Break out RemoteHost/id as its own type?
        > Not necessary; just make those identity fields define equality
    + Create WorldServer in Lisp; otherwise this is going to be a major
      bummer
      x All the node management will be in Java, but the response/
        callback structure will be a major pain in Java.  Java no likey
        callbacks
	> Actually node management, as state shared by multiple
	  threads, is the strongest argument for using Clojure
      + Get and install Clojure
      + Enjoy the consing for a few minutes
      > http://en.wikibooks.org/wiki/Clojure_Programming demonstrates
        how to call a Clojure function from Java
        > (The docs give the reverse case, which is trivial)
      + Install Emacs for OS X
      + Install Clojure support for Emacs
    + Request identity
      + Clojure macro (async) for weaving a do-like construct into a
        series of messages and callbacks
        x Gotcha: all callbacks will need to be removed at the end of
          the pseudo-function
        > (async) always returns nil
        > Actually, just a simple let-like macro
        + Figure out how the end-result code should actually look
        + Write it as an async macro call
        + Then write a macro that goes from B to A
    + Create new user if needed (from skeleton user)
      > Has default starting location
    + Ephemeral universe generation
      + universe-spec
      + gen-fractalplace
        + new-topnode
	  + Problem: This generates nodes with a radius larger than
	    those made with new-subnode; they will exceed the bounds
  	    of their parent nodes
	+ new-subnode
      + Node seed to child node seed
        + Node has a seed-mutation-shift
        + Child node's seed-mutation-shift is parent's (+ 1) (rem 60)
        + Node's seed is:
          x First long generated from rand sequence using parent's seed
	  x bit-xor (node-index << seed-mutation-shift)
	  > xoring the parent's seed instead
  + Plug server into database
    x Need FIFO map (for db-query caching so they're
      transaction-safe): 
      x Created with a length limit, L
      x Adding something new to it, if the (L+1)th thing, causes the
        oldest one to disappear
      x Would be handy to make a version where reading also updates
        the place in the queue
    + Set up Java MySQL driver
    + Pull out db stuff into its own package, wrapping the SQL
      ugliness
      + dm-create-map!
      + Outstanding issues with:
        + Whether select returns a ref or a hash
          > Almost surely a hash
          + local-select and database-select return refs
          + dm-select derefs it
        + Implementation of dm-update based on the above
          + Internal functions return the refs
          + assoc-new-or-retry if the key wasn't already in writes
          + Otherwise alter it in writes
      + dm-init!
        + Create (if not exists) mtables and mvar
        + Getting a null pointer exception from run-stmt
          > SQL commands look perfect
      + Rename translate-val -- there are two directions of
        translation
      + Test
        + Compile everything except the writer thread
          > Will run writes manually
        + Create a dmap
          + (dm-create-map! "test1" {:cols {:mykey ["VARCHAR(32)"
            :str] :myval ["BLOB" :obj]} :key :mykey})
            + get-row must handle the empty set result case
            + next-inname-num doesn't work at all
              + Add an assoc in there
            + On inserting a row, whether to :read (by
              database-select), or to :write (by insert/update), the
              val should be a ref to a hash
            + Row should probably contain the key as well
              x insert-query needs to get the key, obviously
                > That's up to whomever calls dm-insert
                > But I see dm-init! does need to create that var
              + The update probably shouldn't try to set the key
              + WHERE clause in update query has ":varname"
              + Why is it an update?  Why no insert?
                > Because I didn't insert it, dummy
              x Don't add things to the write queue if they have nils
            + Still not creating table
              + inname-num gets added to (*var-map* :write) with key
                equal to clojure.core/key
        + Insert query for new table did not encode spec
          > Also, insert query for new mvar did not encode val
          + Remake tables using text instead of blob
        + Add some stuff to it
        + Flush writes
        + Examine the database from a mysql prompt
        + inname-num got written twice; the first shouldn't have
          happened
        + Update doesn't encode columns -- set or where clause
        + Reload library and attempt to read previously-written data
          + Table gets loaded with :table nil, :spec nil
      + get-row needs to return a column-name -> value hash
        + And the in-memory table needs to wrap that hash in a Ref
      + Need a global write queue, not per-table queues
        + A write is an SQL stmt, the hash equivalent of the values
          being set in the stmt, and a Ref to the in-memory version of
          the row
        + If the hash no longer equals what the Ref points to, cancel
          the write
      x (table-map tablename key "*") => mapx
        x (mapx "foo") does a select * from tablename where key =
          "foo"
      + init
        + Create mtables and mvar
        + Populate mvar with
          + inname-num
      + Writer thread
        + If :required, don't bother to check for a ref
        + Else, if ref doesn't match row being inserted, cancel
      > I think this encapsulates the node caching stuff I was going
        to do separately.  Why carry around two different objects in
        my server code?
        > Somewhat complicated, but worthwhile
          > For example, the object can't be immutable because a
            database table isn't, so it can't support conj or assoc
          > Instead, there will be real mutation functions specific
            to database tables, but they will only happen to the real
            SQL table when an STM transaction succeeds
            > But these will be visible within the transaction, which
              means there will need to be key-value mappings that
              can't time out until they are committed
              > But that means different views of the same table won't
                share the in-transaction changes (within a single
                transaction), which seems awful
              > Worse, they might cache out-of-date values
              > Maybe the answer is to just allow a single view of
                every table and intern table-map per tablename

------------------------------------------------------------------------
- To do for 0.03:
  - Text

------------------------------------------------------------------------
- To do for 0.99:
  - Client
    - Text -- can't escape the morass
    - kp-enter to switch between mouselook/pointer mode
    - Sound
    - Shape smoothing
      - Should this all be done at the proxy level, with additional
        polygons?
      > Goal: a future client with tactile output should be able to
        distinguish between sharp and rounded edges
      > Render versus feel detail levels?
      > Render large area at visual detail; small area at feel detail?
        > Proxies able to break all shapes into numerous smaller shapes
          for ultra-high detail; also useful for microscopic avatars
    - Mouselook smoothing
      > E.g., if mouse resolution results in a 10-pixel movement of the
        scene for each pixel of mouse movement, the movement should be
        interpolated so that it isn't jerky when the mouse is moved
        slowly
      > Could just be a matter of choosing a resolution that results in
        mouse pixel = screen pixel
    - Decide whether to build in things like feel, temperature, specific
      heat, etc
      > These could be properties of objects, or they could be
        independent messages mapping to points on the user's skin where
        the sensation is felt, or both
    - Figure animations (as long as a proxy can do it)
    - Sound
    - Inventory system with remote object browser integration
  - Proxy
    - Obviously these need to be loaded
      > http://gist.github.com/36217 shows an example sandbox function
      	in Clojure; try this for restricting proxy permissions
    - Forbid connecting to SMTP
  - Server

------------------------------------------------------------------------
- Future:
  - Add callback handling in writer thread
    - If write has a :callback, call it with true if query performed,
      false if canceled
      - send for :callback, send-off for :callback-off
  - Server for mass-audience events:
    - Performance recorded on a short delay in an arena with no audience
    - Performance encoded into a series of semi-large packages of
      actions and their times
      > (DList Real:time DvtpExt:event Real:time DvtpExt:event ...)
    - Packages compressed and signed
    - Packages distributed peer-to-peer
    - Proxies receive them, unpack, and send each event to the client at
      the time at which it is scheduled to occur
    - Audience can interact with nearby audience members, or other
      people in the private box, for example; rest of audience simulated
      algorithmically in such a way as to appear the same to everyone
      (except those near enough to see the real audience)
    - Audience members can enter stage, but ideally they should appear
      to go through a tunnel that might take some time, explaining the
      delay
    - Audience member returning to the seats would need to be delayed to
      avoid appearing in two places at once
  - Sleep mode (suspend all proxy threads and stop rendering)
    > In a menu item, not a button; this is not something someone is
      going to need to hit in a moment of frustration like the mute
      button
  - Tabs: Why not?  Put them on top like Chrome
    > A mute button in each tab itself, appearing only when that tab is
      making a sound, and for several seconds (30?) afterward, just
      perceptibly smaller than when the site is actually making sound
  - Reestablishing a multiplexed connection after it is dropped
    - The receiver will likely reset correctly and discard any half-sent
      objects, but a sender will need to back up and retransmit
      > Right now, I think I might be discarding the sent bytes
  - Backward compatibility
    - Client should be able to ignore child classes of ProxySendable
      that it does not recognize
      > Is this just a matter of making the default case a fall-through?
  - Textures must be specifiable as URLs (?) or else they can only be
    loaded from the DVTP server, because that's all the proxy can
    connect to
  - Add support for Scheme source code proxy (using SISC)
  - Need a test that exposes that a server is not threadsafe
    - Tests can run with N threads; good values of N to test would be 1,
      2, 10, 100, maximum that will fit in memory
    - Test that a sequence of objects inserted into a NetOutQueue are
      all received at the other end
  - For paranoid security, suspend all untrusted threads while
    performing public-key computations
  - Switch to a better language targeting the JVM, once something mature
    emerges
    > Probably Rhino
    > Also hyped are Scala, and ... okay, nothing is as hyped as Scala,
      but maybe that's just because they all got together and ambushed
      the comments on
      http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html
    > Maybe Jython or JRuby
    > Maybe the architecture is:
      > Java or fully Java-callable libraries
      > Other projects in other languages, at a higher level
    > Looks like I'm going with Clojure
  - Proxy: short-range chat:
    - Nearest N people (six or seven -- what a person can normally keep
      track of in conversation) appear along the bottom and scroll up,
      horizontally aligned with the person speaking (arrows for people
      off the edge of the screen)
    - In a crowd of people, speech from those further away appears above
      the horizon
    - For calculating distance, factor in the direction the speaker is
      facing (but not the listener)
    - Focus on a person makes their speech boldface?  Decreases distance
      - Press F and click?  Hover and press F?
  - Learning mode: periodically pops up hints and available commands?
  - Client: master volume control and mute button/keystroke
    > Mute icon blinks (optionally) when something is trying to make
      noise
  - Option to swap brackets and parens (so '[' key sends '(', etc.)
  - Client: prompt user if site requests resize; one option should
    defeat malicious sites that flood the user with resize requests and
    make the client unusable without killing/restarting (i.e., "Never
    for this site")
  - Client: prompt user if site requests all heads-up UI elements be
    hidden (pointing out that they can be brought back by selecting the
    menu "Interface / (Un)hide all")
  - Client: Some way to tell whether a texture has finished loading --
    few things are more annoying than standing in front of a texture,
    wondering if it is ever going to get less blocky
  - Client: any grayed-out menu item must explain why it is disabled
  - Client: boldface the hostname in the location bar
    > Could lead to confusion when on a stitched-together pass-through
      site
  - Good idea from SL: explicit affordance, such as highlighting
    clickable objects in red when the user holds down the alt key
    > Even better: auto label them with the name of the action
  - On the server side, "links" should include some metainformation
    about whom to notify when the link breaks.  This information would
    not be transmitted to clients; the client would notify the server
    that the link was broken, and the server would pass that
    notification along
    > A DvtpBrokenLinkMessage object, becoming a broken-link Darc
      message
  - iTunes-like interface for managing in-world objects and inventory
    > Ideally, there would be a single interface for both categories,
      but that raises a big question mark about how (and where) to
      implement such a thing
      > With a protocol for passing object directories around; it has to
        be done
  - Proxy-side collisions with no trust needed
    > Any proxy may report a moment and point of collision between two
      objects; the server knows the trajectories of the objects,
      verifies the collision (cheap), and calculates resulting forces
      > The same method could be used to pass this back to the client,
        if it were advantageous to use the client's world tree
    > Collision with a door non-physical object is required for crossing
      into a solid cell
    > Server could apply simplified physics in unattended areas
  - History tree(s), as suggested by
    > http://www.jacobsheehy.com/technology/browsing-the-web-with-a-tree
    - Each RedirectUrl creates a branch
    - A SetUrl starts a new tree, but with a dotted line to where the
      user was; can connect as a branch
  - Editor with syntax highlighting
    - Proxy sends client a bunch of HTML
      - <noedit></noedit>?  Is there a standard way to do that?
    - Client renders HTML in an editing box
    - Updates and/or keystrokes are sent back to the proxy; proxy can
      send back updates with new HTML tags as well
    - Named colors would provide an easy way to configure color schemes
      at the client side (?)
  - Standardize Autofill EARLY
    > That is, if there's any ablity to fill out forms with things like
      name, address, etc., standardize the field names and implement an
      auto-fill method early on
  - Should be able to cache R-tree nodes (in the proxy, keeping them in
    cookies)
    - Just check the top-level node on the server; if the timestamp is
      the same as the cached one, no need to update any of the subnodes
  - Use PGP (or something similar) for authentication?  What's the legal
    status of that?
  x WibbleConfrobulator class
  - When graying out a menu item, give a reason for doing so; hovering
    over (or selecting) the menu item shows the reason
  - URLs should have spaces and other illegal chars removed in the
    address part, not converted to %XX
  - Distroversity!  The name is too good not to use
    > a.k.a. DVU (but this also refers to a far-right party in Germany)
    - Darc tutorials:
      > Will need to address objections to Lisp
        > Lack of syntax (explain that this may look confusing at first,
          but is quickly learned, and is related to many powerful
          abilities that other languages don't have)
        > Symbols seem like retarded strings (they are more like
          variable names -- don't think of them as strings)
      - For people who have never programmed before
      - For people with limited programming experience in one language
        - Visual Basic (see "never programmed before")
        - Java
        - Perl
        - Python
        - Lisp?
      - For people with extensive programming experience in various
        languages, but no Lisp (for shame!)
      - For Lisp hackers who have never tried Arc
      - For Arc hackers
        - The shortest and easiest one to write; do this first
  - Darc editor: paren/bracket coloring
    - Could do this strictly in the proxy, by updating html
    - Or perhaps bind ( to commands color/insert/send/color
  - Use bittorrent for downloading proxies?
    > Comes with default file to check for updates
    > User can add/remove index files of course
  - 2D mode, in which only GUI objects are valid (others ignored), for
    efficiency and to allow browser-like behavior
  x Distroplane: object scripting bytecode language
    > Distrocode?
    x Objects have properties, some of which can be attached bytecode
    x Message passing between objects
    x previous_object()->owner() and this_person(), just like LPMUD
    x Public/private/protected methods:
      x If a method is defined as public, it has property 'visibility =
        'public
      x Default message receiver in class Object does this when called
        for a message from another object:
        [method_object getProperty visibility]
        > Shorthand for (send method_object 'getProperty 'visibility)
        x If result is 'public, the method is called
        x If result is 'private, the method is not called
        x If result is 'protected,
          x Message receiver then checks whether the sender of the
            message is owned by the same user as itself; if so, method
            is called, else not
    > This idea has changed significantly; see notes
  - Configuration of new server:
    - Menu: World/Create/v1.0
      - Also have menu: World/Create/Email me version news...
        - Pops up window saying, "Would you like to be emailed when new
          versions of Distroplane are available?  Enter the address to
          which mail should be sent:" along with checkboxes:
          - Major stable versions (v1.0, v1.2, v2.0, etc.)
          - Minor stable versions (v1.0.8, v1.0.9, v1.2.0, etc.)
          - All minor versions (v1.0.8, v1.1.32, v1.1.33, v1.0.9, etc.)
    - Ask for name of world (should probably be renamable later)
    - Download Distroplane class, create a directory for it to run in
    - Start Distroplane with current user's public identity info set as
      Creator
    - Initially, only allow the Creator to connect
    - Connect to world; use in-world interface to set it up
      - An avatar with the Creator bit set can access all protected
        methods of every object automatically
      - A Creator connecting to a Distroplane sees the message, "You are
        the Creator of this world" with a "Renounce" button.  (Help
        question mark should explain that "renouncing" is temporary
        only, and that transferring of Creatorhood can be done through
        the World Configurator object, which is the only object floating
        in the void in a newly-created Distroplane, and which can be
        summoned again with World menu >> Summon Configurator)
  - Auto-compress groups of queue objects when the output queue gets
    full
  - (import object) or (import /path/object):
    - Calls something on object to get a list of functions to import
    - Defines each of them as /object/each
  - Check for /Volumes/USB Drive/Distroverse/my_identity.txt
    > So people can visit Internet cafes and plug in their little USB
      pen drives instead of typing a password.  Could even have some
      standardized way of generating one-time keys -- a button you press
      on the pendrive that generates a new key
      > Might not be so valuable, though -- most people would probably
        tend to avoid sketchy Inet cafes
  - .dvapp format
    - Standalone application that runs on the local machine and can
      access arbitrary remote hosts and ports; communicates with client
      using DVTP
    - Perhaps some sort of sandbox; pop up a warning dialog:
      - This application wants to connect to: *.foo.com
      - This application was (not) signed (by foo.com)
    - Also, give it a directory to play in, and don't allow it to go
      outside it
    - Except for generic file-open/save dialogs in the client
    - Extensions would be bound to the DV client, and it would have its
      own registry of extensions to .dvapps
      > This is unfortunate, but
      > They couldn't be bound to the .dvapp if that were itself a
        document type handled by the DV client
