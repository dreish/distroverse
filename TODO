> Java 3D examples at:
  http://java.sun.com/products/java-media/3D/collateral/examples.zip
> API documentation at: http://download.java.net/media/java3d/
  builds/release/1.5.1/java3d-1_5_1-api-docs.zip

- To do for 0.01:
  - Play around with planet-building ideas
    + Create a spheroid polyhedron with N roughly equally-spaced
      points
      > BallFactory isa ShapeFactory, Generate() returns a Shape
      > It might be easyish to do this by subclassing LatheShape3D,
        though it would not result in equally-spaced points
      > Otherwise it means using Java3D's GeometryArray
        > Specifically TriangleStripArray
      + Divide sphere into N equally spaced circles of latitude
      	> They're only equally-spaced for mAspectRatio = 1.0, now
      x Calculate distance between those circles, 'd'
      + For each circle, find M: the number of evenly-spaced points
        such that the distance between them is closer to 'd' than for
        any other number
        > This is actually simple enough: just sin(latitude) *
          (n_circles * 2 - 2)
      + Make an array of points starting at prime meridian
        + 0.5*d*(row%2)
      + ShapeFactory.GenerateSurface( Point3d verts[][] )
      	+ Need to flesh out the Shape class for this
      	  > Will every shape be a TriangleStripArray?
      	    > Yes, apparently so
      	    > I might want some way to specify smoothed forms, or
      	      perhaps at least a sphere primitive
        + For each consecutive pair of arrays of points, create a row
      	  in the TriangleStripArray
          x The vertex count is the sum of the number of points in
            the two rows, plus two because two points are used twice
            > No way of knowing how many points will be used without
              tracing through the points
          > It shouldn't matter which side the array starts with
    - Make a simple server that sends the same shape to any client that
      connects to it
      > HelloServer, the server equivalent to Hello World
      - DvtpServer base class
        - Construct with DvtpListener implementation
        - DvtpListener interface/base class
        - DvtpThreadedListener
          - Accepts connections on port N -- 808?
          - Forks a thread for each new connection
          - Listens for commands and passes them to DvtpServer them
        - Dispatches commands to functions that must be implemented by
          subclass of DvtpServer
      - HelloServer responds to the following commands:
        - LOCATION //blah/blah/blah
          > This is for dvtp:// URLs
          - To anyone who connects, send the URL of the proxy to DL
        - GET //blah/blah/blah
          > This is for WWW-like resource URLs
        x PROXYOPEN <internal-identifier>
          > The handshake, not used in HelloServer, closes immediately
          > Not a good idea to throw an exception or otherwise bail out
            because of this message; makes the server easy to crash
      - The proxy doesn't bother trying to connect back to the server,
        and just sends the client a shape
        > Normally it would connect to port 808 as well, sending a proxy
          handshake instead of a client handshake; this server ignores
          the handshake altogether
    - Make a client that connects to that simple server and renders
      whatever shapes it gets back
      - Implement setUrl()
        - Connect to server and request proxy URL
        - If it is the same as the currently-running proxy, send the
          proxy a SetUrl object
        - Otherwise, download a new server and start it up with the
          given SetUrl object
        x In either case, get a result back and show the effective URL
          > This will just be a general UrlChange object, async
      - Listen for, and handle, messages from the proxy
    - Add rotation
    - Deform the points according to my trig functions and see whether
      it produces decent-looking planets
  - Write a simple Java3D app
    + Create a cube
    - Create methods to set its position, velocity, & acceleration
    - Create methods to do the same for its orientation
  - core.DataPackage (abstract)
    - Find out whether something like this already exists
      > Presents a simple array of objects
      > Serialization produces different results depending on 
        implementation
    - core.DataPackagePlain
      > No compression
  	- core.DataPackageGzip
  	  > Gzips entire package to serialize
  	- core.DataPackageTgz
  	  > Wraps everything in a gzipped tarball
  + Check everything into SVN
    > Too easy!
  + Set up backups for svn repository
    > In case things get corrupted
    + 2 daily and 5 weekly
  + <T> T foldr( T[], folder )
    + Why can't I have a public abstract static method (in
      FoldingFunction)?
      > Doesn't need to be static
    x How does Callable work, and would it be sufficient for this?
  + PointArray class in DVTP
  + Package up a TriangleStripArray into a Shape class
  x Test performance of Java3D and of pushing objects from client to
    server; compare
    > No real doubts about the design at this point, unless it turns out
      to be clearly unusable

- To do for 0.02:
  - Add textures to Shape class
    - Specify color of each triangle
  - Override default serialization in PointArray to guarantee that the
    protocol doesn't change due to changes in Point3d's serialization
  - Reimplement ball factory with a stack of LazyPolygons
    - LazyPolygon( origin, top_vector, side_vector, n_sides )
      - get(n) -> vertex of polygon
        - where n % n_sides == 0 -> origin + top_vector
        - where (n % n_sides) * 4 == n_sides -> origin + side_vector
      - Could make this iterable, no?
    > This should hopefully simplify generation of sections of a ball,
      as well as possibly being useful for other things
  - Add better logging facilities

- Future:
  - Add support for Scheme source code proxy (using SISC)
  - Switch to a better language targeting the JVM, once something mature
    emerges
    > Probably Rhino
    > Also hyped are Scala, and ... okay, nothing is as hyped as Scala,
      but maybe that's just because they all got together and ambushed
      the comments on
      http://steve-yegge.blogspot.com/2007/12/codes-worst-enemy.html
    > Maybe Jython or JRuby
    > Maybe the architecture is:
      > Java or fully Java-callable libraries
      > Other projects in other languages, at a higher level
  - Client: master volume control and mute keystroke
  
