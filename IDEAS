
[Note: This is my file for jotting down thoughts as I have them.  I have
done little or no editing of any of this text, so there are plenty of
places where I would choose different words on further reflection, such
as the part where I describe ideal abstractions as "concrete and real".
The first few entries are somewhat disjointed excerpts from a general-
purpose journal.

Remember that this is stream-of-consciousness documentation of an idea
in progress.  A lot of the ideas I had along the way no longer make any
sense.  It took a long time to fully shift my thought process away from
the fat-client/fat-protocol/homogenous-server paradigm and figure out
how something as abstract as what I ended up with would actually work.]

2007-02-04

I just don't have any interest in anything on Second Life anymore.

Then I had ideas of creating a whole sim, or some large
non-residential build like a maze, or a fight zone, but I just don't
have the interest, and I don't think it'll pay off in any significant
way.

I think part of the problem is that my imagination can go so much
farther [sic] than Second Life.  I can imagine a virtual reality world
50 or 100 years from now with truly photorealistic immersive sight,
sound, and feel.  That might be worth my time.

2007-05-26

I just don't have time to get back into that right now.

Sculpties look somewhat interesting, but they're not going to give SL
what it needs to fulfill the full promise of virtual reality.  The
biggest missing feature in my opinion is private space.

Maybe I'm wrong, since you can own your own sim and allow only invited
guests into it.  But that seems less than ideal.

I just don't see SL gradually morphing into the dominant VR universe
over the next ten years.  Someone else is going to supersede them.

2007-10-12

I'm not sure whether this is a good name for the virtual reality ideas
I had kicking around a few months ago, but ... "Distroverse"?

Distributed Universe.

What I had in mind was something where you would connect to another
person's computer and occupy that private space.  Where businesses
would host their own space.

But what would bind it all together?  Wouldn't there need to be _some_
sort of central server?

I don't think my original idea called for everything to be
decentralized.  I think I just wanted to add private spaces as an
alternative.

There's nothing central tying the WWW together.  That was what AOL,
CompuServe, and Prodigy tried to do, and look what happened to them.

Like a web browser, the first few would probably connect to something
like that first central WWW directory I remember way back in 1994.

2007-10-13

I think my original plan was that there would be a terrestrial plane,
and that each square in a grid drawn on that plane would be defined by
whatever the computer at that IP address was serving.  So it would
start out as a vast ocean with a very small number of distant islands,
and then would gradually fill in.

In each of those islands could exist portals to whatever private
spaces the server at that IP address contained.  Or they might be
accessible by direct URL only.

The map of IP addresses to grid locations would be laid out in a
Hilbert Curve, keeping all subnets square so that customers of the
same ISP would tend to be neighbors.

2007-10-15

I was also thinking about looking for the Second Life client source
code to see what license it is distributed under, since I have some
interesting ideas for a virtual reality universe, but there's no way I
could implement a comparable client from scratch myself, or even come
close enough to generate any interest.

So in looking at their "Embracing the Inevitable" announcement, it
seems they're moving in the direction of a more open virtual universe,
with servers other than those owned by Linden Labs.  Maybe they're
just saying that to discourage others from doing the same, but ... if
the client is free, or even just open source, how could they really
stop it?

It's released under the GPL.  Cool as fuck.

So I could download it, build it, and then start hacking away to my
heart's content.

I think the ideal that I have in mind really does call for starting
from scratch, though.

2007-10-18

I predict full-motion photorealistic virtual reality in wide use by
2018.  It'll probably be "photorealistic enough" before that, but I
mean photorealistic enough that one would be able to see the light
filtering red through someone's ear, or a flashlight showing an
avatar's bones through his hand.  And by "full-motion" I mean twenty
frames per second.

So, when will I get to eat my first virtual reality dinner?  And how
much will it cost?

I'm going to say 2028, and since I'll probably be an eager early
adopter, probably around $200.  That's the cost to [or rather price
paid to] the creator of the simulated food, not the cost of the
full-immersion virtual reality client hardware.

It's _that_ sort of flexibility that I want to build -- and that's
what I don't think Second Life can really handle, if their design for
LSL is any indication.  They don't seem to have the object-oriented
religion.  I guess the only way to be certain would be to look at
their server code, but that's 1. not available, and 2. written with
.NET, which I guess suggests that it is object-oriented.

I think maybe I've been away from Second Life too long to be able to
think of all the little things that bothered me about it.  But I
wanted to be able to control ownership with greater flexibility than I
could in Second Life, for example.

Let me think about it in terms of simulating a realistic world ...

In SL, the vast majority of objects cannot be manipulated by anyone
but the owner of the object.  You can't borrow something that belongs
to someone else.  Can't even move it.  That shouldn't be the usual
behavior, I don't think.  It seems to me that everything should be
mod/transfer/no-copy by default.  However, if things are to be
distributed across the whole Internet, onto client machines running
GPL'd clients with built-in servers, I'm not sure how any restrictions
at all would be possible.

Last time I was thinking about this, I think I was still assuming
there would be a central server.  I just imagined it would be ... you
know ... better.  Without the limitations Second Life has, that I
found ... limiting.

If you wanted to be in the business of selling objects, you could, for
example, not transfer ownership of the object, but just grant a use
license and keep simulating the object on your own server.  Maybe.
I'm not sure how well that would go over.  Nor how useful it would be
for relatively simple objects, where the information needed to
reconstruct them would have to be made available anyway.

Just to be able to create my own universes without boundaries would be
a huge gain.  And to have a client that renders distant landscapes as
a static backdrop, say, once every 5 seconds, would really open things
up and enhance the realism.  I'd love to be able to create a cozy
cottage on an Alpine lake and actually be able to see the high
mountain peaks around me.

I'm thinking the world outside the immediate vicinity could be
rendered into two alpha-layered spheres (one for medium distances
(200-2000 meters) and one for far (2+ km)), and those spheres, which
would already have atmospheric effects rendered-in, could be rendered
along with the nearby objects in realtime, providing some crude
parallax effects in case of wandering through mountains sideways or
whatever.

To create a new plane:

- Specify empty space, sphere, or infinite plane
  > Note -- this would allow a simulation of the entire universe, down
    to individual buildings, to be stitched together out of attached
    planes, but planes can exist with no physical boundary with
    another plane (aside from portals)
  > Support for non-Euclidean topology is (initially, at least)
    provided solely through stitching together planes in unexpected
    ways; planes can also be stitched to themselves; a plane is
    locally Euclidean
- Specify base texture -- flat, fractal, or parametric fractal
  > For space, the fractal defines stars, planets, and nebulae
  > Base parameters are vertical scale, base altitude ASL, and
    horizontal scale
    > Or for space, six parameters: average body size, planet-to-star
      ratio, stars per cubic parsec; average galaxy size, galaxies per
      megaparsec
  > Parametric fractal defines the parameters in terms of X&Y(&Z)
    > Is this necessary, or even practical?
- Specify base texture override map and its scale (optional)
  > R=vert bumpiness, G=altitude, B=horiz scale
  > Only available for sphere/plane; for space, use parametric
- Specify altitude override map(s) for plane/sphere
  > Each map has a base x,y location, pixel scale, and height
    multiplier in floating point meters; maps may overlap and are
    additive
  > As diffs from base
  > (R.G)*(2**B) * height multiplier
- Or specify feature database for space
  > Galaxy database, and simple star list (id,x,y,z,mag,color) for
    each galaxy

I think Java is the language to implement Distroverse in.

A Plane is a class, and the various methods can be overriden to create
the flexibility I describe above, and more.

Mapping might be a tricky subject.  But probably each Plane should
provide a MapContext image, so that the illusion of continuity of
interlocking planes could be preserved.

2007-10-19

I just realized one potential big problem with my object-loading idea
(wherein a VR server would load any object from any client): it would
be trivially easy to crash the server by allocating a ridiculous
amount of memory.

Maybe that was the motivation behind LSL.  [Or maybe there's a way to
prevent that in Java.]

In any case, I'll obviously [probably?] have to come up with a
different design, but I'd like to achieve more-or-less the same goals.
Perhaps the paradigm of objects residing on their owners' or creators'
servers would be sufficient.

No doubt simple objects could also exist without any code.

2007-11-04

I've been thinking more about my design for "Distroverse", and I've
decided that I will de-emphasize the idea of passing untrusted code
around to be executed.  That just sounds too much like asking for
trouble to me.

For example, rather than querying a server for the algorithm that
determines a particular landscape, why not just pass the altitude map?

I guess the answer is: Because I want to allow fractal landscapes to
be passed around efficiently and with as little bandwidth as possible.
That was one of my first ideas, and when I began to think about
programming in various facilities for doing that, it seemed to me that
it would be much easier to just allow the passing of arbitrary code.

Okay, so after thinking about it for four minutes, I've
already changed my mind.

Anyway, that's Java's big selling point, so if I'm not going to do
that, I don't need Java.

It doesn't appear to me that Java's security model provides any way of
restricting memory allocation.

So I think I can still work around that.  I'm thinking that the part
that runs Java bytecode on the client end will be like a local world
server, providing higher-speed updates for things like physics and
calculating terrain to be fed to the client.  The client won't run
that code, because it'll be fundamentally untrusted.  So the local
world server will get a limited amount of memory and maybe run at a
lower priority, and if it runs out of memory and dies, the client will
just see it as being thrown out of that particular world and back into
the Internet Plane, which will be more limited.

2007-11-05

What information does the client need in order to display the
universe?

And whence should that information come?

- Objects
- Terrain
- Background

- Objects can refer to another server for updates; this is how avatars
would work.  But this means communication would be O(N^2) for N
avatars in a room.  Probably no avoiding this, except for LoD and/or
limits on how many nearby avatars are queried, and how often.

- Objects can also report animations, looped or unlooped, just like in
SL, so that they don't have to update every little movement N times a
second.  Probably want this to be more generalized than in SL to allow
it to be used for all kinds of objects and non-humanoid forms.

I want it to be as open and as uncomplicated as the WWW, because
obviously that was a successful system that people really went
creatively nuts with.

And it certainly has grown into something more complicated than what
it started out as.  The key was that it was easy to understand, and it
enabled things that were previously impossible, so people flocked to
it.

_That's_ the key I need to focus on.  Not piling on features to
support every conceivable thing that anyone would ever want to make.
The extra features can come later.  The first thing to get going is
just multiple servers -- the ability to move from one space to
another.

Simple, plain spaces.  I should start there and get that working.
Then I can think about starting to add things.

Solutions and designs might start to become more apparent once I have
a basic canvas.

2007-11-06

Distroverse it remains, so far.  That's probably the best name that
isn't already taken.  Ideas coming along nicely.

Objects:
   phase       => { PHANTOM | SOLID }
   mass        => grams
   signature[] => 0 or more certifications of programmer/creator's
                  identity
   active      => has-update-method-p
   update()    => Java code to change state in some way
   seeing      => can-see-objects-around-it-p
   hearing     => can-hear-sounds-p
   smelling    => can-smell-smells-p

(Touch and taste are contact senses, so the client queries contacted
objects for their texture, temperature, and taste, as needed, rather
than receiving events.)

A world server can choose to execute an object's code or not, based on
whatever rules it wants, typically including the signature.  (It can
also reject insertion of objects into the universe altogether.)  If it
does, so do the world caches of any inhabitants.  (Strictly speaking,
the caches are under the control of the end user, who might decide to
implement different policies about downloading objects.)  If it does
not, it notifies whoever tried to transfer the object to the world,
"You're going to have to execute your code yourself, and send me state
updates."

The world-cache is a true cache, not relaying anything back to the
world server.  The principle here is that because the server code is
published, we can move it closer to the client.  World server relays
events to the world cache, which relays them to the local client.
Local client relays actions to the world server, notifying the local
world cache as well.

The major part of the work is going to be hacking the client to
display my worlds instead of Second Life's.  Good thing it's GPL'd.

I'm not going to start from the OpenSim project, because I don't want
to clone Second Life at all.  Their architecture is all wrong.

I haven't even thought about whether objects should be represented
with prims, the same as in SL.  I have big but vague ideas that would
imply I wouldn't do prims, but ... that's an awful lot of work just to
give up physical compatibility.

The whole system of allowing a prim to be made of one of six different
materials -- that's weird.

The UUID system -- that has to go.  Right?  Basic built-in sound
effects, if there are any, will have to be built into the client, not
loaded from a central server, since there isn't any.

Oy vey.

I think I need to rip out ... a lot of stuff.  Maybe prims are useful,
as one possible way of doing things.  They're certainly bandwidth-
efficient, but is that really so important?  Textures consume so much
more bandwidth.

I'm not a fan of Linden Labs' whitespace style -- ASCII tabs and no
apparent line length limit.  At least braces stand alone.

And they're not really big on modern C++.  I'm seeing a lot of for
loops.  To be fair, that's a pretty recent trend, and this code has
been around for a while.

Okay, I was starting to feel overwhelmed, but now I found the starting
point: indra/newview/viewer.cpp.  There's my int main( ... ).

Hey, I just noticed, they _do_ usually use my paren style.  So thumbs
up to that.  I'm used to reading code that doesn't, though.

But on the whole, I have to say I'm not impressed by the code
organization.

2007-11-07

I should get on SL and chat with the coders group to see if there's a
buzzworthy project similar to what I'm thinking of.

Also, I like the idea of a "ghost world", where viewers don't appear
to exist within the world -- they just see it.  That would be much
like a web page, and in fact, I'm thinking companies could serve
content that way, as a 3D world people could wander around in without
seeing each other, so a nearly unlimited number could be looking at,
say, a gallery of the top ten social venues at any given moment.

And the world itself could be a server object that could be cached by
the local resource cache, and it could load all changing content from
a few compact XML pages and jpegs.  (World servers would need to have
controlled network access to avoid being used as spam zombies, for
example.  They should only have access to HTTP and HTTPS protocols.)

I've been debating whether it would be better to throw out the SL
client and start from scratch.  That's why I need to get on there and
chat up the other VR coders.  Problem is, I'm only a member of
"Scripters of Second Life".  I probably need to join another group.

I think the question to ask is, "Does anyone know of any good projects
to build a distributed free-software VR system?  Something where
clients connect to servers anywhere on the Internet?  I.e., CompuServe
: WWW :: Second Life : ___?___"

Oh, here we go.

http://en.wikipedia.org/wiki/Java_OpenGL

I think maybe the client could be written in Java, too.  That would
automatically make it cross-platform.

I rather like the idea of starting from scratch.

Possibly there could even be a "middleware" world server for Second
Life.  That might be interesting.

I know what I'm doing next: performance testing on Java OpenGL.

Or maybe Java 3D.  Hmm.  So very interesting.

There's something called "Project Wonderland".  Too bad the name sucks
[and yes, I get the Alice reference], but maybe there's some code
there worth using.  Or maybe it obsoletes my ideas.

It looks like there are a lot of people doing a lot of things with VR.
So why aren't any of them catching on as an SL-like distributed
alternative?  Are they all lacking some key insight?  Am I
overgeneralizing, such as someone like Tim Berners-Lee wondering
whether the WWW could catch on given how many people were already
doing things with text on the Internet back then?

Wonderland looks very interesting, but [I think] it has a
central-authority based architecture that may or may not be a problem.

I'll need to try it out tonight.

Maybe before I read too much about the architecture (because I'm
trying to figure out whether it does what I want) I should sketch out
more of my own architecture, so that I'm not biased by what I read.
I'm already having a hard time thinking in terms other than "object
IDs".

I do like the Wonderland idea of hierarchical cells, though I wonder
whether that would add too much complication.

It would make it easy to do things like vehicles, like big spaceships
you could walk around in as they traveled, which I was thinking would
be separate worlds.  Maybe separate worlds is a better paradigm.  I
need to think about that.

One big problem with separate worlds is that it would mean downloading
more than one world server, potentially.  I can see resource issues
here.

I like the cell concept a lot.  I think I might use that.

I'm not sure how else I would have handled things like attachments.
Probably not as elegantly.

I have enough important ideas that I don't think I need to sketch out
my architecture any further.  I'd be better off spending my time
looking at what else is out there.

Well, the Sun demo (MPK20) looks interesting.  So why aren't more
people using it?

I'm guessing what it lacks is the ability to move from one world to
another.  So it would be (to use a crude analogy) like BBS systems
instead of the WWW, or maybe more accurately, like the WWW if you had
to go through dozens of hoops to connect to a server instead of just
entering a URL or clicking a link.

It appears to be purpose-built for workgroup collaboration, not
general-purpose.

But it is a pretty awesome implementation.  I wonder whether the code
is as elegant as the demo looks.

The description I'm reading of the software architecture suggests to
me that its biggest flaw might be bandwidth requirements, and maybe
that's related to its apparent workgroup-oriented purpose.  They're
talking about state updates to objects being transactional, and I'm
not sure whether that means every moment of state update is a single
transaction, or whether it just means they _can_ be grouped together
as transactions, which would be a useful feature.

Authentication is going to be an issue.  I hadn't thought about that.
But it seems to me that the first time a user connects to a server,
that user needs to get a new, unique identity from the server.  It
gets some sort of credential that confirms its identity securely
thereafter.

The client stores those credentials, but the server doesn't.  So
clearly that credential would have to be something like a
server-signed packet containing the raw unique ID, perhaps among other
things.  (Perhaps an email address.)

I need to think about what would happen if a user lost all his
credentials.  That would suck.  Perhaps there could be services that
would store encrypted credentials.  Perhaps servers _should_ store
some information, like an email address, to go with each userid.  And
perhaps they could periodically garbage-collect userids that are not
in use.

Even if five billion people signed up for unique IDs at one site, that
would only be around half a terabyte of information, which is already
a fairly modest storage requirement for a big server.

But obviously whatever I use for unique IDs, it'll have to be more
than 32 bits.  64 would probably be safe.

Might as well make it 128.  AIs could eventually number in the
quadrillions.

What am I talking about?  This is a server implementation detail, not
a protocol matter.  But I might as well design it for 128 to keep
things simple later on.

So each cell would have an owner ID (typically -- again, server
implementation detail), and sub-cells could have different owner IDs.
The dimensionless root cell would be owned by the root user for the
server.

As great as this cell stuff is, I wonder whether even _it_ matters for
what I want to do.  It seems to me I just want a simple protocol for:

- Feeding world information (polygons, textures, sounds, and text in
  some form) to clients
- Feeding actions (movement and speech, for example) to servers
- Most importantly, transmitting objects (including avatars) between
  servers

That last one is probably the defining feature.  So I need a
serializable vocabulary of objects, and I need some sort of way of
identifying an object as an avatar, and defining how it moves.

Within that framework, just about anything could exist -- I could work
on a simple reference implementation, but the protocol is king, and
the protocol opens up infinite possibilities.

But authentication could be a key part of that protocol, because of
the need to store tokens locally.

Perhaps if Sir Tim knew everything that was going to have happened in
the 15 years since the invention of the WWW, he might have built
authentication into HTTP as well, of a form similar to what I'm
thinking of.  But ownership of objects is a little different from ...

What about taking a cue from the real world?  Neither my house not its
contents have some sort of meta-tag identifying them as being owned by
me.  _I_ carry a physical _key_ that lets me into my home.  One of my
annoyances with Second Life is the way its ownership system limits
things unnecessarily, and its object model _fails_ to limit other
things (such as entry into my home).  So what if you could program a
cell not to allow anything in unless it was carrying a special object
that granted access?

For which I'll need to figure out what it means to "carry" something.

My goal is to do as _little_ as I possibly can to enable the
realization of my vision, but not to do _less_ than is necessary.

It would have to be some sort of fob with brains that live back on the
client machine ... but then this is just another thing that could get
lost.

More thought is needed.  I think authentication might be the right
track.  I liked where that was going.  You could subscribe to a
service that keeps your encrypted credentials (as previously
mentioned) -- it's simpler to understand from a programming
perspective than the idea of magic key objects and how they're carried
around without exposing the secret to the server (which might not be
trustworthy).  I don't really know how that would work, and therefore
it's too difficult an idea -- it would be too hard to understand.
What the server decides to do with that authentication is another
matter entirely.

But making user identity a focal part of the protocol means the server
could store a user's last location and automatically start them out
there, which could be a key feature for some games.

I don't think there's any realistic way to provide for moving objects
from one server to another without making it impossible to
copy-protect them, but (as I've thought before) there could be a
copy-protect bit that would just display a request any time it enters
someone's inventory, such as, "This work is copyrighted.  Please
delete it if this copy is not authorized."

Pretty much the only way to absolutely protect content would be to
refuse to distribute servers (the local cache), and never to let the
protected content leave the server.

Ah, the local cache.  So let me revise the above list.  A protocol
for:

- Feeding world information (polygons, texture URLs, sounds and sound
  URLs, and textual data in various forms [XML]) to clients
- Feeding actions (movement, speech, and mouse-based interactions with
  objects, for example) to servers
- Optionally providing a downloadable server cache
- Most importantly, transmitting objects (including avatars) between
  servers

That's still a pretty lightweight and flexible protocol.

I'm picturing the connection process, for a first-time connector, to a
physical (i.e. non-ghost) world with no avatar restriction other than
perhaps size, and allowing a full download, as:

1. User enters a URL (or equivalently passes through a portal) such as
   mvx://world.dreish.org/home+0+0+0
2. Client connects to world.dreish.org and says ENTER
   //world.dreish.org/home+0+0+0
3. Server says, "Send me your avatar and your credentials if you have
   any"
4. Client responds, "I have no credentials, but here's my
   1.8-meter-tall humanoid avatar weighing 60 kg"
5. Server says, "That's fine.  Your vantage point is now object ID
   (cell ID?) xxxx-xxxx-xxxx-xxxx.  Here's a temporary session
   credential"
6. Client says, "May I have a Java server cache?"
7. Server says, "The server code is at
   http://www.distroverse.org/public/server/v1.3/latest/server.class"
8. Client says I already have that server, I'll run it in cache mode,
   giving it my temporary session credential, vantage point object,
   and the server address
9. Cache connects to server and requests updates related to vantage
   point object ID, giving the server the credential
10. Server says, "Yes, the credential is valid, and it corresponds to
    the given object, so I'll do that"
11. Client feeds actions to both servers but reads world information
    only from the cache

Seems workable.

A first-time connector to a ghost world disallowing server downloads
and ignoring credentials:

1. User enters mvx://sculpturemuseum.example.com/
2. Client connecs to sculpturemuseum.example.com and says ENTER
   //sculpturemuseum.example.com/
3. Server says, "Your vantage point is now object ID
   xxxx-xxxx-xxxx-xxxx.  Here is a temporary session credential"
3. Client says, "May I have a Java server cache?"
4. Server says, "No"
5. Client connects to server and requests updates related to vantage
   point object ID, giving the server the credential
6. Etc.

I guess it would be equivalent to saying the server is
http://www.distroverse.com/public/server/passthrough/v1.1/latest/
server.class.
And a "ghost" world is not a protocol feature, it's just an
implementation detail.

So really there's just one feature set so far, and different choices
on whether [or rather how] to use those features.

2007-11-08

The protocol for server-to-client notification of object state changes
is probably the most important part of the whole protocol system.

But I think it can be kept relatively simple, because it's either
always or almost always going to be just between client and cache.
Maybe I should call it a proxy, not a cache -- a world proxy.

So that's it, then.  I'll define a simple protocol for communicating
object updates between the world proxy and the client, and then the
world proxy and the world server can talk to each other with whatever
protocol they want, since the world proxy is arbitrary code downloaded
from a URL given by the world server.

And the protocol will _require_ that the server provide a Java world
proxy for the client to download.  That world proxy can be entrusted
with as much or as little raw information about the world as the
server owner likes.  In the extreme case, it _could_ be a dumb
pass-through channel, with the world server speaking the same simple
low-level object state change protocol as specified in the standard,
though I sure wouldn't recommend that.

So, revisiting my IP Ocean/Archipelago idea, how would that work?

I'm picturing a client configuration item specifying the default class
to use when not connected to an external server.  The default
configuration would be
http://www.distroverse.org/public/server/archipelago/latest/
server.class.

It seems to me a state update can be some combination of:

(object can be a vertex, a face, a particle, or a collection of other
objects; texture can include feel, temperature, taste, animation,
image offset, scaling, and overlay text)

- new vertex <- position, id
- new face   <- vertex[], texture (incl. taste/feel/temp/anim), id
- new particle <- position, radius, texture, id
- new object <- object[]
- object <- position, velocity+duration, acceleration+duration
- object <- vertex:center of orbit
- object <- orientation, rotational velocity, rotational acceleration
- face <- texture
- replace <- object
- delete <- object
- delete all objects
- set background shell (infinite-distance sphere image) <- image
  (plate carree projection)
- set background color (in case background shell is absent or has an
  alpha channel)
- set midground shell (D-distance sphere image) <- distance, image

- play sound
- append sound packet to existing sound stream
- interrupt sound and replace with new sound

x communicate XML textual data (typically text chat including
  programmed object "chat", could conceivably include smells, ambient
  temperature, and sense of gravitation [and menus, such as
  right-click context menus])
  > This is no spec at all.  Instead:
- Position is either in-universe or heads-up in pixels, and all
  heads-up user interface elements are constructed with objects

Additionally, to synchronize some related updates, the protocol
provides:

- stop visual rendering
- resume visual rendering

The client is allowed to resume rendering on its own initiative at any
time; stop rendering is intended to aid the client in smoothly
rendering correlated changes, and is purely voluntary.  Also, "stop
rendering" means don't apply object updates, but the view could still
be moving.

That seems pretty complete.

Yet still simple.

I like it.

The plate carree projection isn't some brilliant insight.  That's how
everyone does it.  The polar distortions I'm thinking of [on Google
Earth, for example] that indicate the use of some other projection are
no doubt in the source data, not Google's decision to use some weird
projection.  Or they're just because the polar data are so low-res.
Come to think of it, the sort of distortion I'm thinking of is exactly
what plate carree would look like near the poles.  It's going to look
bad on zoom-in no matter what, but the key is that background images
wouldn't be zoomed in on, typically.

There needs to be a more feature-rich definition of "object" than the
display-object definition-by-protocol above, if objects are going to
be portable between worlds, which is kinda essential.

I think I already made a start at that, but I could probably revise
it:

...

Actually, I think what I wrote before is right on.  It just doesn't
define anything physical.  Nor does it describe a hierarchical
relationship of objects.

I think that's just because I wasn't finished.  It also needs some
concept of external control -- some channel by which a client could
send commands to an avatar and make it move around and do stuff.

Object (abstract base class):
   signature[] => 0 or more certifications of programmer/creator's
                  identity
   active      => has-update-method-p
   update()    => Java code to change state in some way
   update_frequency => period in seconds
   control( sender, message ) => Java code to do stuff under
                                 ext. control
   id          => Object ID (128-bit hex)
   name        => Object probably-unique-name
   common      => Object common name
   seeing      => can-see-objects-around-it-p
   hearing     => can-hear-sounds-p
   smelling    => can-smell-smells-p

probably-unique-name could just be unique within a collection, for
subobjects.  Otherwise, it is intended to be a name by which the
object can be referred to within a room, for instance, almost always
without ambiguity.  So if someone is selling couches, the vending
object should number each one as it is copied, so that two couches in
a room wouldn't have the same name.

Collection: is an Object, plus:
   subobject[] => Object[]
   mass()      => Sum of masses of constituent objects

Prim: is an Object, plus:
   phase       => { PHANTOM | SOLID }
   mass        => grams
   shape       => Shape

Shape: (abstract base class)

An avatar couldn't be loaded unless it was trusted, because the client
will control it through the message-sending method.

Also, if there's no concept of ownership of a cell, who can delete
prim litter?  Anyone, no one, or only one person?  Or is global
deletion power some sort of ...

I don't know.  Probably ownership is a useful concept for a cell, but
it's not part of the protocol, so it's not locked in.  It's part of
the reference implementation.

So anyway, back to the avatar trust issue.  Since it'll have to have
code that can run, it must be trusted.  And I don't think people would
be thrilled about a distributed universe where they could customize
their avatar and then not go anywhere with it.  But surely they're
going to want to do more than just change parameters.  I mean, there's
no good reason not to allow that.

So code needs to be signed, not objects.  And that makes sense.

I think I'll need to focus on in-world creating and editing tools from
fairly early in the process.  It seems to me that that's a make-or-
break feature.

2007-11-09

I think it was last night that I started worrying about this: What if
the protocol I defined is poorly equipped to transmit a complex mesh
like an avatar?  Or even a sculpted prim?

I really have no idea what might work and what won't when it comes to
3D modeling of human shapes.

I could probably test the feasibility of the protocol by creating some
complex, many-sided shapes and seeing how well it copes.  I could also
try to warp them in some way, like a figure might if it moved or
smiled.

I think if there's one thing I want to get done this weekend, it's
writing a 3D Java app.  And if there are two things, the second would
be laundry.  The third would be writing a very simple "world server"
that feeds objects to the client for display.

The fourth might be ramming as many updates through that connection as
possible to see what it can cope with.

Maybe the first should be laundry.

Now, what was I going to do first with Java?

Oh yeah, simple 3D Java app.

I don't think it particularly matters what 3D library I use, as long
as the layer between the object model of the world and the 3D library
is sufficiently thin and simple.

The java3d demo at java3d.dev.java.net/applets/FourByFour.html is
encouraging.  Movement is very smooth.  It feels like it's creating no
load on the system at all.

And I like the fact that it started up right in the browser.  I had
this crazy idea that it might require some sort of massive download-
and-install process to be done manually.

distroverse.com .org and .net are available.  Too good to be true.

I guess it'll probably be called "Distro" for short.

Now I just need to figure out how to actually build a Java 3D app.
There doesn't seem to be an easy way in.

I finally found a tutorial. ...

2007-11-10

Oops, that tutorial is seven years old.

I know development has been a little slow on Java 3D, but ... come on.

Okay, now I get the difference between Java OpenGL and Java 3D.  Java
OpenGL is a very thin wrapper around the procedural OpenGL API.  Java
3D is object-oriented.  Given that I want to deal with objects, Java
3D seems like the way to go.  It also has spatial sound support, and
support for various virtual reality toys like the CAVE and
head-mounted displays.

I might [make that will] revise the protocol to push some of the sound
processing into the client, rather than having the server calculate
spatial sound and feed raw audio streams to the client.

I'm thinking of driving to the Barnes & Noble in Cumberland to pick up
a copy of the book "Pro Java 6 3D Game Development".

I think I need it.

Interestingly, the glowing review of this book on Amazon.com says that
the best overview of the Java 3D PAI is the "Java 3D API Tutorial" I
rejected for being seven years old.  The reviewer says, "It's old, but
the basics haven't changed.  For the specifics of working with Java 3D
in the modern era, come back to this book."

So, back to that tutorial.

I think the interface should be more keyboard-friendly.  To that end,
I think speech should be turned on with ' for one sentence, terminated
with enter or canceled with escape, or more permanently with ",
continued with enter and canceled with escape.

Question is: Is that a function of the server, or of the client?  It
sure seems like the client to me, but wouldn't that limit what is
possible?

It's another tricky balancing act: How do you prevent each world from
having a foreign interface, yet allow them to have world-specific
actions?  Some games would surely want to have keys set aside for
casting spells or whatnot.

Maybe speech and movement should be the only standard features (or
perhaps a handful of other things), and all unused keys should be
server-defined.

2007-11-11

Okay, I did it.  I pulled in "HelloJava3Da.java" and ran it.  It was
really not anything complicated, it was just a matter of knowing which
of the fifteen billion button combinations to use [in Eclipse].  None
of them are really intuitive, but I can learn how to get by.

2007-11-18

I've decided on the terminology "plane" for what I was calling a
"world", since multiple planes could often be stitched together into a
conceptual world, and the space between planets in a particular
universe could be a plane as well.

I'd like to get some code written today for the Distro client and/or
server.

I'm unsure whether to start at the top, or continue exploring
fundamentals by creating a simple object-passing protocol.  The
protocol is the most fundamental part, isn't it?  So in a sense, I
could do both.  I'm just a little afraid that if I start designing
from the top now, I'll end up having to make major changes, and it'll
end up being a Frankenstein.

I really feel like I want to start by creating objects and some
methods for moving them around in terms of position, velocity,
acceleration, and the same trio for rotation/orbit.

2007-11-21

Distroverse is going to be a long, hard slog, but I think it might be
worth it.

Rotations are going to be somewhat hard.  I don't really "get"
quaternions.  I have a vague idea, but really ... I'm not going to get
them until I play with them.  Java's actually a pretty good language
for doing that, especially with Eclipse, since the edit/run cycle is
so convenient.

I want to provide a convenient way of setting orientation and
rotation, by specifying an axis vector and a rotation around that
axis.  That's easy to understand.

I've been staring at the class org.distroverse.base.PhysicalObject for
what, a week now?  I have no idea how it's going to fit into anything.

I think it would make more sense to start at the top, with a client.

2007-11-22

Nobody has a trademark on Distroverse.

I'm going to call the client "window", as in "Distroverse window".

2007-11-24

In the middle of a Colbert episode where he was plugging Doritos
pretty hard, I realized that that's what was missing from my
late-night hacking sessions.  That's why I haven't been making any
progress on my code: no Doritos.  So I walked over to CVS and bought a
bag.

2007-11-25

Dissatisfactions with Second Life (since I don't go there anymore and
could easily forget):

- Can't create broad vistas (no superlow LOD for distant views)
- Ownership of land is strictly two-dimensional, 3rd dim. fixed
- Can't create truly dense urban landscapes (see above); only facades
- Owner of estate/property can't "change rules" enough
- Can't host land on my own machine (of course)
- Lag (see above)
- Entire universe is just a flat continuous plane; can't get away
- Scripting is very limited and not object-oriented
- Can't mix and match skin parts (heads and bodies)
- No real privacy

I think my idea solves all but the mix-and-match issue in practical
terms, and theoretically solves that one as well.  Or it at least
makes a solution possible.

It's hard to strike that balance between overgeneralizing and
overspecifying.  The former makes a system incomprehensible to almost
everyone, and the latter is a straitjacket.

The genius of the web was that it made things very general in an
obvious way, while providing a simple application that was exciting
enough right out the door.  The generality of it wasn't
incomprehensible; it was just enough to say, "You can do anything with
this."

If Lee had tried to abstract away the idea of data types somehow, or
even (horrors) the idea of a client versus a server (what would that
even mean?) the idea probably would not have gone anywhere.  [I later
learned that he was pushing for some impractical ideas along those
lines, and it was actually Marc Andreessen who pushed the worse-is-
better design that ended up being such a massive success.]

I guess there's an ideal level of abstraction, at which ideas seem
concrete and real, but still flexible.

2007-11-30

That's something I probably need to think about with Distroverse: how
to make it searchable.

Meta tags might be useful, but in the end I suspect it's going to come
down to "spacecrawlers" that connect to servers' default locations and
ask, "What's the name of this space?", possibly "What are the names of
nearby objects?", and certainly, "What portals are nearby?"

So really the main support I would need is a protocol for connecting
and querying basic information about a place without having to create
an avatar and without downloading the appearances of things, though
that might be a nice option as well.  Perhaps places could have not
just names but optional images that could show up in search results.

This would all be defined on the server side, and not in the client
protocol, wouldn't it?  To the Viewer (I'm changing the name from
Window -- that's weak), the name is just a miscellaneous floating bar
with text.

So this would be an additional, optional protocol supported by the
default reference server implementation.  Not part of DVTP.  DVTP is
just concerned with streaming 3D objects -- or more generally,
semi-raw virtual sensory perception -- to a viewer client.

There would be nothing stopping a client from trying to use that
optional protocol, though.  It wouldn't be strictly reserved for
Distrocrawlers.  It just wouldn't be needed initially because ... oh,
actually it would, for bookmarking.

Interesting.

Distrocrawler or spacecrawler?  Distro maybe isn't quite as handy a
short form as web.

There's a text client for Second Life, isn't there?  That might be
hard to do with DVTP, but the meta-information protocol might make it
possible.

That's probably more of a curiosity that I don't need to worry too
much about.  Certainly a client for the blind ought to be possible,
and that's something I _could_ design toward.  At the most basic, it
could speak the distance to the nearest object in a particular
direction (always forward?)  or provide some other audible clues as to
the surroundings.

I think it ought to be possible.  The keys would be passing through
the names of things to the client, allowing the client to retrieve
information about the current location, and making sure the client can
highlight clickable objects (typically including doors).

There's no reason Distoverse couldn't be much much easier for the
blind to navigate than meatspace is.  Especially if text is rendered
by the client -- even 3-D text used as surface textures.  That's
something Second Life doesn't do.  All of SL's text is sprite-like and
limited in where and how it can be used, so people end up putting text
on billboards and the like by incorporating rendered text into their
textures.

The same things might also make it easier for relatively simpleminded
(symbol-processing) narrow AI to flourish in Distroverse.

I haven't made any progress at all in several days.  I'm still at the
stationary cube level, staring at a page about how to create smooth
transitions over a given period.

It's a big leap, to go from creating an object to scheduling movement
and path changes.  What I want to do is create some sort of simple app
to play with quaternions so I can hopefully get some intuition about
how they actually work.

The ideal would be an app with a cube whose orientation is defined by
a quaternion, with "q" and "a" keys raising and lowering the first
component of the quaternion, "w" and "s" doing the same for the
second, and so on.  [The 4-tuple would be displayed on the screen
underneath the cube.]  My guess at this point is that a quaternion is
always normalized, based on what little I've been able to do.  I have
a cube, the orientation of which is defined by a constant quaternion,
and I've been editing the source and rerunning to see where the cube
faces for various quaternions.  It's far less than ideal.

Jon Udell [a Microserf] raises an interesting point about the
configurability of interfaces on his blog today:

    If you observe yourself interacting with a computer, you'll see
    lots of examples of this kind of thing. The composition and
    sequence of buttons or bookmarklets in a toolbar is completely
    arbitrary, but once you've created a layout you start to depend on
    it in ways that you don't even realize until you switch to another
    environment that lacks that customization. Navigational paths
    through applications, or file systems, are trails that could have
    been blazed in a number of ways but, once blazed in a particular
    way, compel you to follow them. And when those trails are
    disrupted, so are you.

    Sometimes I wonder if computer interfaces simply have too many
    degrees of freedom for most people to ever really be comfortable
    with. And if handhelds will become ascendant not only because the
    devices are mobile, but also because the interfaces aren't so
    aggressively metamorphic.

I have to admit some mild discomfort at the idea of pushing the UI out
to the server, but it is Web-like.  The Web browser has a few built-in
widgets, but for the most part it sits at the periphery and just shows
you whatever Web application the server provides.  Customization is
done on the server-side as well.

That's probably the paradigm I should stick to, which is nice, because
it makes my job easier.  I don't have to store any "favorite place for
this button" preferences.

The idea is really to enable arbitrary 3D network applications, not
just to create a flexible virtual reality.  The reference world server
would just be an obvious example, like httpd serving flat files is an
obvious use of HTTP.

I really like the idea that blind people could navigate through a
sound-based interface.  I'm imagining a client spinning around the
room after a teleport, playing a rising and lowering pitch indicating
the distance to the nearest obstruction, with clicks indicating the
cardinal directions.  First, though, a synthesized voice would
announce the name of the place.  Or perhaps these would be
configurable, with both actions bound to keys.

I guess for the very long term, blind people will probably be able to
get vision restoration, but for people in parts of the world where
that's too expensive, and for the nearer term, I like the idea that it
could open up opportunities.

There might even be a period when the blind can see in VR, but not in
reality, though that's probably getting a little carried away.

Ooh!  I was worried about the issue of running loaded objects (which
are the most untrusted programs of all, since they depend on the
unknown trust level of whatever proxy you downloaded from whatever
server you're connected to) at a low enough trust level that they
couldn't do any damage, such as to the filesystem, while allowing the
proxy to cache ...  something.  (Come to think of it, I'm not sure
what the proxy should need to cache on disk.)

It occurs to me that I could just have the client be responsible for
caching things.  The proxy could ask the client, "Would you please
hold on to this key/value pair, expiration time t, and give it back to
me when I request it?"  Cookies!

Potentially large binary cookies, but cookies nonetheless.  That would
give the user control over how much space a site can use in cache
storage.

And _I_ would create two classes of cookies -- local and global -- and
pop up a dialog box asking for permission to store global cookies.

So there would be a multi-store-cookie interface that would do all the
changes as a transaction, asking the user once for all of them, so as
not to annoy with potentially dozens of popup windows.  (My first
thought was to have a button for "Always allow this server to store
global cookies," and then I thought there should also be, "Allow this
server to store global cookies unless doing so would overwrite an
existing cookie," and then I realized that was getting too
complicated.)

I did get over to B&N, and I got my book -- Java in a Nutshell, 5th
Edition.

2007-12-01

I'm glad I got this book.  It really does provide a useful reference
at just the right speed for me.  New concepts get an appropriate brief
introduction, aimed at a person who already understands basic
programming concepts.

It looks like it skips over GUI subjects.

Yes, it does, completely.  Interesting.  Most Java books assume the
reader wants to write graphical apps.

I'll probably go back to B&N tomorrow and buy another O'Reilly book on
GUI programming in Java.  Since I'm writing GUI apps, after all.

It might be a good idea to look into Project Darkstar to make sure my
idea isn't already out there.

I don't think it is.  I think my idea is significantly different.  But
maybe I could pick up some ideas nonetheless.

Depending on what Darkstar is, it might actually be useful as a
backend to my client.  I don't know.

I'm off to B&N to buy two or three more O'Reilly books (I hope).  I
think they should have them -- they had a long, long shelf full of
O'Reilly Java books.

They had the two Swing books, but not the book on Java game
programming, nor the Eclipse pocket guide.  The Darkstar book turns
out to be available only in PDF form.

2007-12-02

I'm trying to write my first app in Java -- a BigClock that will
display the time and date in two different windows, in big enough text
to mostly fill the screen.

I finished the clock around 25 minutes ago, and then spent about 20
minutes sitting on the couch, staring out the window.  It's a great
view.

2007-12-06

Here is an idea I had about level of detail:

LOD  MIN FEAT SIZE  MIN PIXEL SIZE
-12      100 Gm         1 Gm       supergiant stars only
-10        1 Gm        10 Mm       larger stars only (includes sun)
-9   100,000 km     1,000 km       stars only
-8    10,000 km       100 km       giant planets and dwarf stars
-7     1,000 km        10 km       planets, large moons, tiny stars
-6       100 km         1 km       larger asteroids
-5        10 km       100 m        smaller asteroids
-4         1 km        10 m        mountains
-3       100 m          1 m        Great Pyramid of Giza
-2        10 m         10 cm       blue whale, baseball diamond
-1         1 m          1 cm       sprite human figures
 0        10 cm         1 mm       blocky avatars
 1         1 cm       100 um       eyes
 2         1 mm        10 um       3D moles, diamond facets, ants
 3       100 um         1 um       dust mites, coarse hairs
 4        10 um       100 nm       hair, cotton fiber, fog droplet
 5         1 um        10 nm       cells, CPU bitmap
 6       100 nm         1 nm       chromosomes, smoke particles
 7        10 nm       0.1 nm       microprocessor features
 8         1 nm      0.01 nm       carbon nanotubes
 9       0.1 nm         1 pm       larger atoms (sulfur and up)
10        10 pm       0.1 pm       hydrogen atoms
etc.

MFS = 10^(-1-LOD) m
MPS = 10^(-3-LOD) m

Min shapemap/mesh pixel size is between the two, 10^(-2-LOD) m

So if an object was specified only at LOD 1, it would only be visible
at LOD 1 or higher.

[I would expect an avatar would be able to see objects only down to a
LOD one less than the size of its eyes.  I.e., if human eyes are
between 1cm and 10cm (min LOD 1), they can see down to LOD 2.]

I think there probably ought to be separate object R-trees for each
LOD, but this is cumbersome for moving objects, so:

An R-tree for each LOD for stationary objects.

Any time an object moves, it gets yanked out of the stationary R-tree
and put in the moving objects R-tree at whatever its lowest LOD is.

No, scratch that.  EVERY object is only in the R-tree corresponding to
its lowest LOD.  Object transmission order is lowest LOD R-tree first.

So an object is always and only in one R-tree.

After being at rest for a certain amount of time, it goes back into
the stationary R-tree.

[The point of having stationary/moving R-trees is that objects that
move can cross over into someone else's LOD limit, so that's going to
get queried more often.]

One "invisibility" exploit to be aware of is having an avatar with a
very high lowest LOD, perhaps made up of lots of tiny subobjects.
Maybe require that objects/collections with a certain extent need to
have a certain maximum lowest LOD, perhaps 3x the LOD minimum feature
size.

This might not be a worthwhile issue if there are other ways of being
invisible, and if floating nametags are implemented similarly to SL.
(SL has exploits to cover those up, though.)

This weekend, I want to make that quaternion-based rotating cube
thing.  I _think_ I have everything I need to do that.  Then I can
maybe dig into the Killer Game Programming with Java book.

As I was flipping through that book last night, I was getting a little
down because so much of it seems to be devoted to defending Java as a
platform for games, which always reads as a little desperate to me.
Point-by-counterpoint platform advocacy, that is.

But then I reminded myself that Java wasn't really the key to this
whole thing, it's just one important piece that allows some amount
between 0 and 100% of the server processing to be pushed out to the
client to reduce latency.

Planets would probably have to be a special case, though I
came close to thinking they would not.

LOD for rendering could be determined by a distance from a bounding
sphere.  That would work perfectly for planets, however large planar
objects like dance floors would typically be observed from inside
their bounding spheres, so there would need to be a minimum LOD for
objects registering as "zero distance or less".

It would be great if I could represent planets with nothing but
objects.  It would make things like caves much easier.  The hard part
is avoiding obvious transition lines.  There are all kinds of
optimizations that would no longer be possible if the ground were made
up of prims.

The SL hack for this is to use primground only where necessary.

I'll deal with it soon after I get the basics of creating objects
settled, because I want to be able to create worlds.  That's half the
fun of what I want to do with this thing, anyway.  I've had a lot of
different ideas about how it might work, but I won't really know until
I start doing it.

And anyway, this is all secondary to the protocol.  I want to have a
demonstration to show people -- something reasonably interesting --
but Berners-Lee didn't develop Yahoo! or Google.

As I thought I might be able to, I managed to create a rotated
ColorCube, wait two seconds, and then change its rotation.  What I
haven't managed to do, though, is get it to display during those two
seconds.  The window appears, with the cube in its final orientation,
at the end of the program.

Okay, I figured that out.  I was just confused about the overall
program flow -- forgot that it was calling main() because I was
running it as an application.

Anyway, I did this in totally the wrong way, but at least now I know
what to do.

Okay, I can now spin cubes to my heart's content, and I can create
quaternions based on the simple axis/angle method that I prefer.

What I don't like so far is that the window update doesn't appear to
be synchronized to the screen refresh, so there's some chopping
halfway down the image.

2007-12-07

One thought on Distroverse: I'm supposed to not care whether anyone
else uses it, and stick to the philosophy of doing something with it
that I enjoy doing, but ... it occurs to me that what would really
help it take off is if it were _easy_ for people to create their own
worlds and show them off.  No question students would be the natural
early adopters, since they're more likely to have the always-on
bandwidth at close to equal upload/download speeds, although I think
that's tending to equalize -- most people at home have broadband which
has at least pretty decent up speed, and for some reason I think more
students are getting asynchronous speeds in their dorms.  Maybe not.

I guess I just figured colleges would be clamping down on file
sharing, which is facilitated by giving everyone direct Ethernet
access to the campus network.

Another idea:

URLs for the object protocol, too.  So clients connect to dvtp://...,
but servers can connect to dvop:// to load objects from other servers.

Maybe clients could also go to dvop:// -- rendering the resulting
object in whatever context the client wants, but I'd do it slowly
spinning (at a rate determined by the size of the object) with an "add
to inventory" button at the bottom.

Still haven't figured out exactly how the inventory would work, but I
guess it's just an on-disk data structure with a set of objects, and
the display would be some simple abstract plane with the objects laid
out in a grid, or something similar.  Some sort of folder grouping
might be nice.

I want to make it more visual than the SL inventory window.

2007-12-08

So I still think I'll spend most of the weekend on Java and
Distroverse.

I'm vaguely unsettled about the idea of using "long" as the data type
for time values, measured in milliseconds before or after the epoch.
A time data type ought to be abstracted so that as a particular
limitation is approached, the data type can be replaced.  But since
Java doesn't have operator overloading, that becomes impractical.

Unless I were to put my foot down and say, "We _will_ use abstract
data types for realtime and fictional time."  (Fictional time would
not be part of the protocol -- it would be server-side only.)

Veering off that topic, I just thought of a name for the "default
server" implementation: Distroplane.  I'm not really in love with the
name, but I need some kind of name for it, since the question of
whether a particular server uses Distroplane or not would be a subject
of frequent discussion, no doubt.

Coordinate systems on round planets -- that's going to be a bitch.

Maybe the answer will be to make them slightly non-Euclidean, so that
quasi-trapezoiadal ranges of latitude and longitude (Realms) get
mapped into perfect rectangles.  The rectangles themselves would be
Euclidean, but the way they fit together would not.  They would need
to be pretty small (a mile or so?), or the result would be jarring
Realm transitions.

Something different would have to be done around the poles.

How can I do fractal deformation of the surface of a sphere?  I think
I need to take a shower to think this through.

No real ideas there.  Maybe I could play around with Graphing
Calculator [actually now called Grapher] and try to come up with a
surface that, when mapped to a sphere, would smoothly deform it.

I guess the way to do it is

    sin ax   sin ay   sin az
r = ------ + ------ + ------
      2a       2a       2a

With offsets and maybe rotation, so maybe instead of sin ax, it should
be sin AP, sin BP, sin CP, where A, B, and C are transformation
matrices, and P is [x y z], relative to the object center and
orientation (so rotating objects' textures don't change).  So it could
actually be one matrix applied to [x y z], [y z x], and [z x y].

Each LOD would have its own cumulative deformation patterns and
deformation maps.

I'm still not sure how to detect collisions between, for example, a
large flat plane and a small sphere.  I can think of special cases
that work for specific situations, but nothing that is effective and
fast for every situation.

It's important that I get the general representation of objects down
first, so that physics remains modular and replaceable.  I don't want
to build collision-detection code into every object, especially if
it's bad code.

Anyway, that would break the concept of being able to move objects
from server to server.

An object is just shape (including fractal/deformmap), color/image,
flexibility, elasticity, density,

taste, smell, specific heat, flammability ...

Does it even make sense to try to construct a finite list of
properties?

If it's open-ended, like XML, what happens when one person calls it
flammability, and the other one calls it inflammability?

As long as it is possible to add new properties without breaking the
protocol, I probably ought not try to add things like taste and smell
[since I don't even know the right way to specify them -- maybe taste,
but certainly not smell], though everything else on the above list
might be okay.

I guess I need to set up a CVS server on this machine before I can
really get serious about writing code.

2007-12-09

I think I used to do something like a sign-preserving square of
altitude to create low plains and rough highlands.  I'm not sure
whether that's the right way to go, though.  Maybe something more like
multipliers that apply to different levels of detail, but that
themselves have feature sizes at roughly the same scale ...

I need to be able to create a planet and see it with my own eyes
before I can be sure.  So I need to learn how to use GeometryArray.

2007-12-10

My non-Euclidean Realm-stitching idea will (or would) make things
extremely complicated for querying at long distances.  It might
resolve a lock contention issue I was briefly worried about, though:
if every Realm has its own R-tree for objects, there would be less of
a risk of big Planes getting bogged down due to synchronization of the
object R-tree.

So the question is, if you're in a Realm that is stiched together with
a bunch of other Realms such that there were multiple paths to reach
another Realm along a diagonal, where are the objects in that Realm
appear?

This looks unworkable.

Maybe I want something more like Plane > Realm > Cell, with Cells
being defined by a consistent mathematical function.

Still very complicated.

What I wanted to be able to do, and would easily be able to do, if
everything were on a shared coordinate system, is, to display the
surroundings:

- Start at the lowest non-empty LOD in the current Plane
- Calculate the visible radius for that LOD
- Get all objects within that visible radius and display them
- Decrement the current LOD
- Go back to step 4 if the current LOD is less than the highest LOD
  the current avatar is able to see.

I might be biting off way more than I can chew.  It's possible some
degree of generality will have to give, and I might have to come up
with an implementation that is specific to round planets.

Hell, I might even give up on that and go with Euclidean flat planes.
That would certainly be easy.  And it's probably something I want to
do anyway.

It's not that big a deal, though.  What I'm trying to design here is
_*ONE*_ possible server that could run under DVTP and DVOP.  And I
could maintain some ability to plug in different spatial geometries.
Full flexibility to connect spaces in arbitrary ways is a neat idea,
but how useful is it really?

There's a Java implementation of R-trees licensed under the LGPL.
It's about five years old, but maybe that's just because they got it
right the first time.  The C++ version has more recent updates, but
they all appear to be fixing breakage and platform drift.

If I drop the non-Euclidean idea, every Realm local position can be
transformed to a consistent universal position, making it much easier
to stitch realms together into a single view.

But then I would lose something I wanted: the ability to have "private
spaces", the contents of which would only be acessible from the
inside.  That's so that people could have actual private homes on a
public server.

Again, maybe I'm better off making a special case for this rather than
trying to generalize the hell out of it.  There's something to be said
for less computer science and more software engineering.

Or maybe that sort of thing just won't be popular, when people can
create entire worlds all to themselves on their own computer.

And maybe I wouldn't actually lose that at all.  Why couldn't a Realm
just have access controls?

The idea of a "Realm" is starting to sound more and more like a "cell"
in Project Wonderland.  Except that I would for sure want to be able
to have coordinate systems at different angles.

As complicated as all this is, I might very well want to just use
Darkstar for the backend, and maybe even the proxy.

Before I get too heavily invested in this project as it is, maybe I
should scope out some of the existing 3D games that have been written
with Java3D to see whether it can do what I want.

I find it hard to believe it wouldn't be competitive with Second Life
[though I keep saying it's "not meant to compete with any commercial
venture"].  I've always been amazed by the wide gap between graphics
in Second Life and in the latest state-of-the-art first-person games.
Maybe some of that is due to avatar complexity, but then, that speaks
to the need to use my idea of different levels of detail.

At LOD 0, an avatar ought to be reasonably quick to render.  And at
LOD -1 [where they would just be sprites], of course, you could pack a
room with hundreds of them without slowing things down.

Getting back to my original vision, I could require that every plane
be either based on a round planet, a flat planet, or empty space.
That might be simplest to implement.  I really wanted to play around
with planet creation, though -- where planets are just an object like
any other.

It's hard not to get all these wild, ambitious ideas, but really all I
need to do is make something simple and compelling in its openness and
extensibility.  Making planets regular objects isn't likely to draw
more than 1% more people than just getting it up and running.

99% of the draw is likely to be in-world editing.

2007-12-12

Photorealistic virtual reality by 2022, for certain.  Probably a
couple of years earlier, because right now PCs really aren't the state
of the art [I meant to say something about how CPUs aren't as fast as
GPUs], and I think VR is likely to become the killer app of all killer
apps, now and for all time.

It sure would be nice if it's under my protocol, too.  Hope it turns
out as well as I imagine.

Fully immersive VR by 2030, lacking perhaps only the sense of smell.
I think that will be the last one -- I'll say 2035.

So by 2035, it'll be possible to eat meals in VR.  [I was thinking
about that at lunch today.]

Virtual dinner.  I would hope that by that time, nutrition is also
more-or-less automatic.  I'm thinking perhaps the VR client could
automatically suspend and "wake up" the user whenever it's time to eat
real food.

At what point will VR be combined with telepresence?  I'm thinking
that's more like 2045-2050.  So at that point, one would be able to
walk around, appearing in whatever form one chooses, experiencing the
"real world" but with none of the risks of actual physical harm.  Good
god, that will be a different world, won't it?  Shapeshifting and
invulnerability to mugging might sound like fun, but the really
revolutionary thing would be the ability to travel at high speed
without any vehicle, and to pass in and out of the real world.

Okay, I couldn't stop myself.  Here are some implications of my ideas
for concentric LOD circles:

LOD  Radius  Translation
 1     10 m   90% across width of tennis court, can see prim hair
 0     32 m   Batter can see first baseman's arms & legs
-1    100 m   At end of football field, can see sprites at far end
              This is also roughly a city block; can't see people
              at all beyond that
-2    316 m   Three blocks away, only midrise+ buildings are visible
-3      1 km  Skyscrapers visible up to 0.6 miles away
-4    3.2 km  Mountains visible just under two miles away (uh oh!)
-------------------------------------------------------
-5     10 km  No practical effect      (>10 km objects)
-6     32 km  No practical effect     (>100 km objects)
-7    100 km  No practical effect   (>1,000 km objects)
-8    316 km  No practical effect  (>10,000 km objects)
-9   1000 km  No practical effect (>100,000 km objects)

If this is the best I can do, really, it clearly indicates the need to
have special rules for rendering things at longer distances -- at the
very least, the sky, but I was hoping for long landscape views as
well.

However, I think this might actually create much less of a rendering
load than what is typical for any random spot on Second Life.  So
maybe I could go further.  [Especially if the contents of buildings
are not displayed outside of those buildings; if they're in separate
Planes, Realms, Cells, or whatever.]

"Prim hair" is the real lag monster on Second Life.  For client-side
lag, at least.  Physics tends to slow down the servers.

As for broad vistas, come to think of it, the LOD circles would
undoubtedly expand a great deal out on an empty mountainside.  Maybe
even by a factor of ten, which would be pretty close to human eyesight
limits.

The question is: Is there any way to render long-distance scenery
outside the client, and push that out as a background image?  That was
one of my earliest ideas, before I even knew where the client and
server might live.

2007-12-14

Collision detection could be the death of me.

Or of my idea, at least.

One almost-clever idea -- linearly iterating through the R-tree --
doesn't quite work, because branches can overlap, so objects not next
to each other could easily collide even when all consecutive pairs of
objects do not mutually collide.

There are probably some optimizations to be made, though.  For
example, a vehicle would only need to check for collisions as a single
moving object, and the contents of the vehicle would be an opaque cell
[containing "non-moving" objects, if all the people are seated].

An object slowly moving through the air could easily enough determine
that it is not going to collide with any stationary objects in N
seconds, taking it out of the loop for collision checks for that long.

Moving objects could be compared to see if they are moving toward each
other.

That wasn't my idea.  I stole it from a page that crystallizes some of
my thoughts on this so far:

http://www.euclideanspace.com/threed/animation/collisiondetect/index.htm

This might be a great resource, but I continue to have the impression
that this problem is hard, though not impossible.

Maybe the Linux kernel development model will yield an efficient
solution to this sort of thing.

But I can't help feeling that it's going to involve a lot of special
cases.  Bounding spheres are great for objects that are smallish or of
the same magnitude in all dimensions.  Bounding boxes are great for
wide, flat surfaces that don't move.

Bounding rectangles are probably not useful in any case, unless it
were bounding a bounding sphere, as a super-easy step zero.

It's hard to theorize about this stuff until I have some objects
moving around.

And what about constrained objects?  Like a hinged door?  SL doesn't
support anything like that, but it would be cool if I did.

At one point I was thinking of not having a distinction between
physical and nonphysical objects -- making everything obey the same
physical laws, but having a concept of objects being in equilibrium,
which would also put them in the non-moving object R-tree.  Each
object could have an array of refs to other objects exerting a force
on it, and recheck any time one of those objects moves.

One big implication of an approach like that would be that pretty much
anything would be destructible, if there were not an "infinite glue"
object that could be used to put things together.  So clearly people
would want some way to save and restore the state of a particular
area.

That obviously would create an opportunity for griefing: running
around bazookaing the hell out of every visible structure.  So then it
would imply that a world would need to put limits on the kinds of
forces that could be exerted by objects introduced into that world.

Likewise creating a superglue object presents a perfect opportunity to
grief newbies by leaving it on benches or on the ground in a
high-traffic area.

So maybe physicality shouldn't be the default.  I can imagine some fun
area where you can "blow up the castle" [and it'll be nice if physics
is actually fast enough to allow that, but SL is nowhere near being
able to do that], but most people would not want their castles to be
blow-uppable.

Another special case: for elongated objects, a pair [or more] of
bounding spheres might be ideal.

2007-12-17

I was thinking of maybe refactoring my BallFactory so that it
generated a one-dimensional array of Point3d's and an array of ints
effectively slicing it into two dimensions, since this could be passed
directly to TriangleStripArray, but then I realized that, after I've
generated the various circles of points, I still need to stitch them
together into rows of triangles that may or may not be even.

I also was thinking about how this ball of triangles would look, after
reading about tiling pentagons in a Euclidean plane, and realizing
that it might look pretty cool to see something that almost looks like
equilateral triangles tiling a sphere (which is of course impossible
in Euclidean space), and that that might make a neat demo for
Distroverse.  Then I realized that it could also be the program
startup graphic -- a tumbling sphere of triangles rolling toward the
viewer, perhaps showing a tiny rendered city on the surface just as it
rolled by the camera in slow-mo for effect.

I also realized I misstated some info on the LOD chart I drew up
earlier.  Here's a revised version:

LOD  Radius  Translation
 1     10 m   90% across width of tennis court, can see prim hair
 0     32 m   Batter can see first baseman's arms & legs
-1    100 m   At end of football field, can see spritars at far end
              This is also roughly a city block; can't see people
              at all beyond that
-2    316 m   Three blocks away, only midrise+ buildings are visible
-3      1 km  Skyscrapers visible up to half a mile away
-4    3.2 km  330' hills and larger visible within two miles
              Flat city sprites 0.5+ miles wide also visible
-5     10 km  3300'+ mountains visible within 6 miles
-6     32 km  Olympus Mons cliffs visible from 20 miles away
-7    100 km  No practical effect   (>1,000 km objects)
-8    316 km  No practical effect  (>10,000 km objects)
-9   1000 km  No practical effect (>100,000 km objects)

This actually looks good -- the shape of the landscape would be
visible at quite a good distance.  [And up in the air, of course, the
limits would likely rise.]

Of course, it's entirely up to the server, by way of the proxy, to
decide what to send the client and when.  It doesn't need to respect
any externally-imposed LOD limits.  But neither does the client have
to display everything the server gives it.

2007-12-21

I have to admit I still have no idea how I'm going to handle
collisions, which is a huge part of a realistic VR environment.

I'm trying to define the Shape class right now, but behind VPN, I
can't see any of the Java3D documentation, so I'm a little fuzzy on
the class hierarchy I want to go with.

I had been thinking I would just wrap up Shape3D with some additional
information on texture (as I use the term, not as Second Life uses it)
and image map (which is what SL calls "texture"), but then I realized
that no one has ever promised me the Shape3D class (or more
importantly, its serialization) wouldn't ever change, so I can hardly
define a protocol based on that.

But I can define a Shape in terms of the data needed to construct a
Shape3D.

So then my question is: Do I make Shape an abstract class and have the
TriangleStripArray data as one implementation of that abstraction?
Are there other primitive shapes like spheres and cylinders where I
wouldn't need to specify every triangle?

There is a sphere primitive in Java3D, but it is made of triangles, so
I might as well do it myself.

I think I clearly need to separate the concept of "shape" from "form",
which ought to include other aspects related to the physical
appearance and feel of an object.

Oh, wait.  Nevermind.  There's a reason I wanted to tie the two
together: because the imagemap (and probably the texture) will apply
to individual triangles.

That's another thing I'm fuzzy about, to say the least: how to map
images onto all those little triangles.  That's up to the proxy, of
course, but it's something I want to do.  I guess for convenience,
I'll probably provide some obvious primitives with image mapping
similar to what SL does -- rectangular and circular prisms, spheres,
and maybe donuts.  I guess I'll have to do donuts.

The reason I was thinking I should separate shape from texture/image
is that I imagined sending a series of shapes and then sending
commands to iterate a particular object through those shapes in order
to have an undulating or vibrating object.

Another thing I'm less than clear on is how exactly to do the sky,
though I think I have a pretty good idea on that one.

Generating TriangleStripArrays is harder than I thought.  It would be
easy but for one thing: having to preallocate the flat array of
points.

Actually the next step is a little tricky too, but I've been thinking
about it for long enough that I'm pretty sure I know how to do it.

In fact, the best I can do without examining the points themselves is
to set a reasonable upper bound, leaving myself with, I would guess,
an average of around 0.8 extra points per row.

That's probably acceptable.

2007-12-22

I'm vacillating in my opinions on Java.  I'm seeing more and more
things that probably could be done with it that are nice, general
examples of fundamental computer-science algorithms, like foldl.  For
some reason, there doesn't appear to be any such method built in to
Java, but I think I could write one, and rewrite my min() and max()
functions in terms of it.  [I was dissatisfied that they were so
similar, after I had succeeded in writing them as type-generic
functions.]

I _don't_ think I can make a satisfying numericCast() method.  That
appears to be something that shows C++'s strength.

I did find out today that Java schedules threads preemptively, across
all available CPUs.  That's what I wanted.

2007-12-23

Oh well.  I thought I had a way to make reflection a little less
verbose in Java, but it would require writing a function for every
possible number of arguments.  I think I'll just have to accept that
verbosity is a fact of life in Java.  The only things that are quick
and easy are the first-grade cut-and-paste-style answers.

At least I now understand what the Y Combinator is.

I really have been learning a lot recently.

I'm still optimistic about foldl.

Actually, I'm going to do something more like foldr, working from left
to right.

[On an airplane:]

We're slowing down.  I can't tell whether it's time to stow the Mac.
I'm having a little trouble making a foldr function: Eclipse complains
about my every attempt at creating a simple class to wrap an anonymous
method.  I'm sure there's a way to do it, but it could be something
really annoying.

2007-12-24

There's a new issues I need to figure out: What kind of data structure
can I use to get nanometer precision halfway across the universe?  A
double-precision float is not going to do it.  Its precision is only 2
parts per quadrillion.  So if an entire universe were on a single
cartesian coordinate system, the far galaxies would have placement
precision of only about 0.21 au, or 31.5 million km.  That would be
one rough orbit, though no one would see it because they would all be
trapped at the center of the planet -- and anyway, the planet would be
just an infinitesimal point.  (Or bigger than the Sun.)

So obviously there will need to be some system of cells, which I'd
already planned on, but on top of that, there will need to be a way of
getting those coordinates to the client.  I don't think it works to
just have the viewer be at the center of the universe, because then
coordinates of all the stationary objects would have to be
recalculated every instant that the avatar moves around.

I guess every cell will have two transformations associated with it,
or really just one, since the other would just be the inverse.  Viewed
from the outside, all objects inside the cell (if it is not opaque)
would need to have their in-cell coordinates transformed to the
coordinates of the containing cell.

I can understand the complaints about Java: once exposed to a more
powerful language, it's hard not to think in terms of generic
programming, and in Java so many things just can't be reduced beyond
cut-and-paste.

2007-12-25

I'm resigned to going ahead with DVTP as I've designed it.  I'm hoping
that whatever issues the JVM has that are preventing good programming
languages from targeting it, or making it hard for them, will be
addressed.  Maybe I'm getting a little carried away in thinking that
my project might actual focus appreciably more attention on Java,
spurring any kind of improvements, let alone implementation of entire
other languages targeting the JVM.

I guess I'm interested in Rhino.  That's partly because of the blog
post I read recently, "Size is the enemy" or something like that,
which was (ironically) a very long-winded complaint about how verbose
everything written in Java needs to be, claiming that the answer was
to rewrite it in JavaScript targeting the JVM, also known as Rhino.

I looked at it, and it does appear to be a much nicer language.

It's not clear to me what the status of the project is, or even what
the object-oriented features of Rhino are, other than that I'm pretty
sure it has them.  It's clearly more dynamically typed, though.
That's what I like about it.  None of this namby-pamby neither-static-
nor-dynamic no-man's-land that Java occupies.

Actually, I guess it's pretty static.  It just doesn't have the
features that C++ has that make static typed programming tolerable.

I'm not going to try to reimplement min() and max() in terms of a
foldr function.  That's just not what Java is about.  It's enough that
I can parameterize the type of the parameters to min() and max(), and
the rest is just going to have to be cut-and-paste.

I just don't understand how they could have made a language without
functions-as-objects, without anonymous functions, and without a
preprocessor.  It seems so cruel.

Okay, I spoke too soon.  I just figured out the little syntactic twist
I needed: the methods of a Class object are only those methods that
are defined in class Class.  What I wanted was not a Class object, but
the class itself.

I've extracted what I think are all the Distroverse-related thoughts
and put them in a single file.  Now I'll load it into SVN.

I'm actually surprised at how little there is from before October:
just two short entries, one in February and one in May.  I thought I
had a lot of ideas kicking around before that, but I guess I didn't
write enough of them down.

I did have a lot of really vague ideas about something that looked a
lot like Second Life in architecture, but had more features.  I guess
it didn't seem worth writing about because I was missing the thing
that would make it practical: Web-style distribution.

2007-12-26

I'm still not sure how I'm going to design the protocol objects.  I'm
torn between tying my implementation to the existing types Point3d,
Vector3d, etc., which might theoretically expose me to the risk of
interface change, or making my own point objects, which might cause
unacceptable performance degradation.

2007-12-27

My books should arrive today: The Reasoned Schemer, and Code Complete.

I was actually toying with the idea of adding a Scheme interpreter to
the Distroverse client as an alternative to using a JVM binary.  It
wouldn't be too hard to do, would it?

Supposedly a Scheme interpreter can be implemented in a weekend (or
something like that), and I've already done something similar with the
Aptitude Macro Processor, my first programming job, haven't I?

It's something that could be done later, though, after I get everything
else figured out.

I _think_ I could even implement a Scheme interpreter in C and have it
handle a Scheme proxy without having to abandon the Java client.  There
are extremely few points of contact between proxy and client.

Oh, wow, there's already one out there in Java called SISC.  It looks
like it has what I would want.

If I would need to do anything to it, it would just be to make sure it
has the same sandbox restrictions I would apply to a Java cache.  [That
should say "proxy", not "cache".]

So the spec could easily say, "the proxy shall consist of Java bytecode
or Scheme source code."

Which could be gzipped, of course, to mash down all those parentheses.

There's also a SISC-Lite, so I wouldn't have to include a whole megabyte
of Scheme interpreter with the client.

Based on the example at

http://en.wikipedia.org/wiki/Image:Normal_map_example.png

it appears that a reasonably small number of triangles and a bump map
are sufficient to create a highly detailed 3D shape.

Neato.

http://www.ddj.com/java/184406320

lays out the basics of functional programming in Java.  I need to
redesign my Util.foldL(list, max) method based on that article.

Because I can't stick with what I have now: it includes a default
implementation of call(), which means I could forget to implement it and
the error would not even be caught at runtime.  And I can't figure out
how to make it an interface without breaking the anonymous class
instantiation syntax.  (The error I'm getting on that makes no sense,
though.)

2007-12-28

I'm unsure of whether Distroverse, if successful, would really spur
development of alternative compilers targeting the JVM.  On the one
hand, I think it can't have any impact even if it's huge, because
there's obviously already so much being done with Java today.

On the other hand, hardly anything is being done with Java because it
_must_ be done with Java -- I'm seeing a reoccuring theme of people
implementing X-to-JVM compilers for their Master's or Doctoral theses
(or investigating the issue), and then leaving the project hanging.  I
don't really see a lot of ongoing interest in any particular project.

And that would be different, because I'm really proposing to say, "NO
downloadable code is allowed unless it is JVM bytecode (or Scheme source
code)."

Not even Web browsers impose such a requirement, and in fact Flash is
much more popular today than Java as an embedded application platform.

But, I must have portable bytecode [and an open standard based on free
software], so I must have Java.

I need to have some way to serialize my Points so that they can be
deserialized into Point3ds.

I did fix the foldL/max thing.  It was just a matter of moving the
parameterization from the method to the class, and specifying that
parameter when instantiating the interface.

I need a way to serialize and deserialize things that contain Point3ds
in such a way that DVOP and DVTP are not at all dependent on the actual
serialization formats of Point3ds, because I'm pretty sure I want to use
actual Point3d objects throughout my code.

But that ought not be too hard to do.  So the classes that define DVOP
and DVTP (or for now, just DVTP -- DVOP is not part of phase 1, it's
just some ideas I have at this point) will contain Point3d as a
convenience for the Java client, proxy, and server, but the actual
protocol will be defined by the serialization formats, which I can
control by overriding writeObject and readObject.

2007-12-29

I think I should only need to do this once, shouldn't I?  I can just
define a PointArray object and override its serialization, right?  Or
maybe even better provide a utility function for serializing any
iterable container of Point3ds.

And then I could use PointArrays in other objects and not have to
override their serialization.

After I've done all this, I'll need to do some test serializations and
confirm that the formats are what I expect them to be.

2007-12-30

Oh!  I don't need to rely on having the proxy push a high-speed stream
of shapes at the client; I can have the same sort of velocity,
acceleration, and maybe even orbits apply to vertices as apply to whole
objects.  The way to do that would be to send a shape-like set of
vectors, laid out in the same TriangleStripArray.  Then the client can
recompute the shape at every timestep.  [Obviously the morph TSA would
need to have the same number of points in each row as the Shape.]

The duration would apply to the entire TriangleStripArray, not to each
vector.

I'm not sure how this might affect the other idea I've been thinking
about lately: how to do smooth shapes.  Splines?  Can any computer
compute splines quickly enough?  Or is it just a matter of telling the
client, "Render this shape smoothly", so it would just shade it
gradually (and provide tactile feedback without edges, when that becomes
possible)?

That might work.  I don't know whether clients will be able to support
that feature.  I'm sure the reference client won't ever support it as
long as I'm the only one coding it.  But it seems like it ought to be
theoretically possible.

I can't help but think this is probably a crap idea and no one will ever
think it's at all interesting, but I'm still having fun, so I'm going to
keep going with it as long as that remains the case.

I really want to be able to create some objects and walk around them.
Even if my avatar is just a stack of cubes or something like that.

2007-12-31

As one last little bit of complication on dynamics, I think I'd also
like to enable elliptical orbits, including the degenerate case of
sinusoidal back-and-forth motion.  That should be useful for a lot of
kinds of animation.

Or maybe I should just allow sinusoidal acceleration and rotation
specified separately for any axis -- or maybe even ...

I'm not sure whether I'm getting carried away here.  After all, the goal
_was_ to try to keep the client as lightweight as possible.

I think I'd like to have port 808 for DVTP, or maybe 1003.  But I'll
keep thinking about that.  It doesn't need a reserved port for testing.
I can make my own machine listen on whatever port I want, and specify
the port as part of the URL, like dvtp://10.0.1.9:808/.

If it really takes off, maybe it could even get 81, or something below
80.  I wonder how many of those are in wide use, though.

Double buffering doesn't seem to do anything.  I'll try it again when I
have a real client, I guess, and not just a single spinning cube app.

2008-01-01

Wow,

http://www.alchemists.com/vr-index.html

has renewed my confidence in the decision to go with Java3D.

I think I'm ready to make a skeleton client and server and at least see
if I can put up some balls.

It might be most useful at this point to render them in wireframe.

I'm (eventually) adding Scheme as an option for the downloadable proxy
for all the people who are no damn fun at all:

09:14 <nothingHappens> deadly, when i write a defmacro, anything less
        than the best is a hack yo
09:17 <spiaggia> good afternoon
09:17 <nothingHappens> afternoon?  where?
09:17 <spiaggia> here
09:17 <nothingHappens> heh, it's 8:15 AM where I am
09:18 <jsnell> amazing!
09:18 <spiaggia> yeah well, that's how it goes on this planet.
09:18 <fe[nl]ix> ciao spiaggia
09:18 <nothingHappens> spiaggia, so i've heard
09:19 <nothingHappens> us simple midwestern folk don't travel much.
        yall, dowhut,. etc
09:20 <spiaggia> nothingHappens: so i've heard
09:20 <nothingHappens> lowell.
09:20 <Krystof> in case the sarcasm is too subtle for you simple
        midwestern folk: we are utterly uninterested
09:20 <spiaggia> thank you Krystof for that clarification :)
09:21 <nothingHappens> that's good.  you're perfectly welcome to ignore
        it, or go back to the not-talking-about-anything you were so
        busy with before.
09:22 <Xach> nothingHappens: Begone.
09:22 <spiaggia> Krystof: you have until wednesday to suggest a
        programming project for the 1st year masters students.  I
        suggested the same as last year: stamp (because it didn't
        advance very much) and a structure editor for CL.
09:22 <spiaggia> (the structure editor wasn't chosen last year)
09:23 <nothingHappens> Xach, gladly.  you guys are no damn fun at all.
09:23 <Krystof> how about a MIDI sequencer application?
09:23 *** nothingHappens [n=chuck@office.t8design.com] has left #lisp
        ["Leaving"]

I'm about to give up for the night, but I was just at the very beginning
of making a client when I got stuck on the basic form of integrating
Swing and Java3D.  I tried to download the source code for my "Killer
Game Programming" book, but the web site for it, hosted in Thailand (!),
went down.  It came back up while I was downstairs watching TV, but I
was engrossed in something.

Finally I came back upstairs and decided it was too late to do any more
coding, so I tried to do a big svn diff and checkin.  I finally got
irritated enough by the fact that the checkin window in Eclipse is
modal to do something about it, so now I'm trying to get a command-line
SVN client.  I didn't get a recent enough version of SVN through Fink to
understand the Eclipse SVN working copy, so I tried updating Fink,
stupidly thinking that it was too old to realize I'd upgraded to
Leopard.  (I haven't upgraded this machine yet.)

So now I'm waiting for Fink to finish upgrading itself.  It's compiling.

Then I'll install the latest SVN from sources, though I don't know how
to do that yet with Fink.

I get around 1800 spams a day, or at least I did in December.  And yet I
only have to spot-check around 2 or 3 a day.

Oh, crap.  It has to build something like 30 packages.

2008-01-02

Tutorial:

> Inventory
  > This is the only space that is completely private; no one else can
    ever enter it or view the objects in it, unless the general security
    of your computer is breached, physically or electronically
  > In other words, someone who could view your inventory would have to
    also already have access to any emails or other files on your
    computer
  > Unless you have a deep understanding of how the programming works,
    you should probably assume that any other space, no matter how
    obscure or well-guarded, might possibly be seen by someone else, so
    for example, don't leave a piece of paper with your social security
    number, credit card numbers, or passwords lying around, even in a
    private but non-inventory space

- Maybe have an inventory-like 3D view of cookies?  Present the cookies
  as actual cookie shapes, sized according to their filesize?
  - And in glass cookie jars, one per site?
  - Size according to storage space used, not content size
  > If a 100-byte cookie is 1 cm in diameter, a 1-foot in diameter
    spheroid cookie would be 2.8 Mb, and 1 inch would be 1.6k
  - Door to the cookie room in inventory?

2008-01-03

- Traditional senses:
  - Sight
  - Hearing
  - Smell
  - Touch
    - Pressure
    - Friction
    - Pain
    - Heat
    - Cold
    - Itching
  - Taste
  - Core temperature
  - Acceleration
- New senses for the real world in the 21st century:
  - Radio
    - AM
    - FM
    - Wi-fi (field strength, possibly direction)
    - GPS (location)
  - Additional sight
    - Infrared (fuzzy but useful)
    - Ultraviolet (sharp but not as useful)
    - X-Ray (sharp but even less useful)
  - Magnetic field
  - Instant messaging
  - WWW
- New senses for Distroverse:
  - The sky's the limit

VRML.

The problem with VRML is that it lists objects, and layers behavior on
top of those objects.

My architecture is to give the code primacy, and make shapes and other
physical elements just data communicated from the program to the user.

In-world editing in any VRML-based system would have to be an ugly kluge
involving extra layers above VRML interfacing with features within it.
In Distroverse, it's a relatively simple matter with a clean conceptual
design.  (The hard parts are just the unavoidable issues involved in
persistent object storage.)

A decent answer to the question, "Why invest any time in Distroverse?"
can be found at

http://www.lucidity.com/LucidDreamingFAQ2.html#whyLD
   =~ s/lucid dreaming/distroverse/

(Most of section 2.)

I've been sketching out balls as they would be generated by my
BallFactory, trying to figure out their properties, and whether there is
any obvious way to improve them.  They look pretty cool on paper, but I
really want to see them on the screen.

2008-01-04

If I start getting patches emailed to me, I might have to set up
autoresponders such that I can drop emails into a folder and have it
send a form letter in response to politely reject patches for:

- Not using the whitespace style that I've established (acknowledging
that it isn't the Java "standard" style)
- Not including documentation (saying that I already have enough
undocumented code that I must work through, and cannot add more)
- Being incomprehensible
- Not being a unified-diff patch

Something like,

"Thank you very much for the contribution, but unfortunately at this
time I cannot accept patches that [x]. ...

"I hope you will consider [xing] and resubmitting the patch so that I
will be able to evaluate it for inclusion in my next release.  Thank
you."

I don't think I would exclude code that was comprehensible but contained
poorly spelled comments, or obvious grammatic errors.  I would reject
new classes where the name of the class or of the methods included
misspellings.  I would probably also accept patches that fix
documentation errors -- especially spelling and grammar.

I think I've read that Linus doesn't accept patches that just add
documentation to existing code.  I'm not sure why that is, but maybe the
person who claimed that that was the case tried to add some really
asinine comments intermixed with code (like "/* Increment variable by
1. */"), rather than interface documentation; got rejected, and then ran
around saying, "Linus rejects comment-adding patches!"

I wonder whether I would need to set up a Bayesian classifier to handle
it for me.  Since I would want to sort into N buckets, for some flexible
value of N, I don't think my current system would be very good, unless I
were to run it several times with several different databases and take
the result with the highest score.  I guess that would be okay.  Just
horribly inefficient.

I know SpamBrain would be really good at picking out patches that don't
conform to my whitespace style.

It's the sort of problem I find hard to resist; I want to solve it
prematurely, but at this point, it's an absurd waste of time.

And there's no need to solve it _before_ it becomes a problem.  The
exact moment at which I stare at an inbox that I don't want to sift
through is the moment when I can deal with the problem.  And then I'll
use the solution to work through the pile of unread email.

But the first step would have to be adding a special email address just
for Distroverse.

So once I have something substantial enough to start telling people
about, I can grab the distroverse.* domains and advertise
dreish@distroverse.org as my address, or dan@distroverse.org.

I would probably want to set up an autoresponder to say "good code, I'll
add that, thanks," for the occasional piece of really elegant code that
I just immediately know I need to put in.

For the rare piece of exceptionally good code, I would write the
response myself, I guess.

So would the autoresponder ever be trained to recognize good code?  Is
such a thing even possible?

Or just good coders?

Another tricky problem: I would probably want to include a note that the
email has been automatically generated by an automated patch evaluator,
for those cases (score > 0.995, all others < 0.005?) where I would have
it reply automatically and immediately, without intervention.  If I were
to do that, I would probably want to include some means of replying to
the message to request human intervention, for misclassified cases.  So
how could I do that without creating an easy way for spammers and
nutjobs to bug me?

Maybe I could include my real email address, and rely on my regular spam
filter to catch the crazies.

I still want to try to get a basic client running this weekend.  I
don't see any reason not to do it.

2007-01-05

The protocol makes it easy to log an event: just capture the DVTP stream
sent to the client, and timestamp each object.  To play it back, just
send the same stream to a client at the same rate.  Simple as pie!

I thought of that while I was thinking about the possibility of
capturing some historic first moments.

2007-01-06

I made a start at writing the simple server last night, and ran into
all kinds of unanticipated design issues, so I don't think it's likely
I'll have this done today -- neither the client nor the server, and
certainly not both.

But I want to make as much progress as I can, and get as many aspects
of the design settled as I can.

I found a sample web server in Java, but it's a rat's nest of anti-
patterns and indecipherable indentation.  I'm not sure I even want to
keep reading it, because I'm afraid it might fill any gaps in my Java
knowledge with crap.

Wow, this is some of the worst code I've seen in years.  And it's on
java.sun.com.  I'm certain I don't want to borrow any ideas from that
cesspool.

To be fair, it's ten years old, and I'm sure the author has improved a
great deal since then.

2008-01-09

I've been looking at a lot of languages lately.  Mostly I've been
concentrating on their designs and their completeness.  Today, I also
looked at benchmarks.

Java holds its own against pretty much everything else in terms of
performance.

The next most interesting language targeting the JVM, in my opinion, is
Scala.  Rhino, as I thought it might, performs like a typical scripting
language, such as Perl or Ruby or Python.

I also found a web page that advances the argument that Python is like
Lisp without the parentheses.  There are a few major differences, but I
guess I can see the resemblance.  And I would have to admit that Perl
does not bear that same resemblance to Lisp, even though there are a few
advanced techniques one can use in Perl, and it does usually perform
better than the other major scripting languages.

Common Lisp's benchmark results were also impressive.

I need to learn more about Scala, but it looks like it could be just the
solution I'm looking for: a reasonably fast language that could sit on
top of libraries developed in Java (for speed), to make the task of
programming a complex site easier.

It is still statically typed, though, so I will keep looking.  I might
end up deciding Scheme (through SISC) is an even better choice, but
unfortunately I didn't see any SISC benchmarks on this "programming
language shootout" site I was looking at.

2008-01-10

In some cases Rhino is far slower than Perl.

For some applications, that might be just fine, and certain Distroversey
things might be included in "some applications".  But probably not
anything foundational that I would want to build, considering that any
of the languages I'm looking at could easily call Java code anyway.

CAL is a lazy functional language compiling to JVM bytecode.  Its
performance is comparable to regular Java, which is to say very good.
It appears to be even more verbose than Java, but at least it's there.

I think all the bases are pretty much covered.  It might be nice if
there were a Scheme and/or Lisp compiler-to-JVM, but that's why I want
to allow Scheme as an alternative to JVM bytecode.

For any site that wants to do something that might be annoying, like
resize the viewer window, pop up a window like this:

dv.example.com wants to resize your Viewer window.  Do you want to allow
this?

OK  Cancel  Leave

Leave would exit the offending site altogether, which would be useful if
it was asking a string of questions in a short period.  Possibly I would
only present that as a third option if the site _did_ in fact begin
flooding the user with annoying requests.

I want to do this because I _hate_ web sites that resize my browser
window (and in Safari there's no way to stop that without disabling all
JavaScript), but some sites might reasonably want to do that if they're
going to present a 3D "movie" where the frame should be exactly what
they have measured out, so I want to allow the user to say "OK".  But
doing so opens up another avenue for abuse: flooding the user with those
requests, thus making it impossible to get out without force-quitting
the application.

So I guess this would cover:

- Resizing or otherwise molesting the window
- ...

I can't think of any other thing that I would _ever_ want to allow.  The
settings in Firefox are all things I just don't think are particularly
useful.

Maybe they're for running the browser in a "kiosk" mode, but who ordered
that?  I'd think that would call for something more like a special kiosk
version of the Viewer.

2008-01-13

I just found my way over to something called Metaplace (via
Kurzweialai.net).  They seem to have a lot of the same ideas I've had
over the past year, but they've arrived at a conclusion that I think
does not work: That this is a way to make money.  I think it needs to be
first an open standard before there's a corporation behind it.

Or something like that.  It's late and I'm incoherent.

I don't really understand what their architecture is, but it's clearly
not the same as what I've come up with.  It looks like they're focused
on making multiplayer games.  I think that's a pretty narrow thing to be
designed around.

And I only see 2-D games.  What's up with that?  They're talking about
"virtual worlds" and all they have is sliding-piece 2-D puzzle games.
Not that I don't like those, of course.

Ooh, Metabucks.  So this is bullshit.  Alpha testing signup CLOSED.

Lame.

I really want to get the server written this weekend.

Okay, now I see what Metaplace is.  It's basically just a library and
some services, sitting on top of Flash.  And they're waiting for Flash
to add 3-D stuff.

I guess that's not the dumbest thing I've ever heard of.

2008-01-15

I think I need to stop by Barnes and Noble this evening and get a book
on how to write networked applications in Java.  Even though the network
architecture of my app is pretty simple, I have to admit I'm stumped --
I have no idea what to do with a ByteBuffer.  I think if I were to
guess, I would cobble together something atrocious and ignorant.

2008-01-17

I think I'm going to follow a variation on the Martini Method from now
on on the Distroverse project.  I think it will help me keep my momentum
when I encounter the tough spots (like the one I'm in right now --
trying to get a basic server framework coded).

Every day when I get home, all timewasting or recreational activities
are off limits until I produce N lines of svn diff, where N is a
function of what day it is -- more on weekends, less on full-work
weekdays, and somewhere in between on early close days.

I need to figure out what that N is.

I think that should even apply to tonight's show, so I need to pick an N
for today, and produce at least that much change before I go to
Blake's.  (It ought to be a number I can hit in a couple of hours on a
weeknight anyway, or else I'll never stick to it.)

I'd say r62:63 looks like a good weekend day's work, and maybe r50:51
could be a weekday amount of work (though it was one of several things I
did on a Sunday).  Let's see how big those diffs are (including writing
in IDEAS or TODO!) ...

r62:63 - 231 lines
r50:51 - 56 lines

That looks solid to me.  I'm going to round them off to 250 and 50, and
75 for an early close.

So tonight, before I can go to Blake's, I need to sync with SVN and then
write (or change) enough code to get the SVN diff up to 50 lines.

If that proves too difficult, I reserve the right to revise those
numbers.  The total amount of *.java lines at this point (including
comments and boilerplate, and not including IDEAS and TODO, for all of
which I also get credit) is only 855.

I totally haxored that productivity measure by renaming
DvtpThreadedListener to DvtpMultiplexedListener, since the example I'm
going to pattern my code after (after a false start at a threaded server
using Java in a Nutshell as a guide) is a single multiplexed thread, in
Chapter 12 of the O'Reilly book Java Network Programming, 3rd Edition.

So I'm free and clear for the night.  I will _not_ however, engage in
any dishonest refactoring just to fulfill my self-imposed productivity
requirements.

2008-01-18

I guess the requirement should be 75 lines for any work day preceding a
non-work day, whether it's an early close or not.

The client MUST have a master volume control and mute button somewhere
prominent.  I'm pretty sure people will love me for that.  Probably also
a mute keystroke (non-overridable).

The good news is I found a motherlode of example servers in the Java
Network Programming book.  The bad news is they're not well-structured.
But I should be able to get enough of an idea of how to do things ...

I'm tempted to start over from the top, but I really just need to get
_a_ server working so I can move on.  Replacing the clumsy first server
with something more efficient would be a simple matter of programming.

2008-01-20

I had a couple of fairly important thoughts about Distroverse before I
got up -- that's what propelled me out of bed.  One was an idea to use
a simple interpreted bytecode for scripting objects, and the other was
a bug fix to the command parser I'd written yesterday.

Using a bytecode (other than JVM bytecode) would mean the language
could be interpreted on any platform; not just Java.  So objects would
(or could) be portable between worlds regardless of what language the
server is implemented in.

Naturally, I'd want it to be reasonably easy to translate the DVSL
bytecode (Distroverse Scripting Language) into JVM bytecode.

I really don't like this network code.  It's getting to be fairly full
of repetitious boilerplate, and it doesn't even work properly -- I have
no idea what it would do with a GET request that was longer than 1024
bytes.  I think it would just see it as two separate requests and flag
the second one as unrecognized.

And it's not truly multiplexing, for the output at least.  I don't have
any way of continuing to serve other clients while waiting for one
client to finish receiving a block of data.

But, work is work.  I have to think that if there's one thing other Java
programmers would know how to do, it's basic network programming.

2008-01-21

Somehow, I need to design a server that is efficient and smooth with
only one thread, but can run in more than one thread.  I have no idea
how to do that.  But in a way, that's the sort of exciting problem I'm
looking for.  [Exciting to me because it's different from anything I've
done.]

Maybe I could take a lesson from the HTTP model: a stateless interface
to applications that are either embedded in the request handler or run
separately to update state that is viewed by the interface.

I'm sure I'll consider that, but ultimately I need to start from
scratch.  Of course, once I've figured out the design, and figured out
what the implications of that design are for the control flow of the
overall server program, I'll need to figure out the minimal
implementation I can get coded by myself that will be evolvable into
that ultimate design.

2008-01-22

This has been bothering me at least since last night, and probably
longer: What should happen if the proxy starts pushing data at the
client faster than the client can render it?

Actually, I think the solution is to push back: tell the proxy the pipe
is full and the last thing sent has been dropped.  If it was a
short-lived update, it might not even get resent; there might be another
update in a few milliseconds that invalidates what was dropped.  If it
is some fundamental piece of the environment, it will need to be tried
again later.

So the proxy could maintain some state bit on everything, "Does the
client have the latest version of this?"

I guess ... does this just dump the problem onto the proxy?  Should
there be blocking and non-blocking writes to the client?  If it is
always non-blocking, what is the proxy going to do to find out when the
client is again ready to receive things?  And if it is always blocking,
doesn't that mean the proxy might be prevented from doing some sort of
computations that it could be taking care of?

Is this going to require some sort of select-like mechanism?

I've also been struggling with issues of parallelism with regard to the
scripting language, or scripting bytecode.  If multiple threads could be
sending messages to the same object -- messages that might alter that
object's state -- how can they be prevented from ruining everything?

If object locking were done gratuitously (and automatically), it would
be far too easy to deadlock.

If it were done manually,

A functional paradigm is not acceptable.  Objects must be mutable; it's
no good to say, "create a new and different object" in lieu of, say,
changing texture of an existing object, as a means of animating things.

The Java way of doing it is to allow methods to be declared
"synchronized", but I don't even fully understand the implications of
that, and I don't really want my bytecode to be a thin translation layer
to JVM bytecode.

I thought of something somewhat complicated on the way to lunch.  A
method could compile a complete list of all the objects it will "touch"
during its execution, and before it could be invoked, it could be
required to get an exclusive lock on all those objects.  That way, no
piece of code could begin running and then reach a point where it needed
to wait for something else that was waiting for it to release some
earlier lock -- so nothing could deadlock.

The problem is that there would be plenty of cases where the list of
objects could not be trimmed down any further than "all objects in the
entire universe" without getting into code execution, which might
depend on other objects ...

So then the alternative could be: inter-object communication is handled
exclusively through no-return message-passing.  "Returning" data must
be done with a callback.

That's a terrible thing to do to scripters, though.

On the other hand, consider this: LSL (Linden Scripting Language)
doesn't have anything like message passing.  It has things like "say"
and "listen" which are crude approximations of the same sort of one-way
communication.

Also, this doesn't really solve the problem.

Suppose someone wants to get a result from another object.  They're
writing code that just can't continue without it.  So they build a dumb
method into their object that sends a message and then busy-waits for a
reply.  This would lead to the same sort of deadlock opportunities.

Maybe I need to think of a concrete situation.  That might help.

A typical example would be a living room with two toggle light switches.
When a light turns on, it changes surface texture and becomes luminous.
Those are two separate operations.  Additionally, there are several
bulbs in the room, and the switches must iterate over them, either
turning them all on or all off.

With two people standing at either end of the room, punching the buttons
simultaneously in an effort to screw up the lights in some amusingly bad
way, it's not hard to imagine that both switches might be iterating
through the lights simultaneously, leaving some on and some off, or
worse, leaving some with the "on" texture but without luminosity.

So how would I solve that problem?

I guess step one would be to eliminate this idea of iterating over a
disconnected set of lights.  There's no way that can ever work, unless
all objects everywhere execute in a single thread with no interruption
of any code until it finishes.  (Translation: object code is completely
useless.)

So this would just be an elementary example of what _not_ to do when
designing a lighting system.

Instead, there would need to be a single object (the room "wiring", for
instance) containing the state of the affected lights.  Once that design
is adopted, really just about any reasonable implementation will work,
as long as the "wiring" object can't execute its light-switching code in
multiple parallel threads.

In the real world this problem is solved through what amounts to
continuous busy-updating.  It would be as if there was a process in the
middle of it all, running in a busy loop, asking the two light switches
for their state, and then setting all the lights accordingly.  In that
case, any inconsistent state would exist only very briefly.  In the real
world, everything happens at roughly the speed of light so there's no
perceptible moment of inconsistency.  (Not to mention the fact that the
mechanism is completely different from in a simplified simulation.)

Since things like switches that cause object state changes are sure to
be done a gazillion times, maybe the answer is to have some sort of
specialized language for specifying them.

Maybe it's as simple as message-passing, and having only one message-
handling thread in an object.

Another thing I was thinking about earlier today, which might be handy
if I'm going to effectively make all message handlers "synchronized",
would be having properties on an object that can be queried without
sending a message.  Perhaps those properties could even have code hooks
if they're things that are best evaluated lazily, but then they should
operate under strictly self-const circumstances.

Probably what I need to do is to think of more likely uses for object
code.  This shouldn't be too hard; I've run into a few things I wanted
to be able to do with LSL but couldn't (mostly in the realm of privacy,
I guess), and it should also be adequate for doing the things that _are_
possible (and have been done) in LSL.

I'm imagining a region as a "cell" within a world, itself a larger cell.
Each cell has an owner.  The owner can send a message to the cell (the
cost of the act of sending a message should be charged to the caller
until the call successfully reaches a method) telling it to create a
subcell and granting ownership of that subcell to someone else.
(Granting ownership just enables the grantee to take ownership of it;
until that happens, it still belongs to the original owner.)

I'm also thinking about the importance of developing some sort of
offsite backup plan.  I think the offsite backups probably should be
encrypted, but as I wrote before, I need some sort of physical "decoder
kit" that is too big and heavy to lose track of.

The idea of keeping both a CD-ROM and hardcopy keys is probably good.

2008-01-23

I can feel the bytecode ideas starting to settle into something I feel
comfortable with.  I just need to remember to keep it simple and get it
up and running.

I _do_ want to focus on designing a general bytecode first, though.  I
really don't need to worry about the programming language -- there can
be many languages targeting the bytecode.  The first one will no doubt
be very simple, C-like.  It will, however, by dynamically typed.  I will
not impose mandatory static typing, but I might allow optional type
declarations for people who want to use it, to improve performance and
catch errors.

The bytecode need not even be final.  I want it to begin with a magic
number that indicates what version of the bytecode it is.  But I suspect
my current design should be adequate (it is partly based on Java):

...

Actually, I was just looking at Jamaica, a JVM bytecode assembler, to
get an idea of what kinds of instructions I would need.  For some
reason, I had the vague idea that pretty much all I needed was some
basic arithmetic and logic, and a way to call functions.
(Theoretically, that's true.)  But it's somewhat more complicated than
that.  I might be better off adopting Jamaica itself as the bootstrap
language, using the raw JVM bytecode, but passing it through a validator
to ensure that it doesn't attempt to call any static methods in foreign
classes.

I really want a language that _can_ be used with dynamic typing, and
Java's class structure and lack of operator overloading make that
impossible.

I also want to be able to pass method pointers around.

I'm a long way from even beginning to implement any of these ideas -- I
have so many issues I need to deal with before I'll even get a flat
checkerboard world and a cube avatar with which to walk around it.  I'll
need a lot of help to get the object code system working.

The above idea appeals more and more to me: allow arbitrary JVM bytecode
with just one restriction: no invokestatic.  That could be applied
universally, without the complication of checking whether a static
method is being called on a "permitted" object.  Thus, allowed static
methods could be made available by putting them in a DVObject base
class.

I'm not sure whether that would make languages like Scala, JRuby, or
Rhino available.  If they compile into bytecode that uses tons of
invokestatics, then obviously it would not work.

I guess it would also be necessary to forbid "new", and to require the
use of a special protected new that checks whether the class being
constructed is allowed.  Basic data structures would be useful.  File
I/O objects would be disastrous.

And of course, the big problem with that idea is I get none of the
dynamic typing benefits I want.

It's a difficult balance to strike, between doing the things I want to
do, and doing the things I _can_ do as quickly as I need to do them.
What's haunting me is the notion that the whole system will essentially
be useless until objects can be meaningfully scripted.

I'll decide when I get there.

I especially want bignums to be convenient to use; perhaps even the
default integer type:

http://www.cs.clemson.edu/%7Esteve/Spiro/arianesiam.htm

I really would rather make a Lisp-like language, perhaps with some
syntactic sugar to make it more palatable to people who have been weaned
on C-like languages.

And I'd rather have tail recursion, which I don't think the JVM
supports, so I'd have to make my own virtual machine anyway.

But still, I can't help thinking that this idea is _way_ too
ambitious -- JIT compilation into JVM bytecode, for instance -- and that
there are going to be tons of unanticipated complications that I just
have no inkling of.  I didn't have any idea how complicated the network
code would be before I started writing it, because I was completely
ignorant of the issues -- I'd never written a server before.

I assumed the interface would wrap up buffering for me so the socket
would be presented as little more than a filehandle to write to, and
perhaps have to remember to flush.  Maybe that's just another indictment
of Java, that it doesn't provide such a thing.

I might not like the name "Distroverse", but at least it isn't "Call
Block MP3 Ringtone Edition v1.53".

I also want the language to be minimal yet powerful, like Scheme, but
also fast, like Common Lisp.  (Maybe Scheme can be fast, too, but not
based on what I've seen -- at that programming language shootout.)

Maybe it really is important that I do something quick-and-dirty first,
but allow more than one bytecode format.  If the first one is "good
enough", even if it is a fairly ugly language, it will buy time to do a
much better job on the second language.

If I do something like a genuine Lisp dialect, the language will be
pretty much doomed.  Won't it?

But Lisps are the easiest languages to interpret, and also certainly
among the most powerful languages.  It could be a quick-and-dirty
dialect of Lisp.  Dijkstra would not like it.  [Maybe McCarthy would
think it was okay, though.]

A Lisp dialect with a "send" function.  The data types and the idea of
message-passing between objects would likely be deeply ingrained in the
Distroplane implementation -- regardless of the bytecode language.

I think I'm ready to run the server and do a very basic test of it.  For
some reason, though, I'm dreading that task, even though it should be no
more than a couple of mouse clicks and a few dozen keystrokes.  That's
probably just a reflection of how I feel about the network code in
general.  It's so awful that I don't really like the idea of running it.

I'll need to figure out how this is really going to work, and soon.

Okay, that wasn't so painful after all.  I had to change the port from
808 to 1808 to avoid a permission-denied error.  The next run did
actually listen, and accepted a connection, but when I sent the line
"LOCATION foo foo", I got a null pointer exception, with a nice stack
trace.

Null exception fixed, but now it isn't responding to my LOCATION lines,
and I have no idea why.

I'll try sending 1024 bytes.  Maybe it's refusing to do anything until
the buffer is full.

That appears to be one problem.  I also got a string index out of bounds
exception from Util.stringStartsIgnoreCase().  I'm glad I factored
_that_ out.  I didn't realize it was illegal to take a substring of a
string past the actual length of that string.  Kinda lame.

Fixing that, now it just sits there.  I'll either have to use the
debugger to watch what is going on inside it, or I'll have to add some
debugging prints.  Given that I already think the code is messy, I think
I'll lean toward the debugger.  I want to at least try it out.

Tomorrow night.

2008-01-25

This Steve Yegge fellow ought to learn to strip away the superfluous so
that his perfect jewels of wisdom can be more readily accessed by those
who need to see them.  In this case,

http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html

strongly reinforces the conclusion I'd been gradually moving toward,
that it just isn't practical to create a new language or bytecode for
DV:

"It was a complete surprise to me, after 20-odd years of industry
experience, that even writing a simple interpreter would produce a
lifetime of work."

That's a little scary.  Even if I assume that Stevey has problems with
restraint, brevity, and minimalization, I really don't want to take that
risk of getting sucked into an open-ended component of the system to the
exclusion of everything else.

By myself, I cannot create a new object-scripting language.  Without it,
the project probably won't be interesting enough to attract other people
to join in.  It might never reach critical mass.  So I need to take
something that already exists and find a way to adapt it to my needs.
In other words, I need to find a way to eliminate access to all OS
functions within a SISC-interpreted Scheme program, so that it just
contains the core language, plus a message-sending function, and a
reference to the containing object.

Naturally, a cell is an object too; it just doesn't have a visible
physical manifestation like most other objects do.

And every object (including cells) is contained within one other object,
with the root cell containing itself.

A new Distroplane contains a root cell, which contains one configurator
object at <0,0,2>.  The user connecting to the new plane adds a second
object: their avatar, at <0,0,0>.

It's just too much fun to think about these things.  I'm getting
distracted.

Back to the point, the new language should only be begun when there are
several dozen people actively working on the project, at the earliest.

I think the defensive-programming answer to the deadlock problem is to
have messages that require a reply time out in N seconds, where the
sender can set N to something other than its default of, say, 5 seconds.
Perhaps it could be specified in processing units, to avoid a flurry of
timeouts when load gets high.  I'm not sure.

Or [I'll debug] tonight.  [As I wrote this, the above entry was still on
the other computer.]  I really need to find out what's going on inside
that HelloServer.

I think I have a rough idea of how the more stateful servers will work.
Each session will have a queue of things that need to be sent, and if
a new event is added to the queue that invalidates a previous one that
hasn't been sent yet, the previous one gets deleted.  If the queue gets
too big, it gets wiped out and replaced with a single instruction that
effectively means, "Get back to me when you're awake and alive again,
and I'll send you the complete state because it's changing too much and
you're not keeping up."

Actually this Debug perspective is quite nice.  And I think I see the
problem: I didn't flip the buffer in my read_connection() function.

That's my first mistake.  The second one is that I'm not converting
bytes to Unicode characters.

Also, it appears I'm not writing the response correctly.

It is very nice to be able to step through the innards of the running
program and see the variables laid out so neatly like that.

And just like that, I got it working.  Not so bad.  [8 minutes.]

2008-01-26

Clearly I will need some sort of object transmission queue for the
proxy-to-client communication, not just for the server, so I'll need to
do that next.

It will be used in both the client and the server, so it belongs in
core.  And it is very general -- the sort of thing that might be useful
in any number of networked Java (or Scala, or Rhino, etc.) apps.

2008-01-27

Actually, I'll need queues for sending and for receiving, to re-assemble
objects as they are received in pieces.

I'm sure there has to be something out there already that does this, but
it could be instructive, and it could always be replaced later.

It's not altogether general, because of the invalidation plan.

2008-01-29

Paul Graham just released Arc today.  It looks nice.  Oh, crap.  Safari
crashed again.

Anyway, it looks like a language I might want to appropriate for
Distroverse, but with one little change to handle the object system.
Behold, a program in Darc:

(= room this->container->room)
room->(lights-off)

I'm actually not sure how an object's container (which I assume would be
a cell) would have a room as its property -- whether that would always
be guaranteed to work.  Probably not.

But the snippet expresses three^H^H^H^Hfour important concepts:

0. The default (i.e., built-in) object "this"
1. Object properties (this->container, another object)
2. Left-associativity of -> (very un-Lisp-like, except that
   "this->container->room" is a valid Lisp symbol)
3. Message passing using the arrow/funcall syntax, which is again not
   Lisp-like.

I came up with that syntax in response to pg's use of a special syntax
for lambdas -- [] -- which meant I can't use that for message-passing.

I like the arrow notation better anyway, because it's somewhat familiar,
although dots are more popular these days as it turns out, and because
it allows a consistent syntax for both properties and messages.

I guess the big question is: How much work would this be?  It would
surely be easier to just provide these facilities as functions, and in
fact I'm sure that's what they would be.  x->y would just convert to
(get-object-property x 'y), and x->y->z would be
(get-object-property (get-object-property x 'y) 'z).  And
x->(y z) would convert to (send-object-message x 'y 'z).

2008-01-30

A function can print to stdout, which can be made to be the return
value of a message or function ((return-stdout)?), or to stderr, which
percolates back to the console whence the message or function call
ultimately came.  Or perhaps (capture-stdout my-stdout) and maybe even
(capture-stderr my-stderr)?

Normally the return value of the message is just the return value of the
function.

Last night I had a "vision" of the object repl being a floating window
with an arrow connecting the object being interacted with to the window,
mirroring the "object->(method)" syntax.

But this suggests that something like (defprivate) that creates methods
that can only be called by other methods within the same object -- this
wouldn't actually buy anything, because even if the repl couldn't access
them, functions defined from it could (right?).  I think the only
reasonable way to prevent it would be to allow the repl to be closed
off.

Or perhaps to have the repl run in some sort of context that does not
provide the ability to ...

This is too complicated.

Really, what I want is for the floating repl box to be a DIFFERENT
object that sends messages to whatever the arrow is pointed at.  And
maybe the interaction syntax would be something like

->(method)

so that without the "->", it would just call standard functions within
the context of that repl window object.

This suggests that there ought to be a different method to allow someone
who has permission to do so to open up an object and poke around inside.
Otherwise, how would the code get into it in the first place?

Something like the DrScheme two-pane approach might be nice, where the
top half of the window has the definitions, and the bottom window is for
repl interaction.

I'm not wedded to the arrow syntax.  It could be a dot.  I just think
the arrow is less likely to clash with some code that someone might want
to cut-and-paste in.  (Not that there's much Arc code out there to cut,
yet.)

The only problem I have with the dot is: How do you call a method on a
floating point number?  Or ... is there just a restriction that method
names can't start with a number?  Probably, I guess.

Not that I'm doing that, anyway.  Numbers are not symbols that can refer
to objects.  I'm just thinking about all the other languages that use
that.  It seems vaguely impure.

The lack of Unicode in Arc might be the deal-breaker, but I think there
will be enough pressure to add that that eventually someone will do it.

Just in case, though, the important thing is that I can hook any Lisp
into it, or more properly, Scheme using SISC.

2008-01-31

So it turns out pg just phrased it poorly.  Arc does not stand in
iconoclastic opposition to Unicode, as one might reasonably infer from
his announcement.  He just doesn't care about Unicode because that's not
the interesting problem he was trying to solve in making Arc -- Unicode
is a peripheral issue to fill in after the really hard and interesting
stuff -- reducing the verbosity of Lisp -- starts to wind down.
Widechar support is hard and uninteresting -- and now acknowledged by pg
as necessary.  He also opened the door for someone else to do it, saying
that if it's good enough, he'll put it in.

I'm not going near it.

I might end up just going with Scheme, but I'm not sure.

I just realized ... maybe an hour ago ... that the choice of language
could be a highly nontrivial decision if, say, code can be passed around
in messages.

My -> notation might not work.  That's a common idiom in Scheme for
functions that convert one type to another, such as string->symbol.  But
the message-passing part of it would be fine, so maybe I just need to
make a minor alteration, such as object->"property" or
object->'property.

2008-02-01

I'm going to go out on a limb and say that the top two possible modes of
failure for Distroverse as a project are, in no particular order:

- I fail to get it done
- It turns out to be computationally impractical

Maybe another possibility, related to the second one, is that another
similar implementation comes along, and performs better, or has some
feature that people think is great and that I can't replicated because
of some bad architectural decision I made six months earlier.

I think I have a good shot at making the network queue code this
weekend, and from there, things should start to pick up speed.

A naive recursive Fibonacci function in Arc is roughly on the order of
half as fast as the same algorithm in Perl.  That's not a terrible start
for a prototype in its first public release, implemented on top of
another language -- an interpreter on top of an interpreter.  I don't
know how MzScheme in general stacks up, though I guess I could do the
same Fibonacci function.  (Unfortunately, I was playing around with this
at work, and I left my code there.)

I guess that makes it about as fast as Ruby.

I wonder how SISC would do, though.

I still like the idea of Darc.  I think it could work, and it could be
feasible to get it up and running in some minimally efficient way
quickly.

It would need some concept of local and global namespaces.

2008-02-02

At some point I'm going to have to switch to Git.  I can certainly
afford to wait until after 0.01, though.

2008-02-04

A This American Life rerun yesterday defined as "the mistake that runs
the world" one's belief that other people are more like oneself than
they actually are.  That's probably what would have doomed my old market
database idea.  Will it also doom Distroverse?

MzScheme itself is around 10 times faster than Perl at the naive
Fibonacci benchmark.  Arc is indeed just slightly less than half as fast
as Perl at the same test.  I doubt there are any theoretical reasons it
couldn't be made just about as fast as Scheme.

2008-02-05

myobject.(call arg1 arg2)

That does save a significant amount of typing, doesn't it?  The problem
is it can't work with whitespace, because (x . y) means something else
entirely.

Colons might work, except Arc uses that as the function composition
quasi-operator.

".." would actually work, but it's ugly.  It never comes up in actual
Lisp code, though.

".." it is, then.

   (= room this..room)
   room..(lights-off)

Same as

   this..room..(lights-off)

To make a function available as a method:

   (defpub lights-off ()
     (each light lights
       light..(off)))

The dot-dot-paren combo is a little awkward to type.  star-star-paren
would be better in that respect, but I don't think it looks better.

   (= room this**room)
   room**(lights-off)

   this**room**(lights-off)

Actually, that's not half bad.  It certainly stands out, which I think I
would want.  Arc doesn't define ** for exponentiation, so it could work
even with extra whitespace (even though I'm not crazy about that
syntax):

   (= room this ** room)
   room ** (lights-off)

   this ** room ** (lights-off)

That seems deeply un-Lisp-like, but then, so are objects.  It's no worse
than CLOS, I guess.

Maybe the other default object should be "world", and should refer to
the server.

   darc> world**(where-am-i)
   (example.com home 11.746422 0.0 -23.153101)

Though that's the sort of function that could probably be built into
every object.  The world object might be more useful for things like
checking permissions, authenticating other objects, and so forth.

Using cookies for state breaks things like doing multiple things in
parallel in different tabs on the same site (on the web).  Does it
matter for Distroverse?

Probably not, as long as there's a concept of an identity being unique
in a given world, and additional connections to the same world require
the use of different identities, with their own cookie namespace.

But that solution might not be much help for "read-only worlds" that
serve content, where it might be perfectly reasonable to connect without
an identity, with more than one window.

Or would it?  Maybe the idea is that it just wouldn't work that way.  I
can imagine an operation like "new window" might make a copy of the
state of the current connection, but with a different identity, perhaps
automatically generated.

2008-02-06

There's no need for anything like inheritance.  The message handler
could just be told to forward any message that can't be resolved
locally.  Of course, that only "inherits" public methods, but I prefer
that for encapsulation anyway.

It doesn't exactly allow everything that can be done with inheritance,
but it's easy to understand and it permits a reasonable amount of code
reuse.  What makes me a little nervous is the idea of a whole bunch of
singleton nonphysical objects floating around.

In a sense, actually, I guess every object would be a singleton,
wouldn't it?  Code should probably be copy-on-write.  Maybe everything
should be.

This approach to psuedo-inheritance is very much like Self.  (That's
where I got the idea.)  The neat thing that it permits, though I don't
know whether this would ever be useful, is that an object can have its
superclass changed at runtime.  (In a sense, everything happens in
runtime in Darc.)

I'm picturing some sort of iTunes-like interface for managing a
user's objects, both in-world and in inventory.

Wow, that's a good idea.

I added that to the TODO under "Future".  I probably need to go back
through this entire file and scrape out all the ideas I've had that
aren't in the TODO.

The only problem with that excellent idea is the question of how to
implement it: the inventory would be local, and the in-world object list
would be an abstraction not visible to the client.

And I realized that while -> is a commonly occurring string in Lisp
symbols, idiomatically meaning "convert this type to that type", <- is
not.  It's also a little more logically consistent with the idea of
message passing.  So the above example would be:

   (= room this<-room)
   room<-(lights-off)

   this<-room<-(lights-off)

I actually don't like that.  For one thing, the left-associativity of it
is very counter-intuitive.  Also, say what you will about the asterisks,
they do stand out, which I think is a good thing since they're so
syntactically inconsistent with the rest of Lisp.

The syntax is completely wrong.  The object should go inside the parens,
right next to the function name.  Everything else inside that S
expression is evaluated in the local context, not that of the receiver
object, or else it would be impossible to do anything interesting.  So,

   (= room this**room)
   (room**lights-off)

   (this**room**lights-off)

And now it's Lisp again.  Though now the double-asterisk idea sucks.  A
tick might work:

   (= room this'room)
   (room'lights-off)

   (this'room'lights-off)

In regular Lisp, those ticks would be parsed as if they were preceded by
whitespace.  I've never seen anyone do that, but it's unsettling to
change something that fundamental -- valid syntax that means one thing
into valid syntax that means something else entirely.  I like where the
quote key is, but it's also a weird cognitive clash to use it for such
different things.  I might like the slash better:

   (= room this/room)
   (room/lights-off)

   (this/room/lights-off)

Division isn't something that is done so often, and it would still be
possible, since a slash without any symbol before it wouldn't be
anything valid.  It does ruin w/uniq, w/link, etc.

Backquote.  No.  That's part of the quoting syntax.  It's confusing
enough.

Double tick?

   (= room this''room)
   (room''lights-off)

   (this''room''lights-off)

I do not like it.

The caret doesn't appear to be in use at all.  That's odd.

   (= room this^room)
   (room^lights-off)

   (this^room^lights-off)

Looks a little like Pascal.  It also tends to run together with the
words.

   (= room /this.room)
   (/room.lights-off)

   (/this.room.lights-off)

Call me crazy, but that one's growing on me.  If it were all slashes, it
would look just like Unix filenames or URLs:

   (= room /this/room)
   (/room/lights-off)

   (/this/room/lights-off)

That might be acceptable.

And the object browser would be a client feature.  It would have to be
part of the protocol to get objects from the server.  That shouldn't be
too big a deal.  The proxy could cache them.  Could maybe even store the
data in "cookies", which are another issue I'll have to deal with.

Really, this is all just procrastination until I get the network
code -- the in and out queues, and everything that they touch -- done.

2008-02-07

After sleeping on it, I like the /object/message syntax, and I think
imposing some artificial distinction on method messages and lookup
messages is probably a mistake.  Perhaps "method" messages always return
a closure.  That could go either way, I guess.

I need to be careful about adding too many features to the protocol,
like object-listing.  I'm effectively blowing up the protocol so that
the UI can present a unified view of local inventory objects and remote
owned objects.  I need to feel like that's a major setback to my efforts
to keep the protocol minimal.

I really hate to break the mathematical purity of the design, but there
are going to be a few impure features that are just going to have to be
stapled to the protocol whether I enjoy it or not.

I'll enjoy having that free-floating window containing my inventory and
all my in-world objects.

So /object/message is just syntactic sugar for
(send-message object 'message), regardless of where it appears.  I like
that.  I don't see any reason it wouldn't work with closures.  The only
drawback (if it can be called that) is that the message dispatcher on
the receiving object will have no way of accessing the arguments -- a
message really is just one symbol, and after that it's normal function-
call application on a closure with access to the remote object's symbol
table.

[A week later, I now think the function call should be (msg object
'message), in keeping with the reduced-typing spirit of Arc.  I'm
starting to think it _is_ a good idea to abbreviate lots of commonly-
used functions so that, once the programmer learns them, they become
easier to type and less disruptive of indentation.]

As long as I'm fattening up the client and its protocol, I might as well
stick the code editor in there, with its paren matching and syntax
highlighting.  [Implementing such a thing in the proxy, using
fundamental display elements, sounds like an unnecessary nightmare.]

Last night I was thinking about having a REPL with a definitions window
above it, but instead of doing it the way DrScheme does it, where any
definitions entered in the REPL are lost when the definitions window is
edited, I was thinking the defs window would not actually be editable.
Entering a definition in the REPL would update the definitions window.
Attempting to edit a definition would drop it into the REPL seamlessly.

One problem with this approach would be that the task of keeping the
definitions consistent with the history of macros and definitions could
become nontrivial, especially if macros were redefined and used again.
Scratch "could become" -- that _would_ be nontrivial.

It would be a cheap cop-out to just warn users that unpredictable things
might happen, your object might not end up in the same state when it
gets restarted, etc.

A better cop-out would be to do things more-or-less exactly as DrScheme
does them.  But I'd rather make it easier to use.

Maybe the cheap cop-out wouldn't be so bad.  It would only be a problem
with macros, and those are generally considered an "expert" feature of
Lisps anyway, so a macro hacker could reasonably be expected to
understand what's going on.

It would be easy enough to detect the potentially troublesome situation
and at least warn about it, along with perhaps suggesting an object
restart to ensure that its behavior remains consistent with the
definitions.  Perhaps that restart could even happen automatically
whenever a macro is redefined, with the effect that, unlike every other
Lisp, changing a macro inside the REPL actually would change the
functions previously defined with that macro in that REPL.

Could be regarded as more of a feature than a bug.  After all, if you
don't want it, don't reuse macro names.

Putting Darc syntax highlighting in the editor pollutes the generality
of the client.  I think the way to do it is to have the editor edit
HTML, and have some protocol for passing edits back to the proxy and
getting updates to the HTML as needed.

One word: JMonkeyEngine.

I think that's one word.

Some guy named Michael Bien (http://www.adam-bien.com/roller/mbien/)
started a blog toward the end of last year, and his first real-content
post was about something he made a few years ago that he called
"Metaverse".  I have no idea what the architecture was, but he said he
wishes he could keep hacking at it, but just hasn't had the time.  [It
looks like it was just a single-user simulation.]

Need to figure out how to deal with the license conflict.  I think the
answer is just to make the client GPL'd, but with a very specific
exception that it can be linked with the JME library.  Exception or,
maybe more accurately, clarification of position.

Dynamic linking is allowed, so the two pieces of software could be
distributed side-by-side, and linked at runtime.  I think that would be
allowed without exception.  But it might be easier, technically, to just
make an exception.

Actually, that might be wrong.

I can sympathize with people who object to the GPL for being too
complicated.

2008-02-08

JME includes a physics engine.  Maybe I should switch to it sooner
rather than later.

JME does sorta change everything.  It seems to do everything except the
multi-user part, which I wasn't going to get to for a while.  And it
provides so many features, the stripped-down protocol I had in mind
looks really inadequate.

Does my architecture still even add anything?  If you can click on a
link and download a Java Webstart application that gives you everything
I could offer, then what's the point of my DVTP idea?  Is there any?

I think it could still have some value, to insulate the user from that
process just a little bit, and maybe most importantly, to provide a
standard place to keep one's preferred avatar.  The goal is really to
create an architecture that will allow a distributed replacement for
Second Life.

I guess the good news is that most of the hard (for me at least) work
that I've done so far is the part that isn't in any way obsoleted by
jME.

There's nothing in jME that _detracts_ from what I'm trying to do.  In
fact, it makes it much more interesting.  If someone else finds it easy
to do what I'm trying to do, and leapfrogs me, I'd be okay with that, as
long as it's free software.

The first thing I need to do this weekend is find out whether anyone
else has already started doing what I have in mind, or something close
enough to it that I wouldn't care.

Licensing shouldn't be an issue -- jME is licensed under the newer
three-clause BSD license, which is GPL-compatible according to the FSF.

This networking stuff is hard, if you don't usually do it.

2008-02-10

It's all just a bunch of tangled-up tubes.

It's possible that my distinctions between NetInQueue and ObjectParser,
and between NetOutQueue and ObjectStreamer, are not useful.  I seem to
be just passing stuff back and forth between them a lot, as if they were
both the same class, but with the result that several methods that I'd
rather think of as implementation details are exposed.  [Which gives me
a new appreciation for the "friend" class concept in C++.]

I did have a good idea for how to make the session work: DvtpFlexiParser
and DvtpFlexiStreamer classes.  These classes would stream any string
without an embedded CR-LF pair and not beginning with a NUL, as itself,
UTF-8 encoded.  Any other object would be sent as:

   NUL, <byte: number of bytes of size>, <size bytes>, <object>.

2008-02-11

Despite my best efforts to just get something quick and incomplete done
to implement HelloServer, it looks like I really need to implement the
full DvtpFlexiParser/Streamer, because other classes are intimately
intertwined with them, and it really just won't save any time to do only
the string part.

I guess I could just implement String and have it die on any other class
for now -- that would save time.  [But creating a separate example
implementation for strings only, won't.]

2008-02-12

One thing I'd like to be able to make is a world where things are light
unless dark is "shining" on them.  I got this idea from what I think
might be an unintentional effect in a hidden area (a monster pen) in
level 16 of the Doom .wad "the Plutonia Experiment", between the
starting area and the anachrotrons' podiums.  The area looks like a
corridor with alternating ceiling and open sky, but the areas where the
sky is open are dark, and the areas shaded by ceiling are light (despite
no light-source images on the ceiling or walls).

It occurred to me today that my variation on the martini method works
especially well the way I'm doing it, because I've set such a low bar,
as it turns out.  At first, when I was still pretty rough at this, it
seemed like a lot, but now it just takes touching a few pieces of code
and making some notes, and I'm "done" for the day.

But usually, by that point, I really want to keep going, so what the
martini method does for me is not set a goal of a decent evening's worth
of productivity, but to just get me past the "staring blankly at the
screen" syndrome I usually start out at.

Once the ball is rolling, it doesn't stop easily, unless there's
something really tugging at my attention.

And since I know 50 lines of SVN diff is such a piece of cake, I don't
ever sit down with a feeling of dread or of being overwhelmed.

Still, I want my Internet access back.

Wow, I can't believe I actually cleared all the errors.  I'm sure it
won't work, though.

I'll try it tomorrow ... unless the urge to try it today strikes me.

430 lines (of SVN diff).  Not bad for an evening after a busy day at
work.  Really, that was just about an hour of solid coding.

This weekend i hope to break into jMonkeyEngine.  The goal for the
weekend, since I expect to have HelloServer 2.0 up and running, is to
get a basic client with stubs for the networking code that put up a
"default" world.  Maybe I could make it the about:hello world.  I guess
I'll want to be able to handle "about:" URLs, so I might as well
implement that first.

Now the warnings (in the networking code) are gone, too.  I just think
I've probably forgotten some critical connection -- I've got so many
objects that hook into each other and need to call each other to make
everything work, and occasionally I discover something that I've
completely forgotten.  I'll probably have to step through it with the
debugger to find all the little missing pieces.

2008-02-13

And indeed, I get a null pointer exception from niqw.clearAllQueues().
I don't think that code should even be running until I connect to the
server.  (It didn't run long enough to connect to.)

That was a mistake in how I'd arranged the construction and activation
of the server, listener, and the watcher thread.

I fixed that, and now it's calling accept_connection() on each line of
input, but not responding to any of them.  So I guess it's debug time.

On closing the connection, it calls accept_connection() tightly in a
loop and then runs out of memory.  Awesome.

It's probably because I never bothered to implement parseObjects().  I
mean, that might have something to do with it.  That, and
streamObjects().  D'oh.

I think I've gone about as far as I can go without the debugger for
tonight.  So, I'm in the debugger now.  I just need to remember how to
use it.

I'm finding stupid newbie bugs all over the place, but it's still not
running.

2008-02-14

Happy Valentine's Day, Java.  Thanks for sending the selector in a busy
loop when I try to register an OP_WRITE key.

Oh, I get it.  The moment I register the OP_WRITE key, it's ready to
write, but the problem is it's never unregistering the key, presumably
because it's not emptying the queue.

Might have something to do with the fact that I never wrote a
writeConnection method or added anything to handle writable keys.

At least now I get a response before it dies from an uncaught exception.
I think that's as good a point as any to stop for the night.  I can see
what remains; it's no big deal.

2008-02-15

Of course, that assumed there was nothing else wrong with it.  Now, I
get a perfect response to my first message, but things break down after
that point.  The main symptom now is that subsequent messages are
ignored.  I need to find out whether the reading key is being removed
from the selector.

It is, but I don't yet know how it's possible.

2008-02-16

I resolved to kluge my way around the problem, and I've done that.  The
server now behaves correctly from the client's point of view.  It does
seem to spaz out when the client disconnects, though.

I'm using a lot of debugging prints to watch what goes on without having
to step through it slowly.  I think if I'm going to do that, I need to
make a Log singleton so I can easily turn types of log messages on and
off en masse.

Wow, yeah, I've got more of them than I thought.  I don't want that to
grow out of control

Another ugly kluge gets around the disconnect-spazzing.  I'm intent on
just getting something working so I can move on to the parts that are
interesting.  Writing a networking app in Java is not revolutionary;
there are probably tons of people who know how to do that well.

I'm pretty sure that the network subsystem architecture I've put
together will work well for what I'm trying to do, once it is
implemented a little better, and I'm pretty sure it can be implemented
cleanly and correctly.

Turning a program into a Mac executable is surprisingly easy in Eclipse.

I have jME downloaded and imported into my Distroverse working set.

That was somewhat painful, but I got it [the jME TestArrow demo -- not
anything I wrote] running.  Now, I want to see whether I can wrap it up
into an application that I can copy over to the work MBP and run without
having to download anything.  Somehow I doubt it.  I guess I should be
able to just look inside the package to see whether it contains all the
necessary .jars and native libraries.

jME does suffer from the same sort of jagged update problem I noticed
with Java3D.  I'm hoping that can go away at some point.

From this TestArrow demo, this looks ridiculously easy to program in,
but I realize that'll only be true if the paradigm fits what I want to
do.  I'm hoping it's sufficiently general.

Yep, Eclipse builds a Mac application bundle with everything necessary.
I wonder whether such a thing is possible on a PC?

So I guess there's nothing stopping me now, right?

2008-02-20

Except a lack of good documentation, and a splinter design called
StandardGame that maybe I shouldn't have used, since all examples are
given in terms of AbstractGame, or SimpleGame as an example subclass of
AbstractGame.

From the description, StandardGame really does sound better, though.

Reading about git at

   http://git.or.cz/course/svn.html

makes me want to start using it more than Linus' Google talk that I
watched on YouTube this week, although to be fair, it was his talk that
made me go look.  I was a little put off by the forcefulness with which
he promoted git, but given his stature, I guess I unconsciously assumed
he was probably right.

It looks like git is really the only practical way to do a free-software
project with lots of contributors.

I hope I get lots of contributors.  Otherwise I'm fuct.

There's likely to be a significant lag time between putting DV out there
and getting any kind of interest at all from the right kind of people,
simply because it takes time for word to spread around, so maybe I
should put it out there right now and develop my way up to 0.01 in full
view of everyone (with git, obviously).

I would at least want to sketch out a large framework of unimplemented
classes.

Part of the reason I'm hesitant to go public already is I'm afraid of
losing control of the project in some important way -- especially the
Darc idea, I expect that to be unpopular.

That's a little absurd.

There's also the rationalization that I don't want people to see this
extremely unfinished thing and form an opinion of the project on that
basis.  That's also absurd.

I want to try to at least get to the point of having _something_ to show
that might fire people's imaginations.  I think if they could see even a
crude VR world rendered in an interface that explicitly references the
Web browser paradigm, that would be a light bulb moment that no text
description could match, and that would draw in a lot of people who
would otherwise just file it under "big deal" and move on.

So, fine.  I think that's an achievable goal.

2008-02-21

I'm having serious second thoughts about the BigInt idea.  Yes, it's the
most general (aside from the fact that it doesn't do negative numbers,
which is another design issue I keep going back and forth on), and the
most compact in all realistic cases, but I'm pretty sure it's going to
be incurably slow.  I don't want the protocol to be forever hampered by
a slow number format.

Thinking about it a little further, I'm now certain I want to use
length-first encoding for BigInt (and I'm just going to do it the easy
way, using the first byte for length, and possibly for a sign bit).
I'll also make some finite number classes.  (Strictly speaking, my
BigInt will be finite as well, with a range of around 1.12 x 10^307.)
If for some reason that is inadequate, I have a virtually infinite
number of classes available to do other implementations.  I could do
both methods!

I'll make a CompactULong class with a range of up to 2^32-1, using the
high-bit-terminates approach, and I'll make that the class number.  If
ever the protocol grows to more than 2^32-1 classes, then we're screwed
for more reasons than one, but there would still be the option of
reserving class 2^32-1, or maybe better yet, classes 2^31 and up, for an
extended class map.

It seems a little ridiculous, but maybe there will be a reason.  I can
hardly see that far ahead.

2008-02-22

Actually, I guess a long should have a range of up to 2^64, or 2^63 for
the sake of simplicity.

I need to figure out how I'm going to mash all these things together,
because right now I don't have a clear sense of when something should be
length-prefixed, when it should have a class identifier, etc.

I guess the question is: How deeply into an object should one be able to
look before one absolutely needs to know what to expect?  How far should
one be able to parse an encoded object just by a simple, general set of
rules?  The Pair class obviously can be completely general -- has to be,
really -- so you could have Pairs of Pairs of Pairs, like in Lisp, and
traverse that data structure without knowing anything about the bits
inside it.  And on the other hand, if every X, Y, and Z in a mesh had an
object-type and length prefix, it would swell up shapes unreasonably.

But maybe the answer to _that_ problem is just to make a point-array
class.  [Which has actually always been the plan.]

I'm just hesitant to make a format that can only be parsed by the whole
program, because it more-or-less destroys the ability to create simple
tools that might be useful later on.

2008-02-26

"Don't launch with a crappy product -- launch as soon as what you have
is better than what is out there."  That makes a certain amount of
sense, but the definition of "better" is tricky.  The point is that it
needs to attract people.  If someone is thinking of trying to build a
second Second Life, it needs to be something good enough to convince
them to drop their ideas and work on mine.

Before I go public, I want to Google the word "distroverse" and save all
the results.  I think there were only two pages last time I did that.

The proxy sends the client an FPS range.  The client can send back too-
fast or too-slow messages, which include the fraction by which it is too
fast or slow.  I.e., if the target FPS range is 20-60, and the client is
getting 5 FPS, it would send the proxy a (too-slow 4.0) message.  If
getting 150 FPS, it would send (too-fast 2.5).

It occurs to me I need to put maximum emphasis on speed, and minimum
emphasis on space, when designing the protocol, because it's meant to be
high-bandwidth, local, and fast.

I can add some super-compact classes for use in distroplane, and it
might be appropriate to give them low class numbers.

But I need to think about how that's going to work -- do I want to
piggyback on DVTP, or define a new protocol?  If I have multiple
protocols, do I need to refactor my design?  If not, how do I make them
cohabitate cleanly?

It would probably be natural to piggyback.  So I'll need to define how
the proxy will communicate with the server, and carve out a class space
for that to happen in.

I'll do that by getting as simple an implementation of client and proxy
working as I can, and then work on a server that maintains state.

2008-02-27

Watching a frantic talk by Randal Schwartz is actually making me want to
switch to git tonight, not in some future date.

I also think maybe the URLs should start with dv:// instead of dvtp://,
just to save typing.

He should have trimmed it down to about half the content, but I guess
there's a lot to cover.

I changed my mind.  It'll be a weekend project, if that.  Figuring out
exactly what to bring in, and how, is going to be a little complicated.

I finally figured out why my TextDisplayBar wasn't showing up.  I'd just
managed to create a node that wasn't attached to anything.  I don't
know how I missed that one.  Sheesh.

2008-02-28

Here's something to look at and despair about:

http://www.uni-verse.org/

At least they have some software I can download so I can see what the
point of it all is.

I changed my mind about that as well.  I'm not going to despair.  Verse
looks interesting, and so does uni-verse, but there's not really much
there at this point, despite the $18 million in funding they got from
the Swedish Royal Institute of Technology -- sorry, that's 18 million
SEK, which is around US$2.9m.  I forgot the Swedes weren't on the Euro.
For that matter, Euro >>> USD now.

Anyway, good luck to them -- it seems like a very well-intentioned
project -- but I don't think it should stop me from having a good time,
or failing that, at least writing some Java code.

2008-03-03

But who knows what would have happened if I'd done things very
differently?  . . .  Perhaps I would not even have my current big
idea -- the sequence of events that led up to that was very specific,
and included having a 15-minute walk to and from work each day, during
which I could ponder virtual reality, and everything that was wrong with
Second Life.

I hope I can get back to that soon, and quickly get it to a point where
it is publishable, now that I know how to add objects to the scene
graph.  I'll probably want to make some sort of utility wrapper around
that very convoluted technique of adding a callback class to a queue.
Anonymous class syntax is a painfully verbose way of making callback
functions, and most of what's in the function is boilerplate for the 3D
thing anyway.

Also, I want to try applying a MapReduce design to Distroverse.  I was
going to add Filter, but Filter can be implemented in terms of Map and
Reduce: map from subsets that compose the whole set being filtered into
subsets that only include interesting elements (so many of them will be
empty), and reduce the subsets by taking the union of those sets.

This would only lead to passing around unmanageable sets of data if the
requested set was too large.

I'm not sure whether it's a good strategy for, or even a substitute for,
R tree queries, though.

2008-03-05

MapReduce is not exactly what I thought: it applies to a Map (a hash of
key/value pairs) -- hence the name, and Reduce means merge results with
identical keys.  So transform a map, and then merge identical keys.

I was thinking of Map as in Perl @result = map { code } @input, and
Reduce meaning a more general version of Haskell's foldl, where the fold
operations don't necessarily happen in linear sequence.  I still think
that would be useful, but it would need a different name.  Maybe
TransFold, or MapFold.

I think it would still be reasonable to guarantee that folding happens
in a specific order, without skipping elements.  Concatenating files
would be a reasonable standard library thing to do, perhaps implemented
as another MapFold, transforming a list of filenames to a list of
filenames and offsets.

2008-03-09

I finally installed jME from the CVS source (yes, they really use CVS),
so I can see how primitive shapes are constructed.  It looks pretty
gross -- Vector3Buffer/VertexBuffer/FloatBuffer in particular looks
nasty.  But at least it's something.  I'll have to write some routines
to take a more-sane TriangleStripArray and turn it into a VertexBuffer
for a TriangleBatch.

2008-03-10

I need to look around for better ways of creating shapes in jME.  I find
it a little hard to believe that the only available tool is actually as
ugly as what is used in the Pyramid class.  It's a no-win situation,
though, because the fact that they would include such gross low-level
stuff in the Pyramid class suggests jME is not very well designed.  [Or
that I don't know what I'm talking about.]

com.jme.scene.TriMesh appears to be what I want.  [It's still pretty
nasty, though.]

2008-03-12

[I think the following table explains a lot of why people object to
Lisp.  The various grouping tokens in C-like syntax help speed
comprehension of a particular block of code.]

End of          In C-like languages      In Lisp
Statement                ;                  )
Block                    }                  )
Function call            )                  )
Index lookup       ], sometimes }           )
Arith. expr         ) or nothing            )

2008-03-13

I'm not sure about whether either Jython or JRuby is worth the trouble.
I'll think about it as I get nearer to writing the server.  I'm still
not even 1/3 done with the trivial v0.01 of the first third of it (the
client).

I've decided my idea is worthwhile, even if other people are working on
VR.  I had a moment of insight into what things might be possible with
my design as I wished I could rank (or filter) stories on news
aggregator sites using a Bayesian classifier.  It's just not practical
to do something like that over the web, because it would require far too
much processing on the server.  It _would_ be practical with a DV
client.

In fact, it makes me wonder whether it might be worthwhile to have a
text mode or 2D mode, rather than just supporting 2D elements within 3D
GL.  [My expectation is that this would make it easier to have several
windows (or even tabs) open.]

Again, though, the drawback seems to be the difficulty in writing
crawlers for DV.

2008-03-15

If the protocol is going to use floats, that means the coordinate system
would need to be recentered every time the user travels more than 1 km
along any axis, to avoid errors greater than 0.1 mm.

2008-03-22

I've got something displaying, other than a HUD, for the first time.  I
can't tell what it is, though.  I'm not even convinced it came from my
code -- I think it might be some sort of default object added to the
DebugGameState, visible only when the right keys are pressed.

I guess I could change the parameters of my shape factory.  First, I
feel I should check this in.  This seems significant.

I can't for the life of me figure out what's going on, but increasing
the resolution of the ball seems to have added a solid white shape.  It
actually appears to just be a triangle.

It's definitely doing something.  Bumping up the number of rows again,
from 5 to 6 (I started at 3, for what I hoped would be a regular
octahedron) results in a different big white shape.

I guess my next idea would be to add a TriMesh pulled directly from an
example, such as HelloTriMesh.

Of course, it displays perfectly, so now it's just a matter of either
modifying my code until it matches the code from HelloTriMesh, or
modifying HelloTriMesh until it produces the shapes I want.

2008-03-25

When I put up my news.yc clone, I'm going to:

- Only invite people who have contributed code
- Give them 100 karma points to start if they contribute code I would
  use unchanged
- Otherwise 10 points
- Allow people to vote if they have at least 100 points, or have been
  invited
- People who are invited get "invited by x" on their page, and people
  who invite get "invited x, y, z" on theirs
- Allow anyone to post or to comment
- Allow people to invite others to join if they have at least 100 points
- Keep the earlier idea for off-topic (no-karma) and on-topic division

It's starting to sound a little byzantine.  I might need to pare this
idea down a little bit.  But that's approximately how I want to keep it,
I think.

I might also want to put some sort of stupidfilter in the way of
commenting, similar to my spam filter.

Maybe even just a loose adaptation of the spam filter.  Its default
behavior should be good -- if it doesn't see both ham and spam, it
assumes everything is ham.

The spirit of laziness would be to not do that until it was necessary.
It's great to have ideas, but I need to focus on the productive ideas.

2008-03-26

Maybe I could have dual concepts of karma, being what it already has
come to mean, points accumulated by activity, and weight, being on a
fixed scale from 0 to 1, and reflecting basically "agreement with dreish
about what is good and valuable discussion and what is not".

That could be calculated automatically based on my votes on comments and
articles, of course.  Every time I would vote, the weights of others who
voted on that article or comment would be recalculated.  Every time
someone would vote on something I had voted on, their weight would be
recalculated.

M = votes cast by user U on items also voted on by site owner
N = number of M-votes matching site owner

weight(U) = (N+1)/(M+2).

One problem with this idea is that if I were to downvote something
because I thought its score was just a little too high, relative to
other items, it would penalize everyone who upvoted it -- even the first
user, whose upvote might have been perfectly reasonable.  But I think
that's probably about the best I can do.

Maybe,

magnified_weight(U) = (w^2)(1-w) + w*(1-(1-w)^2).

I think I would also try to make it appear to the user as if their own
weight was always 1, but it might be impractical to be constantly
recalculating scores.  If each logged-in user has a hash in the server's
memory of the things they've upvoted, then perhaps it wouldn't be too
computationally intensive.

This might work well with allowing the owner to vote multiple times.  I
could downvote an item showing up on the front page until it
disappeared.

After playing around a little with some spreadsheet graphs, I came up
with this:

M = votes cast by user U on items also voted on by site owner
N = number of M-votes matching site owner
p = power

raw_weight(U) = (N+1)/(M+2),
mag(x) = (x^2)(1-x) + x*(1-(1-x)^2),
weight = mag(mag(raw_weight(U)^p))*scale.

I would want to start out 'p' at 1.0, so that new users would have a
weight of 0.5.  If things got really bad, I might increase it, so new
users would start out with a really low weight, and would need to agree
with me on several votes before their votes would count for much.  If I
were to do that, I might have to add additional moderaters -- a
possibility to consider when writing the code for this.

I think I would also put some hints on the comment and submit pages:

'This site is intended for programmers working on the Distroverse
codebase to discuss issues directly relevant to that effort (on-topic),
and other issues of interest to the programmers (off-topic).  It is open
to the public, but not intended to benefit the general public, outside
that group.  Before posting a comment, ask yourself:

'- Is this comment polite and respectful?  I shouldn't need to say it,
but consider this fair warning: vituperative, unenlightening flames,
directed inside the group or outside it, will cost you karma, and
upvoting flames will cost you influence.

'- Does this comment add to the discussion?  Clever one-liners are fun
(especially when they come from a positive attitude), but is it _more_
than just a clever one-liner?  Can you think of anything substantive to
say along with it?  Do other people need to read this, or do you just
need attention?  If it is humorous, will the rest of the coders get the
joke, or is this a private joke intended for a small subset of the
group?  Comments are held to a slightly higher standard than
submissions, because a bad submission is less disruptive than a bad
comment.

'- Is this comment on-subject?  Look back at the submission you're
posting under; if you're drifting away from that subject, please
consider starting a new main-page thread and referring back to this one.
We love new posts -- the more the better.  We don't love crazy
out-of-control jumbled conversations all under one post.  Along that
line, please refrain from repeatedly diverting unrelated discussions
toward promoting your pet political or religious beliefs.  That could
get you banned faster than flaming.

'- Ideas and conjecture are great, but are you trying to look
knowledgeable by claiming to know something you don't really know?
Consider adding "I think" or "My guess is" -- a few simple words can
make you look honest and humble (which everyone likes) instead of
foolish and loudmouthed (which nobody likes).

'- Have you fully and clearly described your idea?  To quote Ehud Lamm,
we should not be playing "twenty questions" with people who haven't
taken the trouble to express themselves clearly.

'Note: these are also good guidelines to follow when voting.

'Also note: dreish is not required to act humble.'

That's a joke.

Actually, the above should go with _just_ the comment page, and I would
put the following variation on the submit page:

'This site is intended for programmers working on the Distroverse
codebase to discuss issues directly relevant to that effort (on-topic),
and other issues of interest to the programmers (off-topic).  It is open
to the public, but not intended to benefit the general public, outside
that group.  Before submitting a top-level post, ask yourself:

'- Is this marked correctly as on-topic or off-topic?  If you're
discussing the code, the protocol, or yaks that need to be shaved
(Google it), that is on-topic.  If you're discussing an outside site
that uses the protocol or the code, that's off-topic but generally
appreciated.  (If the discussion later crosses the on-topic/off-topic
threshhold, please create a new thread and link them to each other by
mentioning their URLs.)  Off-topic submissions are wide-open, within
reason.  If you crowd the new-submissions page with lots of things that
any reasonable person would know will be unwelcome, you'll get banned
and all your posts will be deleted.  If in doubt, lurk a little more.

'- Is this submission polite and respectful?  I shouldn't need to say
it, but consider this fair warning: vituperative, unenlightening flames,
directed inside the group or outside it, will cost you karma, and
upvoting flames will cost you influence.

'- Have you fully and clearly described your idea?  To quote Ehud Lamm,
we should not be playing "twenty questions" with people who haven't
taken the trouble to express themselves clearly.'

I think that's about it for the submission rules.  It occurs to me that
comments really are held to a higher standard than submissions, because
of the threaded nature of the comment tree.  Posting noise submissions
does relatively little harm, but posting noise comments can disrupt
conversation.  I'll add that above.

2008-03-27

Also, I should probably summarize tips for voting.  One important point
to emphasize: Don't try to use downvoting to "clean up" multiple posts.
They will get cleaned up automatically.  And don't ever downvote
comments because you don't like a submission.  Never downvote everything
on a user's page because you really dislike something a particular user
wrote or did, no matter how heinous.  (Of course, that means I'll need
to have some process scan the site for multiple posts, or better yet,
hook that into the "submit" logic.)

Don't stress out too much about following the rules on voting.  These
are just here to help you maximize your influence.  You can, if you
wish, just vote for whatever you feel like and let the system
automatically figure things out.  If it likes you, your votes will count
for more.

Don't downvote ideas you disagree with into negative territory simply
because you hold the opposite view, unless the comment is genuine
trolling, or clearly disruptive (offensive, argumentative,
topic-shifting, or otherwise).  If you disagree, consider replying, or
upvote someone else's reply.  If it's already widely understood to be
wrong, and introducing nothing new, just go to zero and leave it there.

It is sufficient to downvote thoughtless noise comments to zero, or even
leave them at one.  Doing more than this is akin to slapping your dinner
companion in the face for talking about the weather.

Do downvote really bad ideas, even if eloquently expressed, that are
getting what you perceive to be too high a rating relative to other,
better ideas in the same thread.

Do downvote things that are clearly stupid, right down to zero or -1 in
case of extreme stupidity.  Just remember: -2 and below are generally
reserved for hostility, trolling, and other antisocial behavior.

A pattern that might be useful is a comment that is actually a
submission, so instead of a _reply_ link it has a _goto_ link.  That
might be a good way to branch off to a different topic.  Such a comment
wouldn't have vote buttons next to it, but would have a score, based on
front-page votes it gets.

The view from the front page would be a link to the comment, almost like
a link to some external blog post.  This would help preserve context,
and the two-way linked nature of the discussion.

I'm not sure whether that's a system that could be gamed, or whether it
implies top-level submissions should be downvotable.  Perhaps only this
specific class of submissions should be.

More time wasted thinking about shaving yaks -- not even shaving them!

2008-03-28

I had an idea for Arc (applicable to Darc as well): an "expr" macro that
takes a string containing an expression in C-like syntax and turns it
into Arc code inline.  That might help make the language less
objectionable to certain people.

But why stop there?  Why not parse whole blocks of code?

An example:

Before:
(def fact-step (h)
  [if <._.2  1
      (* _ (h -._.1))])

After:
(def fact-step (h)
  [if (expr "_ < 2") 1
      (expr "_ * h(_-1)")])

Could maybe shorten expr to #, which by itself isn't valid syntax
otherwise, and get rid of the parens:

(def fact-step (h)
  [if # "_ < 2"  1
      # "_ * h(_-1)"])

Or, since C"string" is currently parsed as two different atoms, and
there's precedent for changing the meaning of things in Arc when
whitespace is removed (see (foo . bar) versus (foo.bar)):

(def fact-step (h)
  [if C"_ < 2"  1
      C"_ * h(_-1)"])

Without syntax highlighting, it looks like chicken scratch.  But,
notably, it makes the code in this case shorter, and it cuts down on
those troublesome parens that so many people get hung up on.  (I like
them, myself.)

Here's a sticky question, though: Is "_-1" really valid, or does it need
to be "_ - 1"?  Would making it valid be a decision I'd sorely regret
later?  I'll bet it would be.  So better make that an exception, in
which case C might be misleading.  Maybe an equals sign would be more
linguistically appropriate.

(def fact-step (h)
  [if ="_ < 2"  1
      ="_ * h(_ - 1)"])

Now it is more keystrokes than the pure Arc, not fewer, but the point
here is to provide something palatable for people who just can't think
in Lisp when it comes to math expressions, not to provide a superior
alternative.  A true Lisper would never like saying a+b+c+d+e+f+g
anyway, when (+ a b c d e f g) would suffice.  (Or +.a.b.c.d.e.f.g in
Arc.)

The objection that Arc (or Darc) starts to look like several different
languages isn't much of an objection.  Would should people not be free
to program in their own language?  Would you think much of an operating
system if it only allowed one programming language?

2008-04-10

Okay, I'm having DV ideas.  Arc again:

(imp v1) expands to (imp /darc/v1) which brings in a bunch of extensions
to Arc -- Distroverse-specific functions and macros.  I'm not sure how
much of the language would exist without (imp v1), but probably the
slash syntax, and obviously the (imp) macro.

(dec int x y z) would eventually declare symbols x, y, and z to be
integers.  This might have to be something like a let or with syntax,
so:

(dec int (x 0) (y 0) (z 0) :
 (while (< x 10)
    (+= z x)
    (+= y z)
    (+= x *.y.z)
    (++ x))
 y)

The use of the colon here would require changing Arc syntax a little.
Right now a bare colon is a syntax error.  [Actually, that's not true in
a quoted list, which is what a macro becomes.]  The idea is there can be
several variables with different types declared with a single "dec", and
then multiple expressions after the colon.  The value of the dec is the
value of the last expression, as usual.

Initially, this would be no different from (with) other than the syntax,
except perhaps there would be some typechecking of the initial values.

Finally, assertions could be useful as a standard part of the language:

(asrt t)

If it [the language, Darc] ever becomes compiled, those assertions might
be useful as compiler hints, but not if they're nonstandard macros, as
it is done in Scheme.

As fascinating as the mangled-Shape problem is, I'm going to assume a
decent jME coder could fix it in a few minutes, and move on to other
things, such as client-to-proxy-to-server communication.  What I can see
of Shape objects is good enough right now.

Some people might balk at calling an assert function "asrt", so maybe I
should make it available under both names.  I think a handful of
reasonable synonyms as part of the standard language might be a good
idea.

2008-04-13

Some things that might be fun to do:

- A wikiworld, maybe initialized with USGS data
- A four-dimensional spacetime that can be sliced along any three
  dimensions (as a way of viewing the revision history of the above
  wikiworld, for example, or perhaps with a fourth dimension that is not
  time, but another space dimension)
- A natural world with time sped up by a large factor (inspired by the
  rocks'-eye-view in Das Rad (the Wheel))

2008-05-03

Before I go too much further with the guts of the proxy-loading and
-running system, I should probably do some trivial tests to make sure I
have the right idea.  I guess I could try that tomorrow:

x Write a simple class, SuperAdvancedProxy, that listens on 0.0.0.0 and
  responds to any connection by saying "Hi!  Bye!"
x Telnet to it to make sure it works
x Write a class loader that
  x Loads and runs SuperAdvancedProxy
  x Connects to it
  x Gets and prints the Advanced message
x Try creating another "proxy" with the same name, but in a different
  directory
x See whether the class loader can handle both

Getting that written (not necessarily working) will satisfy my chain
requirement for tomorrow, regardless of the number of lines.  (I'll do
it outside the DV git working copy.)

I guess I could count git diff lines in that test area, actually.

I expect the proxy will need to have a unique class name, which kinda
sucks.

2008-05-04

I'm going to revise the above list a little:

+ Write a very simple class with a method that returns the String "foo"
  > org.dreish.proxytoys.SimpleClass.runMe() => "foo"
+ Write it to disk in a form that URLClassLoader likes
  > Pretty sure that's just the bin directory with the .class in it
+ Write a class loader that
  + Loads and runs the above class
    + Actually, take any class and any directory, as commandline args
  + Gets and prints the string
+ Try it out on the commandline
- Figure out how to run it in a sandbox
  - Add some privileged action in the SimpleClass, like writing to a
    file in my top-level home directory
  - Try it
- Write a simple class, SuperAdvancedProxy, that listens on 0.0.0.0 and
  responds to any connection by saying "Hi!  Bye!"
- Write it to disk as well
- Write a class loader that
  - Loads and runs SuperAdvancedProxy
  - Connects to it
  - Gets and prints the Advanced message
- Telnet to it to make sure it works
- Try creating another "proxy" with the same name, but in a different
  directory
- See whether the class loader can handle both

But really if I spend all afternoon hammering away at this, I'll
consider the chain unbroken regardless of how many lines of code I write
or change.  "Don't break the chain" is about doing something every day
to work toward a goal.  It isn't necessarily supposed to be quantified.
I'm exploring something new, for which I don't have any decent printed
documentation.  (I'm not going to go to B&N to buy another book on Java
unless I can't find anything good online, even though it is a gorgeous
day.)

2008-05-05

I really hope this thing is well-received.  I'm feeling positive about
it, coming off this most recent weekend, when I got the class-loading
test working.  It turns out to be fairly easy.

The next thing to try (tonight) is running a loaded class in a sandbox
with a security policy of my own choosing.

Then I'll try loading two different classes with the same name in the
same program, and see if they collide with each other.  I think they
probably will, which sucks a little.  But it just means that either the
proxy URL message will need to also include the name of the class to
load, or there will need to be some sort of standard file in that proxy
URL resource that gives the name of the class to load.

I would really rather it were okay to have different classes with the
same name.  There's nothing in the Java code that, in the abstract,
should make it impossible, as far as I can tell.  I don't believe these
dynamically loaded classes can be invoked by compiled code.

I don't know.  It probably doesn't work.

But the bad news is that even in the best case, ...

Wait, the bad news is that if two sites have a proxy .class with the
same name, but they're different classes from different URLs -- or
probably even if they're the same class, but from different URLs --
it'll break.

Probably the solution would be to launch an external process to run the
proxy.  It only needs to communicate over a socket, anyway.  It could
get invoked with a cookie command-line parameter and immediately
handshake with the application using that cookie.  I guess that would be
reasonable security.  Better would be to use a filesystem socket, but
that would be nonportable.

I guess identical security to using a filesystem socket could be had by
creating a directory readable only by the user, and putting cookie files
in that directory.

+ Figure out how to run it in a sandbox
  + Add some privileged action in the SimpleClass, like writing to a
    file in my top-level home directory
  + Try it
    > It allows it
  + Add the magic SetSecurityManager invocation
  + Try again
    > Very good, it fails!
x Write a simple class, SuperAdvancedProxy, that listens on 0.0.0.0 and
  responds to any connection by saying "Hi!  Bye!"
x Write it to disk as well
x Write a class loader that
  x Loads and runs SuperAdvancedProxy
  x Connects to it
  x Gets and prints the Advanced message
x Telnet to it to make sure it works
> Change of plans:
  > The proxy class will stick its objects into a queue
  > The loader may or may not then hand those across a network
    connection, but for now, it will simply pick them out of the queue
- Try some more security policy tests
  > Installing the default security policy prevented _everything_ from
    happening, not just the write-to-disk
  > It looks like I need to create a policy file that grants the
    application itself all permissions, but downloaded-to-disk classes
    only those permissions needed to run a proxy
  > The application itself could write out this security policy,
    dynamically generating the directory names, when it is invoked
- Try creating another "proxy" with the same name, but in a different
  directory
- See whether the class loader can handle both

2008-05-06

I think my solution to this problem for now is to just allow everything
for version 0.01, and note security as a TODO.

So that means tomorrow I go back to the diff-wc requirements, rather
than the touchy-feely trying-new-things requirement I'm imposing right
now.

I did some reading, I made an effort.  That's going to count for today.
(Which is part of why I want to stop doing this.)

2008-05-10

+ Need bool types (no payload)

+ Location response is a class of its own, containing:
  + Proxy URL
  + Bool: are subdomains also covered by this proxy?
  + Resource regexp

+ Location response can also be another class meaning:
  + Go ask this other server
  + But "this other server" must be at least one level up in DNS from
    the one being queried

- Expect these in response to LOCATION, instead of a Pair

- A proxy can communicate with any site that is "covered" by it

This allows a site to be distributed across multiple DNS entries, or to
occupy a fraction of a single DNS entry (as before), but prevents
anyone but the owner of a machine at, say "com." from pushing out a
proxy that has the power to spam everyone under "com."

I can't for the life of me figure out how to set up a process to pull
my git repositories to another directory so they contain everything I've
committed.  I'm writing this mainly to touch this file so I can commit
it and try another pull.

I'm probably better off using rsync.  That will get me uncommitted
changes as well.  Maybe it's an abuse of git to try to make it act like
an rsync, but this seems like it would be a fairly standard way to use
it -- pulling a published project and periodically updating it.

The design is getting muddy, which suggests to me it is overcomplicated.
I'm at an impasse with ProxyClientConnection.setUrl().  For some reason
when I added a stub for it, I was sure it needed the location_regexp,
but now that I just tried to implemented it, I realize that I can't
possibly do anything with the regexp at that point.  When the client
sets the URL, it is effectively only asking the proxy to go to a
different URL.

I probably need to come up with some narratives of sequences of events
to understand how the client is going to do its part.

2008-05-12

So the simplest transaction would be:

- User enters a location URI to go to
- Viewer connects to site named in URI
- Viewer sends LOCATION query to the site
- Site responds with a ProxySpec:
  - A proxy URL
  - false: the same proxy does not handle the whole DNS subdomain
  - The regular expression ".*": the proxy handles all this host's URLs
- Viewer loads and runs the proxy, setting the location regexp
- Viewer sends the proxy the SetUrl object
- Proxy sends back the same SetUrl object to acknowledge
- Viewer receives the SetUrl object and matches it to the regexp; no new
  proxy is needed

This makes sense.  The regexp is set as part of the act of loading a
proxy, _not_ setting a URL.  Or more accurately, the regexp is set in
response to a ProxySpec message from a DVTP server -- if the proxy URL
is the same as the one already loaded, it won't be changed or restarted.
It is up to the proxy to reset its state and clear the world graph, if
necessary.

I'm beginning to think I need two different classes: UserSetUrl and
ProxySetUrl.  The client sends the proxy a UserSetUrl, and the proxy
bounces it back to acknowledge and agree to the request.  The proxy
sends a ProxySetUrl ...

Maybe there need to be three.

I'm still not satisfied with this design at all.

I think there really are three classes here:

SetUrl - the user has requested a URL via the client interface
DisplayUrl - the proxy tells the viewer to display a different URL
RedirectUrl - the proxy tells the viewer to go to a URL elsewhere

DisplayUrl would need to match the regexp, and RedirectUrl would need to
not match it.

These are three different kinds of events, and trying to overload them
with a single class is making the logic very confusing.

And much as the hard distinction between DisplayUrl and RedirectUrl
seems objectionable, these are two completely different events.  In one,
the proxy expects the client to do nothing -- it is merely informing the
user that the current view position has changed.  In the other, it is
sending the user to another world entirely, which requires the client to
take action.

I realized recently that the DVTP protocol -- the idea of this byte
encoding specification for the objects the client and proxy send back
and forth -- is essentially useless.  The client is going to either run
some sort of class loader which will communicate with the client in
whatever language the client's programmers see fit to use, since they
would be part of the same package, or the client will load the class
itself (as I'm doing), in which case the objects never get encoded or
decoded.  They're just passed through a queue of DvtpExternalizables.

But I'll no doubt find these useful when I'm programming the first real
proxy and server that must communicate over the network using byte-
encoded objects.

It does invalidate my mental image of how DVTP works.

2008-05-15

Well, this is a great way to end what has been a generally miserable
day: it turns out my class-loading test didn't really load anything at
runtime after all.  It was only able to "load" the class I requested on
the command line because it was part of the build.  It's as if the
loader does nothing.

I discovered this by copying the binary directory that I was supposedly
loading classes from, renaming the class to be loaded in Eclipse, and
then rerunning the test giving the "bin-old" directory.  It failed to
find the classes it should have found in that directory, but was able to
find classes that were only in the regular "bin" directory.

I'm sure I'll just need to learn more about class loaders.  What are the
odds that URLClassLoader actually doesn't work the way it is supposed
to?

2008-05-17

This is a little crazy.  I could have sworn I looked at fenggui and
ruled it out because of license incompatability, but I just saw on their
web site that the license is LGPL.  So that solves my GUI problem,
doesn't it?

It must have been a different one, but fenggui looks fine to me.

2008-06-05

I've been busily working on implementation.  No new ideas needed.

However, I did spot a major hole in my simple idea to allow a server at
x.y.com to specify a proxy with the ability to connect to *.x.y.com, as
a strategy for preventing proxies from turning people into spam zombies:
if I own the DNS server at x.y.com, I can easily have it return any IP
address I want -- i.e., make www.yahoo.com.x.y.com resolve to the same
IP address as www.yahoo.com.  So it actually prevents exactly nothing.

The answer seems to be this: every time the proxy wants to connect to a
site other than the one in the Location bar, the client must connect to
that site at a predetermined port (such as 1808) and ask the server: Do
you handle this URL?

Most servers could safely be configured to always answer "no", since the
question would not be asked in the usual case of a site spanning only
one server.  Servers not offering email service or other easily-abused
network services could probably be configured to always answer "yes",
though I think this option is dangerous and lazy.  Best practice would
be to answer "no" in all cases except those absolutely necessary to
support whatever weird multi-server site setup ...

Oh, I thought of a good use case, shortly before this hole occurred to
me: a world where you host your own content, but it appears in a single
contiguous plane [stitched back together by the proxy running on the
user's computer].

Smooth handoff might require some level of cooperation, but I think it
could be enforced by random testing.  Or nonrandom distributed testing:
the proxy sees the problem and reports it back to the mothership.

Anyway, that [a distributed world presented as a unified one] was one of
the things I think I originally wanted way back when I started along
this train of thought.  I just didn't realize I'd succeeded in getting
there, with my simple, minimal protocol.

I'm excited about the project again.  I think this is it -- this is the
future.

2008-06-06

I couldn't stop thinking about the possibilities of that stitched world
today.  It's almost like hosting just a DNS service and renting out
domains.

Bandwidth costs might be the biggest problem, but maybe that could be
solved by just signing the relevant information and publishing it for
wide redistribution.

2008-06-07

For sure avatars are going to be self-hosted, as well as other
possessions like in-world computer terminals.  That's how you'll be able
to surf the web from inside Distroverse -- with a wearable computer that
pops up a floating terminal window.

Anything's possible, isn't it?

It might be better not to rely on the user's ability to host his or her
own avatar, actually.  But the wearable computer idea -- that should
always work.  Those don't need to be visible to anyone else.

2008-06-09

Secure connections are going to be an issue.

Given what a thin layer there is between the proxy and the client, I
don't see any reason not to just require the proxy to get all its
Internet connections through the client -- at least for dvtps://, and
maybe for dvtp:// as well.

I guess the way to do that would be with some sort of buffer passed back
and forth. ...  I probably need to face the fact that I've designed an
API, not a data protocol, for communication between the proxy and the
client.

2008-06-10

Hold down a key and a faint circle appears over the display.  That's the
axis around which the camera moves, using arrow keys and page up/down to
move in and out, or the mouse and its wheel respectively (no click
required).  Touch controls will be swipe to rotate, pinch to zoom out,
spread to zoom in.  Touch controls will also allow tilting, I guess.
Home/double-tap to restore default view (as defined by the proxy).

This needs to be a function of the client -- camera manipulation.
Because anyone can write a client, a client that is crippled or has some
obvious missing feature will just invite replacement.  And it is
essential to make clear the idea that the client does not do anything to
obscure shapes that are sent to it -- if you want to keep something
hidden, don't send it to the client.  Better yet, don't send it to the
proxy, either.

I've been thinking "controller" would be a decent alternative name for
the proxy, but it's too long.  I don't want to type that.

The fact that I'll make EncSock (encrypted socket) a subclass of
DvtpExternalizable means a server would be able to send the client a
socket.  To reconstitute it would mean opening a socket ... ?  No.  It
would just have the location and port number properties, but would
arrive unopened.  [I guess the proxy would give it to the client
unopened, and the client would give it back opened.]  [If it
de-externalized opened, that would mean the black box that is the proxy
would be attempting to open network connections, which is how I decided
I would identify insecure connections in the client.]

I originally wanted to do smoothed shapes.  I haven't thought about that
lately, but I still think it's a good idea.  I don't really know the
best way to do it, but I guess I could just copy Verse's "creased
subdivision surfaces".  I like the idea of deleted things turning to
dust to make it obvious that they have been deleted, and to allow the
user to undelete.

If I'm going to have secure connections, obviously I need some secure
DVTP protocol, right down to GET, LOCATION, PROXYOPEN, and the
yet-to-be-defined KNOCK (requesting permission to connect).

KNOCK url >> Bool + Str (regexp)

There.  Definition special for you.

Rather than have another port for secure connections, what about having
a command to go to SSL mode?  Can I do that?

It might help if I knew what SSL really was.

2008-06-23

Linus released Linux 0.01 in mid-September 1991, and it took until
December 1992 to get to version 0.99, which I assume was
feature-complete (or seemingly so at the time) but bug-riddled.  It
took until March *1994* (!) to get to 1.0.0.

That's amazing -- not how I thought it went.  I remember I found out
about it a few weeks later -- it was up to 1.0.9 by the time I first
downloaded Slackware to floppies and installed it on a machine.  That
was actually only a month later, so maybe 0.99 was further from 1.0.0
than I thought.  It must have been; it was less than half as big.

I want the experience of a given place to be unified (in what I have
in mind for dvtp://distroverse.com/, anyway), and the concept of
subcells with potentially limited access (which I think is a fantastic
idea -- it essentially removes any need for any kind of physics from
the server) would get horrendously complicated if there were not a
single unified stitched version of the universe.

I think I just had a flash of insight into how the Cartesian fakeout
for a round planet would work.  In some polar region, the land would
just be a flat circle -- though altitudes (everywhere) would be
lowered parabolically beyond a certain don't-care cutoff to reduce
processing time for nearby objects -- so actually the world is a
truncated paraboloid always centered on the viewer.  Outside that, the
world is ... no, my idea doesn't work with rectangles.  It's going to
require trapezoids.

Oh well.  I'll figure out a good way to do that, I'm sure.  I don't
think it'll really be that big a deal.  It just requires that there be
something other than a trivial rectangle to define boundaries, and
some angle translation for moving between regions.

The circle should be fine, though.  Though I guess it will actually be
a polyhedron.  Maybe I'll compose the whole thing out of triangles.

Triangular prisms.

So the basic idea is:

- Generate a polyhedral approximation of a sphere
- ...

Wait.  The triangles won't fit together in a plane if they roughly
tile a sphere.  I could make them _really_ small and just ignore that
fact.  I think what I need to do is make an icosahedron, flatten it,
and figure out how to make some sort of equivalent plane tiling out of
it.

I think continuously warping space would be too computationally
expensive.

The more I think about this, the more I think I'd be better off just
displaying the _actual_ polyhedron, saying gravity _actually_ always
points toward the center of the planet, and relying on the bumpiness
of the landscape to make the seams of the polyhedron (which would
undoubtedly have hundreds of thousands of triangles, only a few of
which would be relevant at any moment) not noticeable.

Anything I do to avoid dealing with that reality is going to create
more difficulties than it could ever eliminate.

An Earth-sized planet would be around 12,500 miles along the surface
from pole to pole, so representing such with 12,500 rows of triangles
would mean sides roughly a mile long.  The distance between the circle
and the center of a chord intersecting 1/25,000 of the whole circle
would be ... 5 cm.

The terrain-generating code could even round that out, come to think
of it.  In case anyone would ever notice a statistically significant
grid of points spaced a mile apart that are two inches lower on
average than the surrounding points.

So no.  That would not be necessary.

And, we come back to my original idea for round planets.  Nice.

2008-06-25

Cool!  I actually have a proxy running and adding moving objects to the
viewer!

Granted, they're just getting a hardcoded default movement, ignoring the
stationary MoveSeq they're supposed to use.  And granted, only the
sphere is even really recognizable -- all three objects display
incorrectly.  But the movement is really smooth.  I like that.

Everything after this point is just details and cleanup.

2008-06-26

I thought briefly about not using names as a form of identity -- and
actually I'm already coming back to that as I write this.

My first thought was: Don't have names at all.  I'm creating an
alternate reality, and there's no physical manifestation of my name
built into my physical body, so why should a virtual one have that as a
property?  People can just learn each other's names and recognize each
other just like they do in the real world.

But then I realized that there's a unique problem: It would be
relatively easy to pose as someone else -- probably.  (There might be
features that are difficult to rip; gait, perhaps.)  So then I thought,
what about some system whereby people you've identified as a friend, and
whose identities are confirmed, have some symbol float over them (from
your point of view only)?

Then I realized that I've more-or-less come full circle.  The system
would still need to transmit a name or some name-like property for this
to work.

But it isn't exactly the same: The property to be transmitted could be
an RSA public key, verified and vouched for by the server.  Maybe the
client could do its own verification, but that seems wasteful if the
server is reasonably trusted.  So maybe that could be an optional
handshake of some kind.

The name itself might not even be transmitted by the server.  It might
be an association made only in the client based on the user's own input;
"I know this avatar as 'Jimmy James'", which may or may not be what the
avatar's user calls himself most often.

This is all relevant to implementing a site, not really to the client.
Though it might be necessary to build in some support for some concept
of identity, if friends are to be recognized wherever they are and not
just within a given site [the one where they were met].

People will probably, make that inevitably, want to choose which
identity they're broadcasting at any given moment.  That's the supposed
death of social networks -- when you accumulate too many "friends" you'd
rather avoid.

Marking of recognized avatars would have to be done entirely within the
client to avoid leaking friend information all over the place.

Shouldn't be a big deal.

2008-07-13

I've been trying to figure out why PassThroughProxy.connect() hangs in
SocketChannel.register() for a while now.  I'm going to try to compile a
sequence of events for both the PassThroughProxy startup and DvtpServer
startup (which does work), and see if I can spot the problem.  It seems
to me that a Selector should be designed not to hang like that, but I'm
sure it's ultimately a symptom that I'm doing something wrong, and not a
bug in Java 1.5.  It's unlikely I would discover such a thing after so
relatively little work.

DvtpServer.createServer():

> Instantiate a new DvtpMultiplexedListener using the two parser classes
> Instantiate a new DvtpServer implementation using the listener
> Create a DvtpServerInQueueObjectWatcher thread using the server
> Start the watcher thread
> Set the watcher on the listener to the newly-activated watcher thread
> Set the greeting on the listener
> Call serve() on the listener
> (Seconds pass)
> A client connects to the server

ProxyClientConnection.runProxy( ... PassThroughProxy ):

> Instantiate a new DvtpProxy (PassThroughProxy)
  > NetProxyBase constructor:
    > Instantiate a new DvtpMultiplexedClient using DvtpFlexi*
    > Create a DvtpProxyInQueueObjectWatcher using the DvtpProxy
    > Set the watcher on the Multiplexer to the one just created
    > Start the watcher thread
    > Start the multiplexer
  > SingleServerProxyBase constructor does nothing
  > PassThroughProxy constructor does nothing
> Set the proxy-to-client message queue on the proxy
> Create a thread that will call the proxy's run() method
> Start that thread -- PassThroughProxy.run():
  > Does nothing

I don't see how this explains the hanging behavior, but it seems to me
that the run method should probably do a lot of what I have the
constructor doing.

No, register() still hangs.  (Though I still think it's better written
this way.)

So now I have:

DvtpServer.createServer() -- works:

> Instantiate a new DvtpMultiplexedListener using the two parser classes
> Instantiate a new DvtpServer implementation using the listener
> Create a DvtpServerInQueueObjectWatcher thread using the server
> Start the watcher thread
> Set the watcher on the listener to the newly-activated watcher thread
> Set the greeting on the listener
> Call serve() on the listener
  > Open a ServerSocketChannel
  > Open a Selector
  > Bind the ServerSocketChannel to port 1808
  > Register the ServerSocketChannel with the Selector
  > Call DvtpMultiplexedConnection.run()
    > Call Selector.select()
> (Seconds pass)
> A client connects to the server

ProxyClientConnection.runProxy( ... PassThroughProxy ) -- broken:

> Instantiate a new DvtpProxy (PassThroughProxy)
  > NetProxyBase constructor:
    > Instantiate a new DvtpMultiplexedClient using DvtpFlexi*
      > Open a Selector
  > SingleServerProxyBase constructor does nothing
  > PassThroughProxy constructor does nothing
> Set the proxy-to-client message queue on the proxy
> Create a thread that will call the proxy's run() method
> Start that thread -- PassThroughProxy.run():
  > Create a DvtpProxyInQueueObjectWatcher using the DvtpProxy
  > Set the watcher on the Multiplexer to the one just created
  > Start the watcher thread
  > Start the multiplexer thread (DvtpMultiplexedConnection.run())
    > Call Selector.select()

Maybe the problem here is that I can't add sockets to the selector while
it is in Select().

Maybe DvtpMultiplexedClient.connect() needs to pause the selector
somehow.  That actually makes sense.

But then activateNetworkReader() would block if the other thread was in
select().

That might well be an unencountered bug; activateNetworkReader() only
calls register() if the queue had previously been full (which has never
happened yet), or the first time it is called, which in case of the
server would happen in a function dispatched by the Selector reader.

So probably this needs to happen inside addSocket, to avoid duplication
of code, and it should _not_ interrupt the selector thread if it is not
currently blocking on select().

2008-07-14

My prize for getting this bug fixed will be that I get to stand in line
for two hours for an iPhone.  I hope two hours!

I'm really uncomfortable exposing the lock that the multiplexer uses to
block selects so that others can register new connections on the
selector.  Exposing the selector itself is arguably an unclean
interface, but exposing a lock is the kind of thing that makes it hard
for me to sleep at night.  I'm thinking of this as an alternative:

public Object withBlockedSelector( Callable fn );

A method that block/pauses the selector, calls fn.call(), and then
unblocks it in a finally clause, so it's guaranteed to do the right
thing.

As much attention as I had to pay to getting the sequence exactly right
within DvtpMultiplexedConnection.run(), I suspect I would rather keep
even a relatively simple lock/unlock in one place inside the class as
well.

I might be able to shuffle some code around so that the selector is not
exposed.  If I can't find a solid reason for exposing it, I might try to
do that.

The problem is that NetInQueue/NetOutQueue are the only classes that
even theoretically need to touch these innards of the multiplexer, and
there's no concept of a friend class in Java (which is fine, I guess;
nested types appear to provide the same basic capabilities).  I could
feed references to these things in the niq/noq constructors, but I'd
rather just keep them encapsulated completely.

Anyone who writes a proxy or a server is going to get their grubby
fingers on the multiplexer, so it makes sense not to have stuff leaking
out of it.

2008-07-16

Sometimes a proxy might want to gather more than one object from a
server before invoking a callback.  I think it should probably work
something like this:

asyncCallback( Function< FunRet[] > c, FunCall fns... );

Hm.  Where'd the complexity go?  I started writing out a bunch of
implementation crap and realized there was no reason to do that at the
point of use.  But here's what it'll do inside (which is slightly better
than my first idea anyway):

Get a new unique function call/return ID for each FunCall.  Register
those IDs with a data structure mapping outstanding return values to the
callbacks they need to be fed to, send the FunCall objects to the
server, and as each return value is received, remove it from the
outstanding-value data structure and increment (decrement?) a counter in
the callback data structure.  When that counter indicates all arguments
have been reached, invoke the callback with those FunRets.

This still leaves the issue of timeouts unhandled.  That's something I
just haven't dealt with at all in the project so far, and I think I'll
probably leave it for v0.02 at least.  It's an interesting problem.
Probably:

asyncCallback( Function< FunRet[] > c, float timeout, FunCall fns... );

and

asyncCallback( Function< FunRet[] > c, float timeout,
               Function< FunRet[] > timeout_handler, FunCall fns... );

where timeout_handler could take nulls for the unfilled positions, and
so would 'c' if timeout_handler were not supplied.  A timeout_handler of
null would mean just drop the request if it times out.  In any case,
FunRets that don't match up with anything would need to be dropped.

I can't wait until I get to start writing servers in Clojure, after all
the low-level stuff is taken care of.  There are so many things that
would just be so much easier with macros.  Repetitive, dumb things.

This will be an interesting problem:

- Proxy sends client an AddObject
- Proxy immediately sends client a Move targeted at that object
- Client handles the AddObject in one thread
- Another thread picks up the Move before the object is added

Uh oh!

I'd hate to have the other thread block; maybe it could get re-added to
the back of the queue along with some kind of counter so it could give
up after N retries?  Maybe there could be a lowest-priority retry queue
for that?

Maybe I need a Retry class, with an int counting down to zero, and the
payload class <T extends DvtpExternalizable>.

I've been thinking it would be a nice idea to turn the queues into
priority queues anyway, but I haven't thought at all about how to do
that.

2008-07-18

I think I need to make unit tests for DvtpExternalizable reading and
writing.  I believe I still have problems with them, so why not just get
them all ironed out and be able to stop worrying about it?

Seems like a really easy unit test to write, too.

2008-08-01

Inventory is just like cookies, except that anything can write to the
inventory (within some reasonable constraints -- possibly a per-site or
just per-session quota), every item in the inventory must have some sort
of visual representation, and only the user can read from it, by
dragging and dropping items into the viewer window.

That should be general enough to take care of everything, but I'll
probably want to have some standard metainformation to go with each
item, since items will need to be [at least potentially] shareable
across all sites.

2008-08-11

This might be completely unnecessary, but ...

I'd been thinking a few days ago in the shower about the problem of
multi-pipeline race conditions (this part _is_ necessary), where two
messages come through the message queue from the proxy to the client,
one after the other -- an AddObject, and then a MoveObject on the
just-added object.  To improve threading performance, incoming objects
are added to different queues handled by different threads on a
round-robin basis.  The problem is that this introduces an obvious race
condition, where the MoveObject is handled before the object it refers
to is added.

I had been thinking that I would have to do something ugly like
busy-wait in the thread with the MoveObject until the referred-to object
exists, and just hope it doesn't happen very often, but ... "ugly" isn't
a strong enough word.  This is a crime against humanity -- the amount of
wasted electricity CPUs would burn busy-waiting, if the client were ever
popular, could be enough to power a small city.  That would be an
unconscionable amount of waste for a single person to be to blame for, I
think.

Not to mention the fact that it opens a can of worms about detecting
whether the hoped-for AddObject is actually in one of the queues.

So, anyway, in the shower, I realized the answer was to just hash the
object ID and use that to assign the incoming message to a queue.
Perhaps there could be more queues than the number of threads servicing
them, to reduce the likelihood of a particular queue getting severely
backed up because it happens to be handling a couple of highly active
objects.  (Maybe the thing to do when a single queue has too many
objects is to rehash, though.)

But then I immediately thought of a denial-of-performance attack:
Suppose an unnamed corporation wants to make the free software client
look bad in comparison to their own proprietary embrace-and-misimplement
client.  Suppose that there are typically no more than 8 queues, since
most people don't have more than 8 CPU cores, and more queues would just
add wasteful overhead.  They could just bump object IDs by 840 (which is
divisible by every number up to 8) every time, instead of, say, one.  If
I used the standard Java int hash (which is just the value of the int
itself), all such objects would be funneled through the same queue, and
handled by the same overworked thread, with the others sitting idle.

This code (in Perl, trivially converted to Java) avoids the problem:

sub rehash
  {
  my ($in) = @_;
  return (($in ^ 2_348_942_530) * 3_177_073_841) % 4_294_967_291;
  }

2_348_942_530 is a stand-in for just any random int, generated at
runtime, and regenerated to rehash things without changing the number of
queues, such as when a queue backs up with no single object making up
more than 60% of the queue contents.

My claim is that even if a proxy could know the number of queues, it
would not be able to generate a sequence of object IDs such that the
hashed IDs would have a statistically significant chance of ending up in
the same queue, aside from sporadic brief runs.

Adding another XOR and another MUL would make it even stronger, I guess.

Or it might do nothing at all.  Whatever.

2008-08-12

I'm on the fence on the issue of whether I should even keep trying at
upgrading to the latest jME.  The way it blew up when I made a
half-assed effort at it over the weekend, corrupting my entire desktop
login session, made me wonder whether jME is even being developed
adequately for the Mac.  I should at least give it the full ass, though,
before I give up on it.

But the idea [of staying with the old jME] is not altogether
unappealing.  From the demos I've seen, I think it was capable enough --
or at least, _some_ version of jME exists that can run well on a Mac and
can do visually stunning things.

All I really need at this point is something visually competent.

Building an application that people can download and do interesting
things with ... that's a worthwhile goal.  The version of the library I
use to do that isn't especially important.

2008-08-22

Okay, I changed my mind about rehash().  I don't even need this function
yet, so this is just another form of procrastination before upgrading
jME, but here it is:

sub rehash
   {
   my ($in) = @_;
   my $ret = (($in  ^ RANDOM1) * 3_177_073_841) % 4_294_967_291;
   $ret    = (($ret ^ RANDOM2) * 2_905_924_783) % 4_294_967_291;
   return $ret;
   }

That seems to do a pretty good job.  This is not worth worrying about,
anyway, because it doesn't need to be consistent from run to run; it
could even theoretically be changed in the middle of a run after
flushing all the pipelines first.

One problem with the rehash scheme: there might be messages that address
more than one object, and (though I haven't decided on the architecture
for this yet) there might be messages to add bitmaps, which might be
required by an object whose ID can't be known when the add-bitmap
message is sent.

Another possibility would be to create unfilled references as each
object is dispatched to a handler pipeline.

I don't even know whether any of this will be necessary -- whether the
CPU time to handle the messages themselves will really be an issue.
That's the most important reason I shouldn't be wasting any time on this
right now.

It's just a fun little puzzle I'm letting myself get distracted by
because I'm not single-mindedly focused on a goal right now.

2008-09-05

I was thinking about my packrat web browsing habits recently after I
lost a long-running Safari process when the laptop wouldn't wake up.  It
had been running for over two months, and I had collected maybe 100 tabs
that I thought might be useful or interesting later.  Rather than
bookmarking them, since bookmarks suck, I just left the tabs open.

What would work better for me?  I was thinking about maybe a better
history mechanism, but I don't think that's really it.  Maybe I need
better bookmarks.  Maybe it's a combination of the two.  Maybe I need to
be able to rate a site as interesting!  That's it!  I don't want to have
to "manage" bookmarks to keep them organized enough to be useful, and I
don't want to sift through a pile of history.

I want to feel like I can find an interesting site, do something, close
it, and know that I will be able to find it again if I want to.

That's easier to do with web pages, I guess, than with VR.  Text creates
so many opportunities for clever algorithms.

I want to encourage sites to offer metainformation as much as possible,
but I just know that isn't going to happen.  Probably the best I can do
is capture text that is sent.

Maybe if it is clear that metainformation is the only way to get found
in Google, people will use it.  To some extent, though, I suspect Google
is going to learn from textual links to DV sites.

So in case it wasn't clear above, "do something" would consist of, for
example, bumping up a score, maybe with a simple up-arrow, or maybe with
something a little more complicated.  Then you could look at your
history in multiple different ways: most-visited, most-visited by domain
name, or highest score.  Or highest score by domain name.

Or chronologically, of course.

There's also the idea of freezing a tab, which would put it into some
sort of pile of visual representations of them.  If I could do that with
a Safari window, I'd love it -- just put away a window, storing all the
data to disk, and have some window I could get at and flip through those
stored windows to get one back, with all its tabs, without having to
reach out across the network.

Better yet, when these pages reload, they should at least be _able_ to
find the last downloaded copy in the cache.  None of this is relevant
(as far as I know) for DV, but I can't help mixing my ideas about the
Viewer with my ideas about a web browser.  It seems probable to me that
the Viewer will include web browsing functionality at some point, most
likely with a proxy.

My thought was that certain protocols other than "dvtp" would correspond
to a hardcoded proxy.  For example, a location starting with http: would
invoke the HttpProxy.  A location starting with secondlife: would invoke
the SecondLifeProxy.

Those could be customized, I guess.

2008-10-07

Cookie commands to support concurrency:

TestSet( Str key, DvtpExt test, DvtpExt newval, CompactUlong id ) =>
[id, key, Bool wasSet]
IncGet( CompactUlong id, Str key ) => [id, key, CompactUlong newVal] 
(or exception)
DecGet( CompactUlong id, Str key ) => [id, key, CompactUlong newVal] 
(or exception)

(I might want to rename DvtpExternalizable to DvtpExt.  I'm getting
tired of long names.)

wasSet means: Did the value change?  It would be true if the old value
of the key cookie was equal to 'test'.  In other words, if several
threads all attempted to set a flag that was initially set to false,
from false to true, only one such thread would get true returned to it.

The id is obviously so that each call can be associated with a callback
in the message handler that will receive the response.  Based on that,
the key isn't really needed, but it's duplicated for convenience.

2008-10-20

I still need to get the most basic element of the GUI, the location bar,
working, but I'm sure that won't be an intractable problem.  Meanwhile,
I think it might be a good time to start working on the
state-synchronization mechanisms.

I think I want to represent the world as an R-tree (or something
similar), with a last-changed property on each node.  I don't see any
way around the problem of repeatedly having to query the top few nodes
of the tree, which reduces performance as the universe gets bigger, even
for a single user only caring about a single part of the universe.

Ah, here's a way: a node can have a property, NoOverlaps, that indicates
no sibling node can cross its boundaries.  In other words, everything
within the geographic boundaries of the node is contained under that
node.

So long as a subscriber only cares about events within that space, it
need not worry about updates to the parent node caused by updates to
irrelevant sibling nodes.

(Updates to LastChanged would still propagate all the way up in the
server, but the subscriber would only be checking for updates to its
"chroot" node.)

Contention for updates to LastChanged on the root node are going to be a
problem.  I might need to set some reasonable limit on resolution so
that the updates stop flowing up at a certain point.

So, here's an example structure:

Top node: "universe"
Child nodes: galaxies; each galaxy having the NoOverlaps property
Child nodes: star systems, each with the NoOverlaps property
Child nodes: celestial bodies, each with its own relative coordinate
             system

So how do I do relative coordinate systems?  The node for a given
celestial body would have its own position, orientation, and movement.

If, hypothetically, multiple nodes (M) with NoOverlaps properties were
to overlap, the procedure would be:

- Create a new node P WITHOUT the NoOverlaps property, with dimensions
 encompassing all of the M nodes, and attach it to the M nodes' parent
- Remove the NoOverlaps property from the M nodes
- Reparent the M nodes as children of P
- Set the NoOverlaps property on P

The subscription model should be pretty simple.  Each node on the server
would have a list of subscribers (session IDs or user identities?), and
each time a modify method is called on the node,

Again, there would be a number of these universes coexisting, each with
its own level of detail.  A client would, for example, subscribe to a
galaxy at an extremely low level of detail that would hardly ever
update, to get enough information to render the night sky, a star system
at a slightly higher level of detail to get the local star and its
planets as disk and points respectively, again not updating much, if
ever, and the local planet at a high enough level of detail to get the
nearby terrain, and so forth.

All this happens according to a simple detail-per-distance formula.

I also thought about a reset mode that either peer on a DVTP connection
could generate if it ever read something that didn't make sense -- an
exception handler for the DVTP reader.  I was thinking it would have to
be some stream of a particular byte, waiting for acknowledgment on the
other side, and then once both sides had acknowledged the reset, they
could attempt to start over and re-synch.

Why not just close the connection and open a new one, though?

I'm not sure my idea about picking levels of detail as a function of
distance multiplied by some scalar, constantly adjusted according to the
refresh rate, is such a good one.

It seems like higher levels of detail can be tolerated as long as
refreshes are very rare.  Specifically, I'm thinking of the galaxy, but
wouldn't the distance to the galaxy always be zero whenever someone is
inside it?

What about the local star?  Should it get an artificial boost because it
is so bright?

What about rendering nearby stars accurately at night?  Is there any way
around making that a special case?  Doesn't the sky just have to be
rendered separately?

I think I'm going to start out by ignoring these issues -- do it simply
and without any special cases, and see whether it works.  If it breaks
down, I'll come up with a solution.  Of course, I'll have to subject the
simple approach to some harsh testing conditions to find out whether,
and at what point, and how, it breaks down.

I think there does need to be _something_ special for the sky, though. 
I don't see the atmosphere being an object rendered just like any other,
though I can give that a half-assed shot.  It might be a nice
simplification.

On rendering the planet, it seems to me that, as with any other object,
if something is being rendered at a higher level of detail, it should
not be rendered at any lower level of detail.

So it seems to me the planet should be a circle bitmap at the lowest
level of detail (presumably objects will be able to have a number of
impostors for different angles; that would be a property of the object
left up to the designer's discretion, but the server will likely impose
some limit to avoid over-rendered impostors that suck up too much
bandwidth), and a simple hollow sphere with a texture at the next level,
and below that, it would be a number of subobjects, each of which would
be a section of the hollow sphere.  When near enough to one of the
subobjects, it would be rendered at a higher level of detail as further
subdivisions, and so forth until individual hills and then rocks and so
forth become visible.

So how would this happen?

The first thing the client does, on connection, is set the level of
detail at an absurdly low level, getting the nearby planet as a disk and
rendering that, so the first thing the user would see, for a very brief
moment, on signing in is a crude bitmap of the entire planet beneath
them.  At this detail level (say, -8, perhaps), the planet would have
rules for gravity ending at roughly a thousand miles up, and the user's
location would be specified in latitude/longitude terms relative to the
planet, so the user would not begin falling just yet.  (When logging in
from a space station far above the planet, location would be specified
in terms of that space station, so I think the rule for gravity must be
that it should not be activated until the node describing the user's
position is loaded at a point where a gravity rule is expressed.)

(Normally, this and slightly higher levels would be cached, so this
would only be visible for a noticeable amount of time upon first visit
to a system.  And for that matter, the sun hasn't even been loaded, so
there probably wouldn't be any light with which to see any of this
happening.)

As the rendering frame rate would be extremely high, the detail level
would immediately start to be cranked up, and next the planet as a
single sphere would be loaded.  (Call it LOD -7 for now.)  Since it
would render at that level, the LOD -8 representation would be hidden. 
Perhaps the sun would be loaded at this point, too, and the proxy could
begin rendering the sky in a background thread.

Next, the planet as sections would be loaded -- LOD -6.  All sections
would render equally, including the ones on the back side, but there
should only be a handful of them.  Of course, this means the LOD -7
representation would not be visible.

Each of these sections is a subobject, though, and each one renders
independently at its own level of detail.

I'm actually not sure any of this is correct.  It seems likely to me
some local objects would probably render before anything else, and the
nearby terrain might render before any planet-as-disk might ever appear.

It's possible nothing at all would load for the first few LOD crank-ups.
That whole process could happen very quickly -- a series of rapid-fire
messages:

MoreDetail 1.1
 < UpToDate
MoreDetail 1.1
 < UpToDate
MoreDetail 1.1
 < UpToDate
MoreDetail 1.1
 < UpToDate
MoreDetail 1.1
 < AddObject[] ...
 < UpToDate

I think atmosphere is going to have to be its own kind of thing.  I'll
have to tinker around with that, I guess.

I don't see how, in the above exchange, the opportunity to express that
an object is already cached arises.

Maybe the AddObject is just a top-level node, and includes a timestamp,
and the client has to fetch the update if needed.  But that seems like
the opposite of a publish/subscribe model.

Needs more thinking.

As for updates on user actions, the client by default can't set the
avatar's location (unless it has permission to do so); it can only set
speed (with a smooth acceleration curve), and with limits imposed on
speed and acceleration as determined by the server.  Collision detection
may or may not be up to the proxy and client, but access restrictions
will be enforced with regional border controls.

The proxy doesn't get to request arbitrary regions; it can only set the
detail level and get regions centered on the avatar.

Regions can be Opaque, meaning that they and their contents are only
visible from the inside, and entry would presumably be restricted as
described above.

I think this is enough to get started with.

I think I like the paradigm jME uses of having an update() method where
changes to state happen, and a render() method where the state is
displayed, during which time it cannot be changed.

It's painfully single-threaded, though.

If each node had its own update queue, it could be multi-threaded.

Or, to make it more tractable, there could be a ring of update queues,
hashed by the node ID.  What was my solution for the problem of state
changes affecting more than one object ID (such as reparenting) at a
time, last time I was thinking about this pattern?

I'm not sure I _did_ have a solution.

One possibility would be this:

- For a state change request, make an ordered list of affected objects
- Put the request in the queue owning the first affected object
- When it reaches the front of that queue,
  - If the second affected object exists, put a copy of the request at
    the front of the queue owning that second affected object, but with
    the first one removed from the ordered list of affected objects;
    wait for the request to complete (oops! deadlock here)
  - If the second affected object does not exist, put a copy of the
    request at the back of the queue owning the second affected object,
    chopped as above, and wait for the request to complete

Thinking about the deadlock possibility this creates, where a request
affects three objects, and the first and third are in the same queue, so
the second request ends up waiting for a third copy of the request to
proceed through a queue that is blocked, and the complexity needed to
solve that deadlock problem (which I think _is_ feasible), makes me
think that I'd be better off with a pure functional approach:

- render() treats the state tree as read-only
- update() runs simultaneously, also treating the state tree as
  read-only and creating a new state tree
- When both methods finish, the old state tree is discarded and the new
 state tree is swapped in

The problem with this is that copying and GCing all those objects could
be tremendously expensive, but if copies of unmodified objects are
shallow, this might not be a problem at all.

Further, I had months ago had the idea to use two state trees, one for
stationary objects, and one for moving and otherwise rapidly-updating
objects, reasoning that at any given moment, most of the world would be
mostly static.

That seems like a really good idea.

But where does a rotating, revolving planet lie in such a system?  Am I
going to have to give up my dream of a literally-represented universe of
planets and galaxies?

Can an object be static relative to a dynamic parent node?

Good grief, when do I get a Ph.D. for this?

This might be a distinction without a difference, though.  It might
happen all by itself, in the ideal way, with my LastChanged property. 
"Static" might be a property any node can have, as long as all its child
nodes are also Static.

So this might be purely a matter of grouping: once a Static object
suddenly starts moving (say, it has a script; a concrete example would
be a parked car put into gear), it needs to be reparented to something
non-Static.  The specific strategy for reparenting ... that's an
interesting issue.

I was thinking of a boat as an example, because I hate always using cars
as examples or analogies, but boats in dock aren't stationary, are they?
It would be better for them to wobble back and forth a bit.  But we'd
want to be able to see the boats in the marina from four or five blocks
away, ideally, and that could be computationally intensive.  So would it
not make sense for simplified representations of objects to also have
simplified movement scripts?

Yes.  Yes, it would.

If a Static object's children must all be Static, is there any hope for
a planet being Static?  Or any of its regions?  Or would there tend to
be that Static/non-Static schism at the planetary level?  If so, would
reparenting a car, when it starts, be a long march up and down the tree?

I also need to figure out whether there's any way this machine actually
runs, ...

I'm not even clear on whether I'm thinking about the proxy, the client,
or the server, come to think of it.  Do I really want to complicate the
protocol with these Static/non-Static issues?

I should probably leave these issues in the back of my mind somewhere,
and start with something really simple.  Then I can figure out how to
improve it.

The focus right now is on implementing a simple, easy-to-understand
world, and implementing the simplest client that makes that possible.

2008-10-21

When a user connects to a site for the first time -- a site with a
concept of identity -- he'll need to choose which ID to give to that
site.  The user interface for doing this is something to implement in
The Future, but I want to at least implement the back-end mechanics of
it now.

So, to get started on the real WorldServer, I'll need the following
exchange, in this case using an unsigned identity:

- Proxy->Client: GetCookie( "ID" )
- Client->Proxy: Cookie( "ID", false, null )
- Proxy->Client: AskInv( "ID", "ID" ) (Inv = Inventory)
  > This will cause the browser to prompt the user to drop into the
    dialog window providing an "ID" (the first parameter), which will be
    copied to the site's cookie named "ID" (the second param)
    > In this case, "ID" (first param) is special, so it can get an
      extra-special dialog box with links to help about how IDs work
  > But for now, it'll just have the client automatically copy
    inventory:ID to cookie:hostname:ID
- Client->Proxy: ReplyInv( "ID", true, ("dreish", public key, (sigs)) )

I'll need to decide how the cookie contents get encoded.  Probably as a
DvtpExternalizable object.  Yes, of course.

I probably need a Dict object, which would just externalize the same way
as a list, but would have a unique-key restriction and hash-table access
methods.  I'm a little leery of stuffing a complex data structure into a
list, but maybe I shouldn't be in this case.

Then, the server will need to confirm the identity by asking the client
to sign a particular string (most likely something like
"207.138.43.173#38501 is dreish at 2008-10-21 14:08:30."); the client
would append a random string and send the whole thing back, signed. 
I'll skip this for now, fun though it would be to do, and just have the
server believe whatever it is told.

Then the server would say, "I know I've got 'dreish' connected to me;
have I seen this user before?"  Checking the server's user info
database, if the user was not there, it would be initialized from the
skeleton user, providing at the very least a location.

The server could send the proxy a simple x/y/z position, without
necessarily telling the proxy what the position is relative to.

The server will pick a starting detail level, presumably very low.

Then I think it would be up to the client to pull data with MoreDetail. 
I think the client should also not send MoreDetail requests while the
proxy indicates it is in the process of loading data, for which there
will need to be a LoadingState( bool ) message.

2008-10-22

I think the architecture is going to initially be strictly based on the
pass-through proxy, and then I'll make the following major changes:

- Caching with cookies
- Generating elements of the user interface, especially ones that need
  to be responsive like menus and in-world editing, in the proxy rather
  than on the server

I'll want to set up the framework for caching beforehand, I think.

The conversation is a little non-obvious to me.  How will it work?

Somewhere, some party will initiate the chain of events: "Get
surroundings for point P at detail level D."  [D being something
extremely low; possibly too low even to load anything.]

- The server will send the proxy the message HoldLoadingState = true
- The proxy will send the client LoadingState( true ) and will not reset
  it, despite the loading queue being empty, until receiving
  HoldLoadingState = false
- The server will check its data structures for the lowest detail level
  with any content
- The server will compute the query zone for that detail level
- The server will look for any nodes in that detail level and zone
  > This is a depth-first search, terminating on any branch when a match
    is found, so the smallest set of nodes containing all nodes within
    the search area will be returned
  > A node must be sent with the IDs of its subnodes, and their physical
    extents and timestamps
  > Note: a client will also be subscribed to changes to all parents of
    all nodes it is subscribed to, but will only be informed of those
    changes if they contain additions also within its area of interest
- The server will send those top-level nodes to the proxy
- The server will send the proxy the message HoldLoadingState = false
- The proxy will check the cache for the contents of those objects, and
  their children
- The proxy will send the client AddObject messages every time it
  finishes constructing a complete object
  > Can work on partial loading later; N.B. this is a function of the
    proxy, not the client
- Any object not cached, or out-of-date, will cause the proxy to send
  the server a GetObject message and send the client
  LoadingState( true )
- Any time the queue of objects to load is empty, if the proxy has
  HoldLoadingState = false, the proxy will send the client
  LoadingState( false )
- This enables the client to send the proxy a MoreDetail message, which
  will start the process anew

Simple as pie!

Unlike in a Unix filesystem, any update to the timestamp on an object
will also update the timestamps of all ancestor objects.  (I might want
to maintain dual timestamps for this -- one for resource modified, and
one for children modified -- in case a node can have both a shape and
children.  Unless I decide they can't, but that might be unwieldy.)

Nothing in my plan accounts for replacing low-detail representations of
objects with their higher-detail replacements, though.  That probably
won't be too difficult, but I'll need to figure it out nonetheless.

Because of the harsh limits on bitmap detail for low-detail objects,
most such objects will probably use simple generator functions with a
few parameters, or maybe small tessellations.

Maybe an exception could be made for bitmaps that are already loaded,
but that sounds complicated.  I'd rather just get the low-detail
rendering over and done with, not get fussy trying to make it look good,
and then move on to higher detail.

I think I figured out how to make my R-tree thing scale: any time a node
is created or resized (unless strictly shrunk), its parent node, and any
sibling node with an overlapping extent is considered to have changed as
well.

Then, whenever a subscribed node changes, its parent node (if not also
subscribed) will also need to be checked for being out-of-date.

This way, a client will only need to subscribe to the smallest nodes
that are completely within its extent of interest.

No, wait.  That doesn't work.  There must be some way of doing this.

2008-10-23

I think I figured it out.

I'm mixing together two ideas that need to be separate: updates, and
caching.  For updates, every node will have a list of subscribers; a
subscriber has dual arrays, indexed by detail level [one for negative
numbers and one for nonnegative], of zones of interest.  (I think zones
and notification events will probably need to be spheres.)  A subscriber
will also have a list of nodes subscribed to, which can be lazily
garbage collected; nodes will be unsubscribed actively when an event
happens, and the event handler notices that a claimed subscriber is
actually no longer interested in the entire extent of the node [not just
the event].

For caching, the upward-propagating timestamp system I had in mind
earlier is the right one.  The important thing to realize is that
updating a timestamp on a node is not, in and of itself, an event in
that node requiring notification of subscribers.  It is strictly for
clients that have not been keeping their representation of a particular
area in sync, to determine how far down they need to fetch when they
begin watching a node.  [Put more positively, an update on a node [such
as would trigger notifications to all subscribers] is: a change in the
shape or movement of the node, a change in the extent of the node or an
immediate child node, the addition or removal of a child node, or the
reparenting of the node.  A modification of a node, for the purpose of
updating its timestamp, is either an update as above, or a modification
of any of the node's children.]

That leaves one scaling issue with the timestamps: a large enough
universe will quickly reach the point where contention for updating the
root node becomes an issue.  Therefore, whenever a node reaches that
point, where threads have to start waiting to update it, it and any
parents not already so marked will be marked as NeverCache, and the
timestamp update will never propagate up to or beyond that node.

This should be especially helpful when a site is spread across multiple
servers.

That one's going to be fun.  Oh boy.

What about massive subterranean complexes beneath an empty field, for
example?  Wouldn't they generate an unfortunate rendering load as the
detail level cranks up to take in the wider landscape?

No, not if the complex is composed of numerous carefully-constructed
opaque nodes.  That's one of the two main reasons for opaque nodes, the
other being privacy: as a sort of higher-level culling.

Opacity will be controlled entirely by the server, for obvious reasons,
and will probably be based on various conditions, depending on the
application.  One obvious application is locked rooms; for those, any
attempt to enter will have to be rejected unless the room is unlocked
and the person entering is entirely within an open access point such as
the area in front of a front door.

Another application is just reducing rendering load with no implied
privacy or secrecy; for those, the node would be made transparent
whenever the viewer is within the specified area.

Jumping to another track, revisiting my LOD table from a long time ago:

Actually, this [table I proposed earlier] might be be fine.  Detail
level would undoubtedly be much higher in an open field where one might
be able to see far away.  I.e.,

LOD  Radius   Translation
 1    100 m   From across field (1 block away) can see prim hair
 0    316 m   From 1/2 mile away, can see arms & legs
-1      1 km  At end of football field, can see spritars at far end
              This is also roughly a city block; can't see people
              at all beyond that
-2    3.2 km  Tall (30') trees visible within 2 miles
-3     10 km  Towers (100') visible up to six miles away
-4     32 km  330' hills and larger visible within 20 miles
              Flat city sprites 0.5+ miles wide also visible
-5    100 km  3300'+ mountains visible within 60 miles
-6    316 km  Olympus Mons cliffs visible from 200 miles away
-7   1000 km  No practical effect   (>1,000 km objects)
-8   3160 km  No practical effect  (>10,000 km objects)
-9     10 Mm  No practical effect (>100,000 km objects)

I think the Radius(LOD) function could probably stand to be much
better than just sqrt(10)^(-LOD) * C.  This does seem to have too much
detail nearby and too little far away.  The function could reasonably be
pretty complicated, I think, and could include avatar size as a
parameter.  The above results actually look pretty reasonable, though. 
Maybe there should just be an upper limit on LOD as a function of avatar
size, or a discontinuous sudden drop-off at a point that is a function
of avatar size.

I think I can improve the scalability of the system even further by
combining two ideas: separate trees for stationary and moving objects.
[And what else?  I obviously got distracted here.  NeverCache?]  The
tree of moving objects would make liberal use of NeverCache.  The static
objects, much less so, though still probably at the planetary level at
least.  (Planets would be static because their movement would be
permanent.)

2008-10-24

LOD radii should probably be in proportion to the size limit, so
10^(-LOD) rather than sqrt(10), which would mean a greater rendering
load from faraway objects -- maybe something between the two would be
ideal.  In any case, bright light sources should get a huge LOD bonus so
they are among the first things to load.

Moons might be somewhat late loading under this plan, though.  But they
are more-or-less decorative, so maybe that's okay.

2008-10-25

An avatar will have a location relative to some node with the
LocationBase property.  I think the entire world, as rendered by the
client, will need coordinates relative to that base, or else floating-
point resolution will be too low to represent the entire universe.

The problem I see with this is that whenever the avatar gets reparented,
every object being displayed by the client will need its location
changed simultaneously.  A ProxySendable such as TransformWorld might
solve the problem.

No, I'm an idiot.  The tree will only need a relatively minor transform,
rotating to a different root node.  The key is that the avatar's parent
node will be the root node of the client's representation of the world.
Grandancestor nodes of the avatar will be represented as children of
that root node.

I'm going to need to draw several pictures to figure this out.

Transaction (ProxySendable):
   TopNode
   ProxySendable[]

All ProxySendables in a Transaction must be applied within the same
update() call.

To avoid race conditions, an event happens in this order:

- Parameters in the node are updated
- The timestamp is updated
- Ancestor and immediate child NodeRef timestamps are updated, stopping
  at a NeverCache node
- Subscribers are notified

And a node request is served in this order:

- The requester is added to the node's subscriber list
- The node is returned

Does NeverCache just mean lastUpdated = Float.POSITIVE_INFINITY?

2008-10-27

AddObject might as well have a WarpSeq.

Unlike a MoveSeq, it would be perfectly valid for a WarpSeq to be empty.
That would just mean the shape is not changing.  An empty or nonexistent
MoveSeq would mean the object would not have a location, in which case
it should not have a parent node.  There's no need to add such objects
to the client.  They can merely be hidden and then revealed when needed.

A DNode needs a radius.

My idea had been that moving nodes would need to be put under a node
with a big enough area to contain the node throughout its entire
movement.  That probably means that user-controlled vehicles shouldn't
have MoveSeqs longer than maybe 10 or 15 seconds, or perhaps a minute,
to prevent them from being put under very high nodes and creating a lot
of load for all clients.

I'm torn on whether a client [really I'm thinking of the WorldProxy
here] should load all children of a node it is interested in, or just
the ones within its range.  Maybe the answer is to have every shape
contained within a shapeless node.

Also, how does my idea of opaque nodes complicate my plan to have the
server choose parent nodes for moving objects based on their movement? 
Answer: a lot.  [Or maybe it doesn't.  Maybe the answer is just that the
node becomes transparent when the condition is met; not necessarily that
the avatar becomes a child of that node.  Also, I might want to display
an alternative node as a substitute for an opaque node.  And I'll need
to figure out how the node becomes opaque again when an avatar leaves,
such that there aren't ways of leaving that skirt around it.]

Also troubling me at the moment: when an avatar comes close enough to,
say, a city that had been represented as a single flat bitmap, and it
can begin to be represented as individual buildings, those buildings
would come into range one-by-one, but the sprite version of them would
disappear all at once.  How do I deal with that?  Say that any object at
detail level N, where the detail N-1 representation is within range but
is not being displayed because some other part of it is being shown at
level N, will also be displayed at level N.

2008-10-29

I would love for the server to eventually have the capability to do live
upgrades like this:

- In normal operation, the server frontend talks to a data backend that
  keeps a journaled database synced to disk at all times
- In preparation for a database upgrade, a command is given to the
  frontend to detach from the database server:
  - All further writes to the database are queued, and written objects
    are kept locally cached for future reads
  - After the database reports that it has flushed out all updates,
    reads are done by the frontend directly off the backing files; it
    will have rudimentary database-reading capabilities
  - At that moment, the database can be shut down, a quick backup made
    of the files and the frontend's journals, and the database restarted
  - When it comes back up, it will first begin reading the modifications
    cached by the frontend, as it would handle writes normally,
    journaling them and bulding up a local cache of modified data no
    longer in sync with the disk as it goes
  - If it dies before finishing this process, the old files could be
    put back and the old server could be started automatically; this
    would work transparently
  - Once it has finished reading the modifications, the frontend server
    can nullify its local cache of the written data and stop reading
    from the files
  - The journal of all changes since the upgrade would continue building
    up until the new server is accepted as stable
- The same process could be used, with the new database server being the
  same executable as the old one, for holding the data in a quiescent
  state for regular backups
- For a frontend upgrade:
  - The active server gets a command to stop accepting connections
  - The new server must be started up as soon after that as possible,
    hopefully quickly enough that no one gets a rejected connection
  - Both servers would be connected to the same database; nothing else
    special ought to be necessary for the switchover
  - With super snazzy versions of the proxy, it ought to be possible to
    send a disconnect/reconnect command that is virtually unnoticeable
    to users, silently kicking everyone off the old server
  - Otherwise, it would be necessary to wait for everyone to stop using
    it, finally just giving up and shutting it down at some point

But of course, all this fits under the general category of The Future.
I sure as hell don't want to get stuck in a quagmire of trying to build
a journaling database server.

